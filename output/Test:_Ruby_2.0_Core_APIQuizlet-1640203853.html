<html slick-uniqueid="1" class="windows firefox cursor submitted" lang="en"><head><script type="text/javascript" src="http://bam.nr-data.net/1/a92c37725f?a=124534&amp;v=885.a559836&amp;to=YVcEY0EAXUJYVkUMDlgdJUJAFVxcFmFUFhUZWwhTVhk%3D&amp;rst=1195&amp;ap=982&amp;be=315&amp;fe=872&amp;dc=125&amp;f=%5B%5D&amp;perf=%7B%22timing%22:%7B%22of%22:1640203852074,%22n%22:0,%22u%22:172,%22ue%22:172,%22dl%22:176,%22di%22:440,%22ds%22:440,%22de%22:440,%22dc%22:1180,%22l%22:1187,%22le%22:1187,%22f%22:1,%22dn%22:1,%22dne%22:1,%22c%22:1,%22ce%22:1,%22rq%22:1,%22rp%22:167,%22rpe%22:288%7D,%22navigation%22:%7B%7D%7D&amp;at=TRAHFQkaTkw%3D&amp;jsonp=NREUM.setToken"></script><script src="http://js-agent.newrelic.com/nr-885.min.js"></script><script type="text/javascript" async="" src="https://ssl.google-analytics.com/ga.js"></script><script type="text/javascript" async="" src="https://secure.quantserve.com/quant.js"></script><script type="text/javascript" async="" src="https://sb.scorecardresearch.com/beacon.js"></script><script src="https://pagead2.googlesyndication.com/pagead/managed/js/adsense/m202112060101/reactive_library_fy2019.js"></script><script async="" src="//www.google-analytics.com/analytics.js"></script><script src="https://partner.googleadservices.com/gampad/cookie.js?domain=whyfund.net&amp;callback=_gfp_s_&amp;client=ca-pub-2916049119845824&amp;cookie=ID%3De3f38363a9e1f35a-222e89990ccd003a%3AT%3D1640203570%3ART%3D1640203570%3AS%3DALNI_MYDBnrzczGyn31WvhEsLLPdeRfKkA"></script><script src="https://pagead2.googlesyndication.com/pagead/managed/js/adsense/m202112060101/show_ads_impl_with_ama_fy2019.js?client=ca-pub-2916049119845824&amp;plah=whyfund.net" id="google_shimpl"></script><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2916049119845824",
    enable_page_level_ads: true
  });
</script>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- WhyFund -->
<meta http-equiv="origin-trial" content="AxujKG9INjsZ8/gUq8+dTruNvk7RjZQ1oFhhgQbcTJKDnZfbzSTE81wvC2Hzaf3TW4avA76LTZEMdiedF1vIbA4AAABueyJvcmlnaW4iOiJodHRwczovL2ltYXNkay5nb29nbGVhcGlzLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzVGhpcmRQYXJ0eSI6dHJ1ZX0="><meta http-equiv="origin-trial" content="Azuce85ORtSnWe1MZDTv68qpaW3iHyfL9YbLRy0cwcCZwVnePnOmkUJlG8HGikmOwhZU22dElCcfrfX2HhrBPAkAAAB7eyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A16nvcdeoOAqrJcmjLRpl1I6f3McDD8EfofAYTt/P/H4/AWwB99nxiPp6kA0fXoiZav908Z8etuL16laFPUdfQsAAACBeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="AxBHdr0J44vFBQtZUqX9sjiqf5yWZ/OcHRcRMN3H9TH+t90V/j3ENW6C8+igBZFXMJ7G3Pr8Dd13632aLng42wgAAACBeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A88BWHFjcawUfKU3lIejLoryXoyjooBXLgWmGh+hNcqMK44cugvsI5YZbNarYvi3roc1fYbHA1AVbhAtuHZflgEAAAB2eyJvcmlnaW4iOiJodHRwczovL2dvb2dsZS5jb206NDQzIiwiZmVhdHVyZSI6IlRydXN0VG9rZW5zIiwiZXhwaXJ5IjoxNjUyNzc0NDAwLCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A8FHS1NmdCwGqD9DwOicnHHY+y27kdWfxKa0YHSGDfv0CSpDKRHTQdQmZVPDUdaFWUsxdgVxlwAd6o+dhJykPA0AAACWeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><meta http-equiv="origin-trial" content="A8zdXi6dr1hwXEUjQrYiyYQGlU3557y5QWDnN0Lwgj9ePt66XMEvNkVWOEOWPd7TP9sBQ25X0Q15Lr1Nn4oGFQkAAACceyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><meta http-equiv="origin-trial" content="A4/Htern2udN9w3yJK9QgWQxQFruxOXsXL7cW60DyCl0EZFGCSme/J33Q/WzF7bBkVvhEWDlcBiUyZaim5CpFQwAAACceyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><meta http-equiv="origin-trial" content="AxujKG9INjsZ8/gUq8+dTruNvk7RjZQ1oFhhgQbcTJKDnZfbzSTE81wvC2Hzaf3TW4avA76LTZEMdiedF1vIbA4AAABueyJvcmlnaW4iOiJodHRwczovL2ltYXNkay5nb29nbGVhcGlzLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzVGhpcmRQYXJ0eSI6dHJ1ZX0="><meta http-equiv="origin-trial" content="Azuce85ORtSnWe1MZDTv68qpaW3iHyfL9YbLRy0cwcCZwVnePnOmkUJlG8HGikmOwhZU22dElCcfrfX2HhrBPAkAAAB7eyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A16nvcdeoOAqrJcmjLRpl1I6f3McDD8EfofAYTt/P/H4/AWwB99nxiPp6kA0fXoiZav908Z8etuL16laFPUdfQsAAACBeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="AxBHdr0J44vFBQtZUqX9sjiqf5yWZ/OcHRcRMN3H9TH+t90V/j3ENW6C8+igBZFXMJ7G3Pr8Dd13632aLng42wgAAACBeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A88BWHFjcawUfKU3lIejLoryXoyjooBXLgWmGh+hNcqMK44cugvsI5YZbNarYvi3roc1fYbHA1AVbhAtuHZflgEAAAB2eyJvcmlnaW4iOiJodHRwczovL2dvb2dsZS5jb206NDQzIiwiZmVhdHVyZSI6IlRydXN0VG9rZW5zIiwiZXhwaXJ5IjoxNjUyNzc0NDAwLCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A8FHS1NmdCwGqD9DwOicnHHY+y27kdWfxKa0YHSGDfv0CSpDKRHTQdQmZVPDUdaFWUsxdgVxlwAd6o+dhJykPA0AAACWeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><meta http-equiv="origin-trial" content="A8zdXi6dr1hwXEUjQrYiyYQGlU3557y5QWDnN0Lwgj9ePt66XMEvNkVWOEOWPd7TP9sBQ25X0Q15Lr1Nn4oGFQkAAACceyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><meta http-equiv="origin-trial" content="A4/Htern2udN9w3yJK9QgWQxQFruxOXsXL7cW60DyCl0EZFGCSme/J33Q/WzF7bBkVvhEWDlcBiUyZaim5CpFQwAAACceyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><link rel="preload" href="https://adservice.google.de/adsid/integrator.js?domain=whyfund.net" as="script"><script type="text/javascript" src="https://adservice.google.de/adsid/integrator.js?domain=whyfund.net"></script><link rel="preload" href="https://adservice.google.com/adsid/integrator.js?domain=whyfund.net" as="script"><script type="text/javascript" src="https://adservice.google.com/adsid/integrator.js?domain=whyfund.net"></script><link rel="preload" href="https://adservice.google.de/adsid/integrator.js?domain=whyfund.net" as="script"><script type="text/javascript" src="https://adservice.google.de/adsid/integrator.js?domain=whyfund.net"></script><link rel="preload" href="https://adservice.google.com/adsid/integrator.js?domain=whyfund.net" as="script"><script type="text/javascript" src="https://adservice.google.com/adsid/integrator.js?domain=whyfund.net"></script></head><body class="oldtemplate mode test none-selected all-terms qad-is-hiding" itemscope="" itemtype="http://schema.org/WebPage" style="padding: 0px 0px 154px;">
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<title>Test: Ruby 2.0 Core API | Quizlet</title>

	<script src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/a92c37725f" type="text/javascript"></script><script src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/nr-885.js"></script><script src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/ga.js" async="" type="text/javascript"></script><script src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/quant.js" async="" type="text/javascript"></script><script src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/beacon.js" async="" type="text/javascript"></script><script type="text/javascript">window.NREUM||(NREUM={}),__nr_require=function(e,t,n){function r(n){if(!t[n]){var o=t[n]={exports:{}};e[n][0].call(o.exports,function(t){var o=e[n][1][t];return r(o||t)},o,o.exports)}return t[n].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<n.length;o++)r(n[o]);return r}({QJf3ax:[function(e,t){function n(){}function r(e){function t(e){return e&&e instanceof n?e:e?a(e,i,o):o()}function s(n,r,o){e&&e(n,r,o);for(var i=t(o),a=l(n),u=a.length,f=0;u>f;f++)a[f].apply(i,r);var s=c[w[n]];return s&&s.push([h,n,r,i]),i}function p(e,t){g[e]=l(e).concat(t)}function l(e){return g[e]||[]}function d(e){return f[e]=f[e]||r(s)}function v(e,t){u(e,function(e,n){t=t||"feature",w[n]=t,t in c||(c[t]=[])})}var g={},w={},h={on:p,emit:s,get:d,listeners:l,context:t,buffer:v};return h}function o(){return new n}var i="nr@context",a=e("gos"),u=e(1),c={},f={},s=t.exports=r();s.backlog=c},{1:12,gos:"7eSDFh"}],ee:[function(e,t){t.exports=e("QJf3ax")},{}],3:[function(e,t){function n(e,t){return function(){r(e,[(new Date).getTime()].concat(i(arguments)),null,t)}}var r=e("handle"),o=e(1),i=e(2);"undefined"==typeof window.newrelic&&(newrelic=NREUM);var a=["setPageViewName","addPageAction","setCustomAttribute","finished","addToTrace","inlineHit"],u=["addPageAction"],c="api-";o(a,function(e,t){newrelic[t]=n(c+t,"api")}),o(u,function(e,t){newrelic[t]=n(c+t)}),t.exports=newrelic,newrelic.noticeError=function(e){"string"==typeof e&&(e=new Error(e)),r("err",[e,(new Date).getTime()])}},{1:12,2:13,handle:"D5DuLP"}],gos:[function(e,t){t.exports=e("7eSDFh")},{}],"7eSDFh":[function(e,t){function n(e,t,n){if(r.call(e,t))return e[t];var o=n();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,t,{value:o,writable:!0,enumerable:!1}),o}catch(i){}return e[t]=o,o}var r=Object.prototype.hasOwnProperty;t.exports=n},{}],handle:[function(e,t){t.exports=e("D5DuLP")},{}],D5DuLP:[function(e,t){function n(e,t,n,o){r.buffer([e],o),r.emit(e,t,n)}var r=e("ee").get("handle");t.exports=n,n.ee=r},{ee:"QJf3ax"}],XL7HBI:[function(e,t){function n(e){var t=typeof e;return!e||"object"!==t&&"function"!==t?-1:e===window?0:i(e,o,function(){return r++})}var r=1,o="nr@id",i=e("gos");t.exports=n},{gos:"7eSDFh"}],id:[function(e,t){t.exports=e("XL7HBI")},{}],G9z0Bl:[function(e,t){function n(){if(!v++){var e=d.info=NREUM.info,t=f.getElementsByTagName("script")[0];if(e&&e.licenseKey&&e.applicationID&&t){u(p,function(t,n){e[t]||(e[t]=n)});var n="https"===s.split(":")[0]||e.sslForHttp;d.proto=n?"https://":"http://",a("mark",["onload",i()],null,"api");var r=f.createElement("script");r.src=d.proto+e.agent,t.parentNode.insertBefore(r,t)}}}function r(){"complete"===f.readyState&&o()}function o(){a("mark",["domContent",i()],null,"api")}function i(){return(new Date).getTime()}var a=e("handle"),u=e(1),c=window,f=c.document;NREUM.o={ST:setTimeout,XHR:c.XMLHttpRequest,REQ:c.Request,EV:c.Event,PR:c.Promise,MO:c.MutationObserver},e(2);var s=(""+location).split("?")[0],p={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-885.min.js"},l=window.XMLHttpRequest&&XMLHttpRequest.prototype&&XMLHttpRequest.prototype.addEventListener&&!/CriOS/.test(navigator.userAgent),d=t.exports={offset:i(),origin:s,features:{},xhrWrappable:l};f.addEventListener?(f.addEventListener("DOMContentLoaded",o,!1),c.addEventListener("load",n,!1)):(f.attachEvent("onreadystatechange",r),c.attachEvent("onload",n)),a("mark",["firstbyte",i()],null,"api");var v=0},{1:12,2:3,handle:"D5DuLP"}],loader:[function(e,t){t.exports=e("G9z0Bl")},{}],12:[function(e,t){function n(e,t){var n=[],o="",i=0;for(o in e)r.call(e,o)&&(n[i]=t(o,e[o]),i+=1);return n}var r=Object.prototype.hasOwnProperty;t.exports=n},{}],13:[function(e,t){function n(e,t,n){t||(t=0),"undefined"==typeof n&&(n=e?e.length:0);for(var r=-1,o=n-t||0,i=Array(0>o?0:o);++r<o;)i[r]=e[t+r];return i}t.exports=n},{}]},{},["G9z0Bl"]);</script>
	
			
<script type="text/javascript">
var _rollbarConfig = {"accessToken":"166928c224d249338a9a2123b7420b46","captureUncaught":true,"enabled":false,"payload":{"environment":"prod","client":{"javascript":{"source_map_enabled":true,"code_version":"056a5fa8e7ed9ead192db5372a9d17fa15b1af4b","guess_uncaught_frames":true}},"person":{"id":"33806798","username":"wjridge"}}};
!function(d){function g(l){if(c[l])return c[l].exports;var h=c[l]={exports:{},id:l,loaded:!1};return d[l].call(h.exports,h,h.exports,g),h.loaded=!0,h.exports}var c={};return g.m=d,g.c=c,g.p="",g(0)}([function(d,g,c){d=c(1).Rollbar;c=c(2);_rollbarConfig.rollbarJsUrl=_rollbarConfig.rollbarJsUrl||"https://d37gvrvc0wt4s1.cloudfront.net/js/v1.8/rollbar.min.js";d=d.init(window,_rollbarConfig);c=c(d,_rollbarConfig);d.loadFull(window,document,!_rollbarConfig.async,_rollbarConfig,c)},function(d,g){function c(b){return function(){try{return b.apply(this,
arguments)}catch(a){try{console.error("[Rollbar]: Internal error",a)}catch(e){}}}}function l(b,a,e){window._rollbarWrappedError&&(e[4]||(e[4]=window._rollbarWrappedError),e[5]||(e[5]=window._rollbarWrappedError._rollbarContext),window._rollbarWrappedError=null);b.uncaughtError.apply(b,e);a&&a.apply(window,e)}function h(b){var a=function(){var a=Array.prototype.slice.call(arguments,0);l(b,b._rollbarOldOnError,a)};return a.belongsToShim=!0,a}function f(b){this.shimId=++p;this.notifier=null;this.parentShim=
b;this._rollbarOldOnError=null}function q(b){return c(function(){if(this.notifier)return this.notifier[b].apply(this.notifier,arguments);var a=this,e="scope"===b;e&&(a=new f(this));var c=Array.prototype.slice.call(arguments,0);return window._rollbarShimQueue.push({shim:a,method:b,args:c,ts:new Date}),e?a:void 0})}function r(b,a){if(a.hasOwnProperty&&a.hasOwnProperty("addEventListener")){var e=a.addEventListener;a.addEventListener=function(a,c,k){e.call(this,a,b.wrap(c),k)};var c=a.removeEventListener;
a.removeEventListener=function(b,a,e){c.call(this,b,a&&a._wrapped?a._wrapped:a,e)}}}var p=0;f.init=function(b,a){var e=a.globalAlias||"Rollbar";if("object"==typeof b[e])return b[e];b._rollbarShimQueue=[];b._rollbarWrappedError=null;a=a||{};var d=new f;return c(function(){if(d.configure(a),a.captureUncaught){d._rollbarOldOnError=b.onerror;b.onerror=h(d);var c,f,k="EventTarget Window Node ApplicationCache AudioTrackList ChannelMergerNode CryptoOperation EventSource FileReader HTMLUnknownElement IDBDatabase IDBRequest IDBTransaction KeyOperation MediaController MessagePort ModalWindow Notification SVGElementInstance Screen TextTrack TextTrackCue TextTrackList WebSocket WebSocketWorker Worker XMLHttpRequest XMLHttpRequestEventTarget XMLHttpRequestUpload".split(" ");
for(c=0;c<k.length;++c)f=k[c],b[f]&&b[f].prototype&&r(d,b[f].prototype)}return b[e]=d,d})()};f.prototype.loadFull=function(b,a,e,d,f){var h=!1,k=a.createElement("script");a=a.getElementsByTagName("script")[0];var l=a.parentNode;k.crossOrigin="";k.src=d.rollbarJsUrl;k.async=!e;k.onload=k.onreadystatechange=c(function(){if(!(h||this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState)){k.onload=k.onreadystatechange=null;try{l.removeChild(k)}catch(a){}h=!0;var c;if(void 0===b._rollbarPayloadQueue){var e,
d,g;for(c=Error("rollbar.js did not load");e=b._rollbarShimQueue.shift();)for(e=e.args,g=0;g<e.length;++g)if(d=e[g],"function"==typeof d){d(c);break}}"function"==typeof f&&f(c)}});l.insertBefore(k,a)};f.prototype.wrap=function(b,a){try{var c;if((c="function"==typeof a?a:function(){return a||{}},"function"!=typeof b)||b._isWrap)return b;if(!b._wrapped){b._wrapped=function(){try{return b.apply(this,arguments)}catch(a){throw a._rollbarContext=c()||{},a._rollbarContext._wrappedSource=b.toString(),window._rollbarWrappedError=
a,a;}};b._wrapped._isWrap=!0;for(var d in b)b.hasOwnProperty(d)&&(b._wrapped[d]=b[d])}return b._wrapped}catch(f){return b}};for(var n="log debug info warn warning error critical global configure scope uncaughtError".split(" "),m=0;m<n.length;++m)f.prototype[n[m]]=q(n[m]);d.exports={Rollbar:f,_rollbarWindowOnError:l}},function(d,g){d.exports=function(c,d){return function(h){if(!h&&!window._rollbarInitialized){h=window.RollbarNotifier;var f=d||{},g=f.globalAlias||"Rollbar",f=window.Rollbar.init(f,c);
f._processShimQueue(window._rollbarShimQueue||[]);window[g]=f;window._rollbarInitialized=!0;h.processPayloads()}}}}]);
</script>


<script type="text/javascript">
	
	var Quizlet = {"LOGGED_IN":true,"SERVER_TIME":1457338266,"DEBUG":false,"willHaveJquery":false,"cstokenName":"qtkn","useGoogleTts":false,"blacklistMatcherRegex":"\/\\onffubyrf?\\o|pbpxfhpx|\\ophagf?\\o|qbhpur[\\f-]?ont|qhzo[\\f-]?nff|shpx|shqtr\\f*cnpxre|\\oavttn(?!eq)|\\oavttre|fhpxf?\\f*qvpx|fhpxf?\\f*pbpx|gbjry\\f*urnq|tbq[\\f-]?qnza|\\osng[\\f-]?nff\\o|\\oyneq[\\f-]?nff\\o|\\opnzry[\\f-]?wbpxrl\\o|\\ofynag[\\f-]?rlr\\o|\\ooybj[\\f-]?wbo\\o|\\owvmm\\o|snttbg|\\ojuber\\o|qbaxrl\\f?qvpx|\\ownpx[\\f-]?bss\\o|\\ownpxvat\\f?bss\\o|\\owrex[\\f-]?bss\\o|\\owrexvat\\f?bss\\o|\\ofhpx\\f(?:n|zl|uvf|lbhe)\\f(?:qvpx|pbpx)|\\ozl\\fqvpx\\o|\\orngf?\\f(:?n\\f)?qvpxf?\\o|(?:qvpx|pbpx)\\ffhpxre|ohgg[-\\f]?ubyr|obbgl[-\\f]?ubyr|avtthu|\\ova\\fgur\\fnff\\o|\\ova\\fgur\\fohgg\\o\/","audioSpeeds":{"ja":{"normal":83,"slow":60,"medium":70},"ko":{"normal":83,"slow":60,"medium":70},"fr":{"normal":100,"slow":60,"medium":75},"default":{"normal":100,"slow":70,"medium":85}},"bigqueryEventsEnabled":"yes","emailApiKey":"pubkey-8qhg4gtdx3dv-j2kfl4j12m-axgqzft2","cloudFlareRay":"27fc9323b4c5200c-DFW","flashAudioPlayerSwfFilePath":"\/a\/i\/FlashAudioPlayer.H7pP.swf","uid":"-4674682768844257166","username":"wjridge","ab_enrolled_variations":"newUserDiscovery:on","ab_all_variations":"smsLink:on,cardsBadge:on,hotjar1:off,trophyShare_1:on,trophyLostEmail_1:on,newUserDiscovery:on,ltlUpsells0:off","live_rollbar_config":"state"};
	var _gaq=[["_setAccount","UA-1203987-1"],["_setDomainName","none"],["_setCustomVar",1,"Logged In","true",2],["_setCustomVar",3,"ABTests","newUserDiscovery:on"],["_setCustomVar",4,"LoginSource","password"]];
	var QWait,QLoad;
(function(){var e=window.onerror,d=[],g={},l=0,h=function(b,a,d){if(6>l++){var c;c="/activity-log/create?title=preload_js_error&data="+encodeURIComponent('"msg: '+b+"; "+a+"#"+d+'"');c+="&cstoken="+encodeURIComponent(Quizlet.getCsToken());(new Image).src=c}e&&e.apply(window,arguments)};window.onerror=h;QWait=function(){for(var b=arguments,a=b.length-1,f=b[a],c=[];a--;)g.hasOwnProperty(b[a])||c.push(b[a]);c.length?d.push({labels:c,func:f}):f()};QLoad=function(b){var a,f,c,e;a=0;for(f=d.length;a<f;a++)for(c=
e=d[a].labels.length;c--;)if(d[a].labels[c]===b){d[a].labels.splice(c,1);if(1===e){d.splice(a,1)[0].func();QLoad(b);return}break}g[b]=1};setTimeout(function(){var b=d.length,a="";for(label in g)a+=", "+label;for(;b--;)h(d[b].labels.toString()+" UNFIRED; "+a.substr(2)+" DONE","","","unfired_label")},2E4);var k=function(){QWait("quizlib",function(){QLoad("dom");QLoad("onload")})};window.onload=k;"readyState"in document&&(document.onreadystatechange=function(){"complete"===document.readyState&&k()})})();
	(function(c,d){d.getCsToken=function(){var a;a=c.cookie.match("(?:^|;)\\s*"+d.cstokenName.replace(/[\-\[\]{}()*+?.,\\^$|#\s]/g,"$&")+"=([^;]*)");a=null!==a?decodeURIComponent(a[1]):null;return a};d.appendCstokenToForm=function(a){var b=c.createElement("input");b.type="hidden";b.name="cstoken";b.value=d.getCsToken();a.appendChild(b)};var e=function(a){a=a.target||a.srcElement;var b=a.method.toLowerCase();"post"!==b&&"put"!==b&&"delete"!==b&&"patch"!==b||d.appendCstokenToForm(a)};"addEventListener"in
c?c.addEventListener("submit",e,!1):c.attachEvent&&c.attachEvent("onsubmit",e);d.willHaveJquery?QWait("jquery",function(){$.ajaxPrefilter(function(a){var b=a.type.toLowerCase();if("post"===b||"put"===b||"delete"===b||"patch"===b){var b=d.getCsToken(),c="cstoken="+encodeURIComponent(b);a.data&&"[object FormData]"===a.data.toString()?a.data.append("cstoken",b):a.data=a.data?a.data+("&"+c):c}})}):QWait("mootools",function(){var a=function(){var a=d.getCsToken();Request.prototype.options.headers={"X-Requested-With":"XMLHttpRequest",
Accept:"text/javascript, text/html, application/xml, text/xml, */*","Cs-Token":a};Request.prototype.options.data={cstoken:a}};a();setInterval(a,3E3)})})(document,Quizlet);

					QLoad('Quizlet.Common.intl');
	
			QWait('quizlib', function() {
			if (window.console && window.console.log) {
				console.log("\n .d88888b.           d8b          888          888\nd88P\" \"Y88b          Y8P          888          888\n888     888                       888          888\n888     888 888  888 888 88888888 888  .d88b.  888888\n888     888 888  888 888    d88P  888 d8P  Y8b 888\n888 Y8b 888 888  888 888   d88P   888 88888888 888\nY88b.Y8b88P Y88b 888 888  d88P    888 Y8b.     Y88b.\n \"Y888888\"   \"Y88888 888 88888888 888  \"Y8888   \"Y888\n       Y8b\n\nThe world of education is changing, and a generation of students is turning to digital learning tools.\nQuizlet is building those tools... come join us!\n\nCheck out out our jobs page at https:\/\/quizlet.com\/jobs!");
			}
		});
	
	var Window,Document,Element,Event;</script>

<script type="text/javascript" src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/quizlib_mootools.js" async="" defer="defer"></script><script type="text/javascript" src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/mootools.js" async="" defer="defer" onload="QLoad('Quizlet.Common.mootools');"></script><script type="text/javascript" src="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/test_mode.js" async="" defer="defer"></script>	
			<link rel="stylesheet" type="text/css" href="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/all-ttf.css">
			<link rel="stylesheet" type="text/css" href="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/test.css">
			<link rel="stylesheet" type="text/css" href="Test%20%20Ruby%202.0%20Core%20API%20MATCHING_files/style.css">
	
	<link rel="dns-prefetch" href="https://up.quizlet.com/">

	
	
	<link rel="shortcut icon" href="https://quizlet.com/a/i/favicon.Byhh.ico">

	
	<link rel="canonical" href="https://quizlet.com/23794409/ruby-20-core-api-flash-cards/"><meta name="referrer" content="origin-when-cross-origin">
	
	
	
	<script type="text/javascript">window.DFPADS = false;if ((window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || (document.body && document.body.clientWidth)) >= 568) {window.DFPADS={};googletag=window.googletag||{};googletag.cmd=googletag.cmd||[];googletag.cmd.push(function(){googletag.pubads().enableSingleRequest();googletag.enableServices();});}</script>



<div class="site"><h2 class="SpacedRepetitionHeader-headline"><center>This is a Free Service provided by Why Fund Inc. (a 501 C3 NonProfit) We thank you for your donation!<br><br><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="hosted_button_id" value="9836W6R4XQHWC">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The 

safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form><br></center></h2>
		<p class="SpacedRepetitionHeader-subheadline">(1. Click on the course Study Set you wish to learn.)  (2. If you wish you can click on "Print" and print the test page.)  (3. When you want to take a test...click on anyone of the tests for that Study Set.)  (4. Click on "Check Answers" and it will score your test and correct your answers.)  (5. You can take all the tests as many times as you choose until you get an "A"!)  (6. Automated college courses created from lecture notes, class exams, text books, reading materials from  many colleges and  universities.)</p>
	</div>


<main class="page" id="page" role="main" itemscope="" itemprop="mainContentOfPage">
	
<div class="TestPage">
	
		<div class="container">

	
	<img src="https://quizlet.com/a/i/global/logo_print.du83.png" class="PrintLogo" id="PrintLogo">

<script type="text/javascript">
	QWait('dom',function(){document.getElementById('PrintLogo').setAttribute('src',"https://quizlet.com/a/i/global/logo_print.du83.png")});
</script>

	<div id="nametag">
		<span class="nametag-text">NAME</span>
		<span class="nametag-line"></span>
	</div>

	<script type="text/javascript">
	var WORD_ACCENTS = [],
	    DEFINITION_ACCENTS = ["\u2014"],
	    WORD_LANG_CODE = "math",
	    DEF_LANG_CODE = "en";
	</script>

	<div class="small right" id="config">
	    <div id="grade" class="roundedoverflow " style="overflow: hidden; display: block; height: 0px;">
	        <div class="mrnd">
	            <div id="answer-area">
	            <h1 class="incorrect">F</h1><b class="block">0%</b></div>

	        </div>	    </div>

	    <form action="/23794409/test" id="reconfigure-form" method="get" class="dnone noprint">
	    <div class="mrnd">	    	<h3>Question types</h3>
	    	<ul>
	    		<li><input name="written" onclick="saveCookiePref.call(this)" id="written" type="checkbox"> <label for="written">Written</label></li>
	    		<li><input name="matching" onclick="saveCookiePref.call(this)" id="matching" checked="checked" type="checkbox"> <label for="matching">Matching</label></li>
	    		<li><input name="mult_choice" onclick="saveCookiePref.call(this)" id="mult_choice" type="checkbox"> <label for="mult_choice">Multiple choice</label></li>
	    		<li><input name="tf" onclick="saveCookiePref.call(this)" id="tf" type="checkbox"> <label for="tf">True/False</label></li>
	    	</ul>
	    	<br>
	    	<h3>Start with</h3>
	        <ul class="prompt-radio">
	    		<li>
	    			<input name="prompt-with" onclick="saveTestPromptCookie.call(this)" value="0" id="test-prompt-word" type="radio">
	    			<label for="test-prompt-word">Math / Symbols</label>
	    		</li>
	    		<li>
	    			<input name="prompt-with" onclick="saveTestPromptCookie.call(this)" value="1" id="test-prompt-def" checked="checked" type="radio">
	    			<label for="test-prompt-def">English</label>
	    		</li>
	    		<li>
	    			<input name="prompt-with" onclick="saveTestPromptCookie.call(this)" value="2" id="test-prompt-both" type="radio">
	    			<label for="test-prompt-both">Both</label>
	    		</li>
	    	</ul>
	        <br>
	    	<h3>Question limit</h3>
	    	<p>
	    		<input size="3" name="limit" id="limit" class="value" value="1298" type="text"> of 1298 available terms	    			    			<br><small>(7 exact duplicates found)</small>
	    			    	</p>

	    	<p><button type="submit" class="large button reconfig-btn">Create new test</button></p>

	    </div>	    </form>


	    
	</div>


	
	<div id="testwrapper" class="large right"><div class="mrnd">					<a href="#" onclick="window.print();return false" class="TestPage-printButton button gray">Print test</a>									<h3>629 Matching questions</h3><ol id="matching1"><li id="iesucks-ed" class="wrong-q"><b> <span class="TermText qWord lang-math">STRUCT<br>
struct[symbol]<br>
struct[fixnum]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ed</span> <span class="TermText qDef lang-en">Attribute Reference—Returns the value of the instance variable named by<br>
symbol, or indexed (0..length-1) by fixnum. Will raise<br>
NameError if the named variable does not exist, or<br>
IndexError if the index is out of range.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
<br>
joe["name"] #=&gt; "Joe Smith"<br>
joe[:name] #=&gt; "Joe Smith"<br>
joe[0] #=&gt; "Joe Smith"</span></p></li><li id="iesucks-bu" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
readlines(name, sep=$/ [, open_args])<br>
readlines(name, limit [, open_args])<br>
readlines(name, sep, limit [, open_args])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bu</span> <span class="TermText qDef lang-en">Reads the entire file specified by name as individual lines, and<br>
returns those lines in an array. Lines are separated by sep.<br>
<br>
a = IO.readlines("testfile")<br>
a[0] #=&gt; "This is line one\n"</span></p></li><li id="iesucks-ey" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
max_by { |obj| block }<br>
max_by</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ey</span> <span class="TermText qDef lang-en">Returns the object in enum that gives the maximum value from the<br>
given block.<br>
<br>
a = %w(albatross dog horse)<br>
a.max_by { |x| x.length } #=&gt; "albatross"</span></p></li><li id="iesucks-rv" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
compact</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rv</span> <span class="TermText qDef lang-en">Returns a copy of self with all nil elements<br>
removed.<br>
<br>
[ "a", nil, "b", nil, "c", nil ].compact<br>
 #=&gt; [ "a", "b", "c" ]</span></p></li><li id="iesucks-nu" class="wrong-q"><b> <span class="TermText qWord lang-math">FALSECLASS<br>
false &amp; obj<br>
nil &amp; obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nu</span> <span class="TermText qDef lang-en">And—Returns false. obj is always evaluated as it is<br>
the argument to a method call—there is no short-circuit evaluation in this<br>
case.</span></p></li><li id="iesucks-mn" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
keep_if { |item| block }<br>
keep_if</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mn</span> <span class="TermText qDef lang-en">Deletes every element of self for which the given block<br>
evaluates to false.<br>
<br>
a = %w{ a b c d e f }<br>
a.keep_if { |v| v =~ /[aeiou]/ } #=&gt; ["a", "e"]</span></p></li><li id="iesucks-ov" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
file?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ov</span> <span class="TermText qDef lang-en">Returns true if stat is a regular file (not a device<br>
file, pipe, socket, etc.).<br>
<br>
File.stat("testfile").file? #=&gt; true</span></p></li><li id="iesucks-oh" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
nlink</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oh</span> <span class="TermText qDef lang-en">Returns the number of hard links to stat.<br>
<br>
File.stat("testfile").nlink #=&gt; 1<br>
File.link("testfile", "testfile.bak") #=&gt; 0<br>
File.stat("testfile").nlink #=&gt; 2</span></p></li><li id="iesucks-dh" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
strftime( string )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dh</span> <span class="TermText qDef lang-en">Formats time according to the directives in the given format<br>
string.<br>
<br>
%&lt;flags&gt;&lt;width&gt;&lt;modifier&gt;&lt;conversion&gt;</span></p></li><li id="iesucks-wc" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
slice(index)<br>
slice(start, length)<br>
slice(range)<br>
slice(regexp)<br>
slice(regexp, capture)<br>
slice(match_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wc</span> <span class="TermText qDef lang-en">Element Reference — If passed a single index, returns a<br>
substring of one character at that index. If passed a start<br>
index and a length, returns a substring containing<br>
length characters starting at the index. If<br>
passed a range, its beginning and end are interpreted as<br>
offsets delimiting the substring to be returned.<br>
<br>
a = "hello there"<br>
<br>
a[1] #=&gt; "e"<br>
a[2, 3] #=&gt; "llo"<br>
a[2..3] #=&gt; "ll"<br>
<br>
a[-3, 2] #=&gt; "er"<br>
a[7..-2] #=&gt; "her"<br>
a[-4..-2] #=&gt; "her"<br>
a[-2..-4] #=&gt; ""<br>
<br>
a[11, 0] #=&gt; ""<br>
a[11] #=&gt; nil<br>
a[12, 0] #=&gt; nil<br>
a[12..-1] #=&gt; nil<br>
<br>
a[/[aeiou](.)\1/] #=&gt; "ell"<br>
a[/[aeiou](.)\1/, 0] #=&gt; "ell"<br>
a[/[aeiou](.)\1/, 1] #=&gt; "l"<br>
a[/[aeiou](.)\1/, 2] #=&gt; nil<br>
<br>
a[/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/, "non_vowel"] #=&gt; "l"<br>
a[/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/, "vowel"] #=&gt; "e"<br>
<br>
a["lo"] #=&gt; "lo"<br>
a["bye"] #=&gt; nil</span></p></li><li id="iesucks-wx" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
require(name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wx</span> <span class="TermText qDef lang-en">Loads the given name, returning true if<br>
successful and false if the feature is already loaded.<br>
<br>
require "my-library.rb"<br>
require "db-driver"</span></p></li><li id="iesucks-nd" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
to_a</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nd</span> <span class="TermText qDef lang-en">Converts the environment variables into an array of names and value arrays.<br>
<br>
ENV.to_a # =&gt; [["TERM", "xterm-color"], ["SHELL", "/bin/bash"], ...]</span></p></li><li id="iesucks-ci" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
dev_major</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ci</span> <span class="TermText qDef lang-en">Returns the major part of File_Stat#dev or nil.<br>
<br>
File.stat("/dev/fd1").dev_major #=&gt; 2<br>
File.stat("/dev/tty").dev_major #=&gt; 5</span></p></li><li id="iesucks-ld" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
each_codepoint {|c| block }<br>
codepoints {|c| block }<br>
each_codepoint<br>
codepoints</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ld</span> <span class="TermText qDef lang-en">Passes the Integer ordinal of each character in ios,<br>
passing the codepoint as an argument. The stream must be opened for reading<br>
or an IOError will be raised.</span></p></li><li id="iesucks-qm" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
sub(pattern, replacement)<br>
sub(pattern) {|...| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qm</span> <span class="TermText qDef lang-en">Equivalent to $_.sub(args), except that<br>
$_ will be updated if substitution occurs. Available only when<br>
-p/-n command line option specified.</span></p></li><li id="iesucks-fs" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
class_eval(string [, filename [, lineno]])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fs</span> <span class="TermText qDef lang-en">Evaluates the string or block in the context of mod, except that<br>
when a block is given, constant/class variable lookup is not affected. This<br>
can be used to add methods to a class. module_eval returns the<br>
result of evaluating its argument. The optional filename and<br>
lineno parameters set the text for error messages.<br>
<br>
class Thing<br>
end<br>
a = %q{def hello() "Hello there!" end}<br>
Thing.module_eval(a)<br>
puts Thing.new.hello()<br>
Thing.module_eval("invalid code", "dummy", 123)</span></p></li><li id="iesucks-jf" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
remove_class_variable(sym)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jf</span> <span class="TermText qDef lang-en">Removes the definition of the sym, returning that constant's<br>
value.<br>
<br>
class Dummy<br>
 @@var = 99<br>
 puts @@var<br>
 remove_class_variable(:@@var)<br>
 p(defined? @@var)<br>
end</span></p></li><li id="iesucks-wh" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fdiv(numeric)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wh</span> <span class="TermText qDef lang-en">Returns the floating point result of dividing fix by<br>
numeric.<br>
<br>
654321.fdiv(13731) #=&gt; 47.6528293642124<br>
654321.fdiv(13731.24) #=&gt; 47.6519964693647</span></p></li><li id="iesucks-vy" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
global_variables</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vy</span> <span class="TermText qDef lang-en">Returns an array of the names of global variables.<br>
<br>
global_variables.grep /std/ #=&gt; [:$stdin, :$stdout, :$stderr]</span></p></li><li id="iesucks-oq" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
reject {| key, value | block }<br>
reject</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oq</span> <span class="TermText qDef lang-en">Same as Hash#delete_if, but works on (and returns) a copy of<br>
the hsh. Equivalent to hsh.dup.delete_if.</span></p></li><li id="iesucks-td" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
realdirpath(pathname [, dir_string])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">td</span> <span class="TermText qDef lang-en">Returns the real (absolute) pathname of pathname in the actual<br>
filesystem. The real pathname doesn't contain symlinks or useless dots.</span></p></li><li id="iesucks-oe" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
loop { block }<br>
loop</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oe</span> <span class="TermText qDef lang-en">Repeatedly executes the block.<br>
<br>
loop do<br>
 print "Input: "<br>
 line = gets<br>
 break if !line or line =~ /^qQ/<br>
 # ...<br>
end</span></p></li><li id="iesucks-ui" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
truncate(integer)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ui</span> <span class="TermText qDef lang-en">Truncates file to at most integer bytes. The file must be<br>
opened for writing. Not available on all platforms.<br>
<br>
f = File.new("out", "w")<br>
f.syswrite("1234567890") #=&gt; 10<br>
f.truncate(5) #=&gt; 0<br>
f.close() #=&gt; nil<br>
File.size("out") #=&gt; 5</span></p></li><li id="iesucks-gc" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
dirname(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gc</span> <span class="TermText qDef lang-en">Returns all components of the filename given in file_name except<br>
the last one. The filename can be formed using both<br>
File::SEPARATOR and File::ALT_SEPARETOR as the<br>
separator when File::ALT_SEPARATOR is not nil.<br>
<br>
File.dirname("/home/gumby/work/ruby.rb") #=&gt; "/home/gumby/work"</span></p></li><li id="iesucks-te" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
to_s(base=10)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">te</span> <span class="TermText qDef lang-en">Returns a string containing the representation of fix radix<br>
base (between 2 and 36).<br>
<br>
12345.to_s #=&gt; "12345"<br>
12345.to_s(2) #=&gt; "11000000111001"<br>
12345.to_s(8) #=&gt; "30071"<br>
12345.to_s(10) #=&gt; "12345"<br>
12345.to_s(16) #=&gt; "3039"<br>
12345.to_s(36) #=&gt; "9ix"</span></p></li><li id="iesucks-kq" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
grpowned?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kq</span> <span class="TermText qDef lang-en">Returns true if the effective group id of the process is the same as the<br>
group id of stat. On Windows NT, returns false.<br>
<br>
File.stat("testfile").grpowned? #=&gt; true<br>
File.stat("/etc/passwd").grpowned? #=&gt; false</span></p></li><li id="iesucks-sz" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
chars</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sz</span> <span class="TermText qDef lang-en">Returns an array of characters in str. This is a shorthand for<br>
str.each_char.to_a.</span></p></li><li id="iesucks-ta" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
find(ifnone = nil) { |obj| block }<br>
find(ifnone = nil)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ta</span> <span class="TermText qDef lang-en">Passes each entry in enum to block. Returns the first for<br>
which block is not false. If no object matches, calls<br>
ifnone and returns its result when it is specified, or returns<br>
nil otherwise.<br>
<br>
(1..10).detect { |i| i % 5 == 0 and i % 7 == 0 } #=&gt; nil<br>
(1..100).detect { |i| i % 5 == 0 and i % 7 == 0 } #=&gt; 35</span></p></li><li id="iesucks-y" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
upcase!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">y</span> <span class="TermText qDef lang-en">Upcases the contents of str, returning nil if no<br>
changes were made. Note: case replacement is effective only in ASCII<br>
region.</span></p></li><li id="iesucks-jb" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
source</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jb</span> <span class="TermText qDef lang-en">Returns the original string of the pattern.<br>
<br>
/ab+c/x.source #=&gt; "ab+c"</span></p></li><li id="iesucks-du" class="wrong-q"><b> <span class="TermText qWord lang-math">ENCODING<br>
default_internal = enc or nil</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">du</span> <span class="TermText qDef lang-en">Sets default internal encoding or removes default internal encoding when<br>
passed nil. You should not set ::default_internal in<br>
ruby code as strings created before changing the value may have a different<br>
encoding from strings created after the change. Instead you should use<br>
ruby -E to invoke ruby with the correct default_internal.</span></p></li><li id="iesucks-lf" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
each_entry { |obj| block }<br>
each_entry</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lf</span> <span class="TermText qDef lang-en">Calls block once for each element in self, passing<br>
that element as a parameter, converting multiple values from yield to an<br>
array.<br>
<br>
class Foo<br>
 include Enumerable<br>
 def each<br>
 yield 1<br>
 yield 1, 2<br>
 yield<br>
 end<br>
end<br>
Foo.new.each_entry{ |o| p o }</span></p></li><li id="iesucks-tz" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
trap( signal, command )<br>
trap( signal ) {| | block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tz</span> <span class="TermText qDef lang-en">Specifies the handling of signals. The first parameter is a signal name (a<br>
string such as "SIGALRM", "SIGUSR1", and so on) or a signal number. The<br>
characters "SIG" may be omitted from the signal name. The command or block<br>
specifies code to be run when the signal is raised. If the command is the<br>
string "IGNORE" or "SIG_IGN", the signal will be ignored. If the command is<br>
"DEFAULT" or "SIG_DFL", the Ruby's default handler will be invoked. If the<br>
command is "EXIT", the script will be terminated by the signal. If the<br>
command is "SYSTEM_DEFAULT", the operating system's default handler will be<br>
invoked. Otherwise, the given command or block will be run. The special<br>
signal name "EXIT" or signal number zero will be invoked just prior to<br>
program termination. trap returns the previous handler for the given<br>
signal.<br>
<br>
Signal.trap(0, proc { puts "Terminating: #{$$}" })<br>
Signal.trap("CLD") { puts "Child died" }<br>
fork ^!^ Process.wait</span></p></li><li id="iesucks-ex" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
select! { |name, value| }<br>
select!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ex</span> <span class="TermText qDef lang-en">Equivalent to ENV#keep_if but returns nil if no changes were<br>
made.</span></p></li><li id="iesucks-sy" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
drop_while { |arr| block }<br>
drop_while</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sy</span> <span class="TermText qDef lang-en">Drops elements up to, but not including, the first element for which the<br>
block returns nil or false and returns an array<br>
containing the remaining elements.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.drop_while {|i| i &lt; 3 } #=&gt; [3, 4, 5, 0]</span></p></li><li id="iesucks-uo" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
tv_sec</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uo</span> <span class="TermText qDef lang-en">Returns the value of time as an integer number of seconds since<br>
the Epoch.<br>
<br>
t = Time.now<br>
"%10.5f" % t.to_f #=&gt; "1270968656.89607"<br>
t.to_i #=&gt; 1270968656</span></p></li><li id="iesucks-i" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
odd?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">i</span> <span class="TermText qDef lang-en">Returns true if fix is an odd number.</span></p></li><li id="iesucks-im" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fix &gt;= real</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">im</span> <span class="TermText qDef lang-en">Returns true if the value of fix is greater than<br>
or equal to that of real.</span></p></li><li id="iesucks-dd" class="wrong-q"><b> <span class="TermText qWord lang-math">METHOD<br>
source_location</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dd</span> <span class="TermText qDef lang-en">Returns the Ruby source filename and line number containing this method or<br>
nil if this method was not defined in Ruby (i.e. native)</span></p></li><li id="iesucks-nh" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
respond_to?(symbol, include_all=false)<br>
respond_to?(string, include_all=false)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nh</span> <span class="TermText qDef lang-en">Returns true if obj responds to the given method. <br>
Private and protected methods are included in the search only if the<br>
optional second parameter evaluates to true.</span></p></li><li id="iesucks-dp" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
chomp!(separator=$/)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dp</span> <span class="TermText qDef lang-en">Modifies str in place as described for String#chomp,<br>
returning str, or nil if no modifications were made.</span></p></li><li id="iesucks-nb" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
zero?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nb</span> <span class="TermText qDef lang-en">Returns true if the named file exists and has a zero size.</span></p></li><li id="iesucks-ds" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
join(string, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ds</span> <span class="TermText qDef lang-en">Returns a new string formed by joining the strings using<br>
File::SEPARATOR.<br>
<br>
File.join("usr", "mail", "gumby") #=&gt; "usr/mail/gumby"</span></p></li><li id="iesucks-nx" class="wrong-q"><b> <span class="TermText qWord lang-math">MATCHDATA<br>
post_match</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nx</span> <span class="TermText qDef lang-en">Returns the portion of the original string after the current match.<br>
Equivalent to the special variable $'.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")<br>
m.post_match #=&gt; ": The Movie"</span></p></li><li id="iesucks-hj" class="wrong-q"><b> <span class="TermText qWord lang-math">ENCODING<br>
name_list</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hj</span> <span class="TermText qDef lang-en">Returns the list of available encoding names.<br>
<br>
Encoding.name_list<br>
#=&gt; ["US-ASCII", "ASCII-8BIT", "UTF-8",<br>
 "ISO-8859-1", "Shift_JIS", "EUC-JP",<br>
 "Windows-31J",<br>
 "BINARY", "CP932", "eucJP"]</span></p></li><li id="iesucks-gk" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
foreach( dirname ) {| filename | block }<br>
foreach( dirname )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gk</span> <span class="TermText qDef lang-en">Calls the block once for each entry in the named directory, passing the<br>
filename of each entry as a parameter to the block.<br>
<br>
Dir.foreach("testdir") {|x| puts "Got #{x}" }</span></p></li><li id="iesucks-hi" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hi</span> <span class="TermText qDef lang-en">Produce a nicely formatted description of stat.<br>
<br>
File.stat("/etc/passwd").inspect<br>
 #=&gt; "#&lt;File::Stat dev=0xe000005, ino=1078078, mode=0100644,<br>
 # nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,<br>
 # blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,<br>
 # mtime=Fri Sep 12 15:41:41 CDT 2003,<br>
 # ctime=Mon Oct 27 11:20:27 CST 2003&gt;"</span></p></li><li id="iesucks-o" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
gcd(int2)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">o</span> <span class="TermText qDef lang-en">Returns the greatest common divisor (always positive). 0.gcd(x) and<br>
x.gcd(0) return abs(x).<br>
<br>
2.gcd(2) #=&gt; 2<br>
3.gcd(-7) #=&gt; 1<br>
((1&lt;&lt;31)-1).gcd((1&lt;&lt;61)-1) #=&gt; 1</span></p></li><li id="iesucks-uf" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
bytesize</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uf</span> <span class="TermText qDef lang-en">Returns the length of str in bytes.<br>
<br>
"\x80\u3042".bytesize #=&gt; 4<br>
"hello".bytesize #=&gt; 5</span></p></li><li id="iesucks-lh" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
executable?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lh</span> <span class="TermText qDef lang-en">Returns true if the named file is executable by the effective<br>
user id of this process.</span></p></li><li id="iesucks-we" class="wrong-q"><b> <span class="TermText qWord lang-math">FILETEST<br>
readable?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">we</span> <span class="TermText qDef lang-en">Returns true if the named file is readable by the effective<br>
user id of this process.</span></p></li><li id="iesucks-uu" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
initialize_copy(other_ary)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uu</span> <span class="TermText qDef lang-en">Replaces the contents of self with the contents of<br>
other_ary, truncating or expanding if necessary.<br>
<br>
a = [ "a", "b", "c", "d", "e" ]<br>
a.replace([ "x", "y", "z" ]) #=&gt; ["x", "y", "z"]<br>
a #=&gt; ["x", "y", "z"]</span></p></li><li id="iesucks-ls" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
float - other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ls</span> <span class="TermText qDef lang-en">Returns a new float which is the difference of float and<br>
other.</span></p></li><li id="iesucks-hg" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERATOR<br>
next_values</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hg</span> <span class="TermText qDef lang-en">Returns the next object as an array in the enumerator, and move the<br>
internal position forward. When the position reached at the end, StopIteration is raised.<br>
<br>
o = Object.new<br>
def o.each<br>
 yield<br>
 yield 1<br>
 yield 1, 2<br>
 yield nil<br>
 yield [1, 2]<br>
end<br>
e = o.to_enum<br>
p e.next_values<br>
p e.next_values<br>
p e.next_values<br>
p e.next_values<br>
p e.next_values<br>
e = o.to_enum<br>
p e.next<br>
p e.next<br>
p e.next<br>
p e.next<br>
p e.next<br>
<br>
## yield args next_values next<br>
# yield [] nil<br>
# yield 1 [1] 1<br>
# yield 1, 2 [1, 2] [1, 2]<br>
# yield nil [nil] nil<br>
# yield [1, 2] [[1, 2]] [1, 2]</span></p></li><li id="iesucks-lb" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
last<br>
last(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lb</span> <span class="TermText qDef lang-en">Returns the last object in the range, or an array of the last<br>
n elements.<br>
<br>
(10..20).last #=&gt; 20<br>
(10...20).last #=&gt; 20<br>
(10..20).last(3) #=&gt; [18, 19, 20]<br>
(10...20).last(3) #=&gt; [17, 18, 19]</span></p></li><li id="iesucks-qh" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
nan?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qh</span> <span class="TermText qDef lang-en">Returns true if flt is an invalid IEEE floating point<br>
number.<br>
<br>
a = -1.0 #=&gt; -1.0<br>
a.nan? #=&gt; false<br>
a = 0.0/0.0 #=&gt; NaN<br>
a.nan? #=&gt; true</span></p></li><li id="iesucks-ux" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
new(string, [options [, kcode]])<br>
new(regexp)<br>
compile(string, [options [, kcode]])<br>
compile(regexp)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ux</span> <span class="TermText qDef lang-en">Constructs a new regular expression from pattern, which can be<br>
either a String or a Regexp (in which case that regexp's options are<br>
propagated), and new options may not be specified (a change as of Ruby<br>
1.8).<br>
<br>
r1 = Regexp.new('^a-z+:\s+\w+') #=&gt; /^a-z+:\s+\w+/<br>
r2 = Regexp.new('cat', true) #=&gt; /cat/i<br>
r3 = Regexp.new(r2) #=&gt; /cat/i<br>
r4 = Regexp.new('dog', Regexp::EXTENDED | Regexp::IGNORECASE) #=&gt; /dog/ix</span></p></li><li id="iesucks-nr" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
utc(year)<br>
utc(year, month)<br>
utc(year, month, day)<br>
utc(year, month, day, hour)<br>
utc(year, month, day, hour, min)<br>
utc(year, month, day, hour, min, sec_with_frac)<br>
utc(year, month, day, hour, min, sec, usec_with_frac)<br>
utc(sec, min, hour, day, month, year, wday, yday, isdst, tz)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nr</span> <span class="TermText qDef lang-en">Creates a Time object based on given values,<br>
interpreted as UTC (GMT). The year must be specified. Other values default<br>
to the minimum value for that field (and may be nil or<br>
omitted). Months may be specified by numbers from 1 to 12, or by the<br>
three-letter English month names. Hours are specified on a 24-hour clock<br>
(0..23). Raises an ArgumentError if any<br>
values are out of range. Will also accept ten arguments in the order output<br>
by #to_a.<br>
<br>
Time.utc(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
Time.gm(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC</span></p></li><li id="iesucks-vq" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
at(index)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vq</span> <span class="TermText qDef lang-en">Returns the element at index. A negative index counts from the<br>
end of self. Returns nil if the index is out of<br>
range. See also Array#[].<br>
<br>
a = [ "a", "b", "c", "d", "e" ]<br>
a.at(0) #=&gt; "a"<br>
a.at(-1) #=&gt; "e"</span></p></li><li id="iesucks-nf" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
str % arg</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nf</span> <span class="TermText qDef lang-en">Format—Uses str as a format specification, and returns the result<br>
of applying it to arg. If the format specification contains more<br>
than one substitution, then arg must be an Array or<br>
Hash containing the values to be substituted. See<br>
Kernel::sprintf for details of the format string.<br>
<br>
"%05d" % 123 #=&gt; "00123"<br>
"%-5s: %08x" % [ "ID", self.object_id ] #=&gt; "ID : 200e14d6"<br>
"foo = %{foo}" % { :foo =&gt; 'bar' } #=&gt; "foo = bar"</span></p></li><li id="iesucks-kk" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
all? [{ |obj| block } ]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kk</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block never returns false or<br>
nil. If the block is not given, Ruby adds an implicit block of<br>
{ |obj| obj } which will cause all? to return true<br>
when none of the collection members are false or<br>
nil.<br>
<br>
%w[ant bear cat].all? { |word| word.length &gt;= 3 } #=&gt; true<br>
%w[ant bear cat].all? { |word| word.length &gt;= 4 } #=&gt; false<br>
[nil, true, 99].all? #=&gt; false</span></p></li><li id="iesucks-ja" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
freeze</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ja</span> <span class="TermText qDef lang-en">Prevents further modifications to obj. A RuntimeError<br>
will be raised if modification is attempted. There is no way to unfreeze a<br>
frozen object. See also Object#frozen?.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.freeze<br>
a &lt;&lt; "z"</span></p></li><li id="iesucks-ii" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
last<br>
last(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ii</span> <span class="TermText qDef lang-en">Returns the last element(s) of self. If the array is empty,<br>
the first form returns nil.<br>
<br>
a = [ "w", "x", "y", "z" ]<br>
a.last #=&gt; "z"<br>
a.last(2) #=&gt; ["y", "z"]</span></p></li><li id="iesucks-vw" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
default_proc</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vw</span> <span class="TermText qDef lang-en">If Hash::new was invoked with a block, return that block,<br>
otherwise return nil.<br>
<br>
h = Hash.new {|h,k| h[k] = k*k } #=&gt; {}<br>
p = h.default_proc #=&gt; #&lt;Proc:0x401b3d08@-:1&gt;<br>
a = [] #=&gt; []<br>
p.call(a, 2)<br>
a #=&gt; [nil, nil, 4]</span></p></li><li id="iesucks-an" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
now</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">an</span> <span class="TermText qDef lang-en">Alias for ::new. Returns a Time object initialized to the current system time.</span></p></li><li id="iesucks-as" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
pos = integer</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">as</span> <span class="TermText qDef lang-en">Seeks to the given position (in bytes) in ios. It is not guranteed<br>
that seeking to the right position when ios is textmode.<br>
<br>
f = File.new("testfile")<br>
f.pos = 17<br>
f.gets #=&gt; "This is line two\n"</span></p></li><li id="iesucks-gz" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
lineno = integer</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gz</span> <span class="TermText qDef lang-en">Sets the line number of ARGF as a whole to the given<br>
Integer.<br>
<br>
ARGF.lineno #=&gt; 0<br>
ARGF.readline #=&gt; "This is line 1\n"<br>
ARGF.lineno #=&gt; 1<br>
ARGF.lineno = 0 #=&gt; 0<br>
ARGF.lineno #=&gt; 0</span></p></li><li id="iesucks-gq" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
encoding</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gq</span> <span class="TermText qDef lang-en">Returns the Encoding object that represents the<br>
encoding of sym.</span></p></li><li id="iesucks-di" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
truncate</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">di</span> <span class="TermText qDef lang-en">As int is already an Integer, all these methods<br>
simply return the receiver.</span></p></li><li id="iesucks-os" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
Hash(arg)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">os</span> <span class="TermText qDef lang-en">Converts arg to a Hash by calling<br>
arg.to_hash. Returns an empty Hash when<br>
arg is nil or [].<br>
<br>
Hash([]) #=&gt; {}<br>
Hash(nil) #=&gt; nil<br>
Hash(key: :value) #=&gt; {:key =&gt; :value}<br>
Hash([1, 2, 3]) #=&gt; TypeError</span></p></li><li id="iesucks-uv" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
trust</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uv</span> <span class="TermText qDef lang-en">Removes the untrusted mark from the object.</span></p></li><li id="iesucks-jd" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
protected_instance_methods(include_super=true)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jd</span> <span class="TermText qDef lang-en">Returns a list of the protected instance methods defined in mod.<br>
If the optional parameter is not false, the methods of any<br>
ancestors are included.</span></p></li><li id="iesucks-iu" class="wrong-q"><b> <span class="TermText qWord lang-math">METHOD<br>
eql?(other_meth)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">iu</span> <span class="TermText qDef lang-en">Two method objects are equal if they are bound to the same object and refer<br>
to the same method definition and their owners are the same class or<br>
module.</span></p></li><li id="iesucks-em" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
to_proc</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">em</span> <span class="TermText qDef lang-en">Returns a Proc object which respond to the given method by<br>
sym.<br>
<br>
(1..3).collect(&amp;:to_s) #=&gt; ["1", "2", "3"]</span></p></li><li id="iesucks-hz" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
seek(amount, whence=IO::SEEK_SET)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hz</span> <span class="TermText qDef lang-en">Seeks to a given offset anInteger in the stream according to the<br>
value of whence:<br>
<br>
:CUR or IO::SEEK_CUR | Seeks to _amount_ plus current position<br>
----------------------+--------------------------------------------------<br>
:END or IO::SEEK_END | Seeks to _amount_ plus end of stream (you<br>
 | probably want a negative value for _amount_)<br>
----------------------+--------------------------------------------------<br>
:SET or IO::SEEK_SET | Seeks to the absolute location given by _amount_</span></p></li><li id="iesucks-qg" class="wrong-q"><b> <span class="TermText qWord lang-math">ENCODING<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qg</span> <span class="TermText qDef lang-en">Returns a string which represents the encoding for programmers.<br>
<br>
Encoding::UTF_8.inspect #=&gt; "#&lt;Encoding:UTF-8&gt;"<br>
Encoding::ISO_2022_JP.inspect #=&gt; "#&lt;Encoding:ISO-2022-JP (dummy)&gt;"</span></p></li><li id="iesucks-ub" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
cycle(n=nil) { |obj| block }<br>
cycle(n=nil)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ub</span> <span class="TermText qDef lang-en">Calls the given block for each element n times or forever if<br>
nil is given.<br>
<br>
a = ["a", "b", "c"]<br>
a.cycle { |x| puts x } # print, a, b, c, a, b, c,.. forever.<br>
a.cycle(2) { |x| puts x } # print, a, b, c, a, b, c.</span></p></li><li id="iesucks-or" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
each_with_index(*args) { |obj, i| block }<br>
each_with_index(*args)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">or</span> <span class="TermText qDef lang-en">Calls block with two arguments, the item and its index, for each<br>
item in enum. Given arguments are passed through to each().<br>
<br>
hash = Hash.new<br>
%w(cat dog wombat).each_with_index { |item, index|<br>
 hash[item] = index<br>
}<br>
hash #=&gt; {"cat"=&gt;0, "dog"=&gt;1, "wombat"=&gt;2}</span></p></li><li id="iesucks-vb" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
replace(other_hash)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vb</span> <span class="TermText qDef lang-en">Replaces the contents of hsh with the contents of<br>
other_hash.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.replace({ "c" =&gt; 300, "d" =&gt; 400 }) #=&gt; {"c"=&gt;300, "d"=&gt;400}</span></p></li><li id="iesucks-oy" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERATOR<br>
next</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oy</span> <span class="TermText qDef lang-en">Returns the next object in the enumerator, and move the internal position<br>
forward. When the position reached at the end, StopIteration is raised.<br>
<br>
a = [1,2,3]<br>
e = a.to_enum<br>
p e.next #=&gt; 1<br>
p e.next #=&gt; 2<br>
p e.next #=&gt; 3<br>
p e.next #raises StopIteration</span></p></li><li id="iesucks-ad" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
to_hash<br>
to_h</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ad</span> <span class="TermText qDef lang-en">Creates a hash with a copy of the environment variables.</span></p></li><li id="iesucks-vs" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
cover?(obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vs</span> <span class="TermText qDef lang-en">Returns true if obj is between the begin and end<br>
of the range.<br>
<br>
("a".."z").cover?("c") #=&gt; true<br>
("a".."z").cover?("5") #=&gt; false<br>
("a".."z").cover?("cc") #=&gt; true</span></p></li><li id="iesucks-ei" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
numerator</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ei</span> <span class="TermText qDef lang-en">Returns the numerator. The result is machine dependent.<br>
<br>
n = 0.3.numerator #=&gt; 5404319552844595<br>
d = 0.3.denominator #=&gt; 18014398509481984<br>
n.fdiv(d) #=&gt; 0.3</span></p></li><li id="iesucks-fa" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
puts(obj, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fa</span> <span class="TermText qDef lang-en">Equivalent to<br>
<br>
$stdout.puts(obj, ...)</span></p></li><li id="iesucks-lx" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
merge!(other_hash)<br>
merge!(other_hash){|key, oldval, newval| block}</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lx</span> <span class="TermText qDef lang-en">Adds the contents of other_hash to hsh. If no block is<br>
specified, entries with duplicate keys are overwritten with the values from<br>
other_hash, otherwise the value of each duplicate key is<br>
determined by calling the block with the key, its value in hsh and<br>
its value in other_hash.<br>
<br>
h1 = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h2 = { "b" =&gt; 254, "c" =&gt; 300 }<br>
h1.merge!(h2) #=&gt; {"a"=&gt;100, "b"=&gt;254, "c"=&gt;300}<br>
<br>
h1 = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h2 = { "b" =&gt; 254, "c" =&gt; 300 }<br>
h1.merge!(h2) { |key, v1, v2| v1 }<br>
 #=&gt; {"a"=&gt;100, "b"=&gt;200, "c"=&gt;300}</span></p></li><li id="iesucks-ht" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
size(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ht</span> <span class="TermText qDef lang-en">Returns the size of file_name.</span></p></li><li id="iesucks-vd" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
syscall(num [, args...])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vd</span> <span class="TermText qDef lang-en">syscall is essentially unsafe and unportable. Feel free to<br>
shoot your foot. DL (Fiddle) library is preferred for safer and a bit more<br>
portable programming.<br>
<br>
Calls the operating system function identified by _num_ and<br>
returns the result of the function or raises SystemCallError if<br>
it failed.<br>
<br>
Arguments for the function can follow _num_. They must be either<br>
+String+ objects or +Integer+ objects. A +String+ object is passed<br>
as a pointer to the byte sequence. An +Integer+ object is passed<br>
as an integer whose bit size is same as a pointer.<br>
Up to nine parameters may be passed (14 on the Atari-ST).<br>
<br>
The function identified by _num_ is system<br>
dependent. On some Unix systems, the numbers may be obtained from a<br>
header file called &lt;code&gt;syscall.h&lt;/code&gt;.<br>
<br>
 syscall 4, 1, "hello\n", 6 # '4' is write(2) on our box<br>
<br>
&lt;em&gt;produces:&lt;/em&gt;<br>
<br>
 hello<br>
<br>
Calling +syscall+ on a platform which does not have any way to<br>
an arbitrary system function just fails with NotImplementedError.</span></p></li><li id="iesucks-mp" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
round([ndigits])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mp</span> <span class="TermText qDef lang-en">Rounds flt to a given precision in decimal digits (default 0<br>
digits). Precision may be negative. Returns a floating point number when<br>
ndigits is more than zero.<br>
<br>
1.4.round #=&gt; 1<br>
1.5.round #=&gt; 2<br>
1.6.round #=&gt; 2<br>
(-1.5).round #=&gt; -2<br>
<br>
1.234567.round(2) #=&gt; 1.23<br>
1.234567.round(3) #=&gt; 1.235<br>
1.234567.round(4) #=&gt; 1.2346<br>
1.234567.round(5) #=&gt; 1.23457<br>
<br>
34567.89.round(-5) #=&gt; 0<br>
34567.89.round(-4) #=&gt; 30000<br>
34567.89.round(-3) #=&gt; 35000<br>
34567.89.round(-2) #=&gt; 34600<br>
34567.89.round(-1) #=&gt; 34570<br>
34567.89.round(0) #=&gt; 34568<br>
34567.89.round(1) #=&gt; 34567.9<br>
34567.89.round(2) #=&gt; 34567.89<br>
34567.89.round(3) #=&gt; 34567.89</span></p></li><li id="iesucks-lt" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
tell</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lt</span> <span class="TermText qDef lang-en">Returns the current offset (in bytes) of ios.<br>
<br>
f = File.new("testfile")<br>
f.pos #=&gt; 0<br>
f.gets #=&gt; "This is line one\n"<br>
f.pos #=&gt; 17</span></p></li><li id="iesucks-qu" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
flatten!<br>
flatten!(level)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qu</span> <span class="TermText qDef lang-en">Flattens self in place.<br>
<br>
a = [ 1, 2, [3, [4, 5] ] ]<br>
a.flatten! #=&gt; [1, 2, 3, 4, 5]<br>
a.flatten! #=&gt; nil<br>
a #=&gt; [1, 2, 3, 4, 5]<br>
a = [ 1, 2, [3, [4, 5] ] ]<br>
a.flatten!(1) #=&gt; [1, 2, 3, [4, 5]]</span></p></li><li id="iesucks-po" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
public_send(symbol [, args...])<br>
public_send(string [, args...])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">po</span> <span class="TermText qDef lang-en">Invokes the method identified by symbol, passing it any arguments<br>
specified. Unlike send, #public_send calls public<br>
methods only. When the method is identified by a string, the string is<br>
converted to a symbol.<br>
<br>
1.public_send(:puts, "hello") # causes NoMethodError</span></p></li><li id="iesucks-lv" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
glob( pattern, [flags] )<br>
glob( pattern, [flags] ) {| filename | block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lv</span> <span class="TermText qDef lang-en">Returns the filenames found by expanding pattern which is an<br>
Array of the patterns or the pattern String,<br>
either as an array or as parameters to the block. Note that this<br>
pattern is not a regexp (it's closer to a shell glob). See<br>
File::fnmatch for the meaning of the flags parameter.<br>
Note that case sensitivity depends on your system (so<br>
File::FNM_CASEFOLD is ignored), as does the order in which the<br>
results are returned.<br>
<br>
Dir["config.?"] #=&gt; ["config.h"]<br>
Dir.glob("config.?") #=&gt; ["config.h"]<br>
Dir.glob("*.[a-z][a-z]") #=&gt; ["main.rb"]<br>
Dir.glob("<b>.[^r]</b>") #=&gt; ["config.h"]<br>
Dir.glob("*.{rb,h}") #=&gt; ["main.rb", "config.h"]<br>
Dir.glob("*") #=&gt; ["config.h", "main.rb"]<br>
Dir.glob("*", File::FNM_DOTMATCH) #=&gt; [".", "..", "config.h", "main.rb"]<br>
<br>
rbfiles = File.join("*<b>", "</b>.rb")<br>
Dir.glob(rbfiles) #=&gt; ["main.rb",<br>
 # "lib/song.rb",<br>
 # "lib/song/karaoke.rb"]<br>
libdirs = File.join("**", "lib")<br>
Dir.glob(libdirs) #=&gt; ["lib"]<br>
<br>
librbfiles = File.join("*<b>", "lib", "</b><b>", "</b>.rb")<br>
Dir.glob(librbfiles) #=&gt; ["lib/song.rb",<br>
 # "lib/song/karaoke.rb"]<br>
<br>
librbfiles = File.join("*<b>", "lib", "</b>.rb")<br>
Dir.glob(librbfiles) #=&gt; ["lib/song.rb"]</span></p></li><li id="iesucks-uh" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big &gt;&gt; numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uh</span> <span class="TermText qDef lang-en">Shifts big right numeric positions (left if numeric is<br>
negative).</span></p></li><li id="iesucks-jx" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
subsec</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jx</span> <span class="TermText qDef lang-en">Returns the fraction for time.<br>
<br>
t = Time.now #=&gt; 2009-03-26 22:33:12 +0900<br>
"%10.9f" % t.to_f #=&gt; "1238074392.940563917"<br>
t.subsec #=&gt; (94056401/100000000)</span></p></li><li id="iesucks-nn" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
swapcase</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nn</span> <span class="TermText qDef lang-en">Same as sym.to_s.swapcase.intern.</span></p></li><li id="iesucks-ol" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
symlink?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ol</span> <span class="TermText qDef lang-en">Returns true if stat is a symbolic link,<br>
false if it isn't or if the operating system doesn't support<br>
this feature. As File::stat automatically follows symbolic<br>
links, symlink? will always be false for an<br>
object returned by File::stat.<br>
<br>
File.symlink("testfile", "alink") #=&gt; 0<br>
File.stat("alink").symlink? #=&gt; false<br>
File.lstat("alink").symlink? #=&gt; true</span></p></li><li id="iesucks-pk" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pk</span> <span class="TermText qDef lang-en">Returns true only if obj has the same value as<br>
big. Contrast this with Bignum#eql?, which requires<br>
obj to be a Bignum.<br>
<br>
68719476736 == 68719476736.0 #=&gt; true</span></p></li><li id="iesucks-tw" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
flock(locking_constant)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tw</span> <span class="TermText qDef lang-en">Locks or unlocks a file according to locking_constant (a logical<br>
or of the values in the table below). Returns false<br>
if File::LOCK_NB is specified and the operation would<br>
otherwise have blocked. Not available on all platforms.<br>
<br>
LOCK_EX | Exclusive lock. Only one process may hold an<br>
 | exclusive lock for a given file at a time.<br>
----------+------------------------------------------------<br>
LOCK_NB | Don't block when locking. May be combined<br>
 | with other lock options using logical or.<br>
----------+------------------------------------------------<br>
LOCK_SH | Shared lock. Multiple processes may each hold a<br>
 | shared lock for a given file at the same time.<br>
----------+------------------------------------------------<br>
LOCK_UN | Unlock.</span></p></li><li id="iesucks-eb" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
instance_variable_defined?(symbol)<br>
instance_variable_defined?(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">eb</span> <span class="TermText qDef lang-en">Returns true if the given instance variable is defined in<br>
obj. String arguments are converted to<br>
symbols.<br>
<br>
class Fred<br>
 def initialize(p1, p2)<br>
 @a, @b = p1, p2<br>
 end<br>
end<br>
fred = Fred.new('cat', 99)<br>
fred.instance_variable_defined?(:@a) #=&gt; true<br>
fred.instance_variable_defined?("@b") #=&gt; true<br>
fred.instance_variable_defined?("@c") #=&gt; false</span></p></li><li id="iesucks-df" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
value?(value)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">df</span> <span class="TermText qDef lang-en">Returns true if there is an environment variable with the<br>
given value.</span></p></li><li id="iesucks-nk" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
ascii_only?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nk</span> <span class="TermText qDef lang-en">Returns true for a string which has only ASCII characters.<br>
<br>
"abc".force_encoding("UTF-8").ascii_only? #=&gt; true<br>
"abc\u{6666}".force_encoding("UTF-8").ascii_only? #=&gt; false</span></p></li><li id="iesucks-px" class="wrong-q"><b> <span class="TermText qWord lang-math">METHOD<br>
clone</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">px</span> <span class="TermText qDef lang-en">Returns a clone of this method.<br>
<br>
class A<br>
 def foo<br>
 return "bar"<br>
 end<br>
end<br>
<br>
m = A.new.method(:foo)<br>
m.call # =&gt; "bar"<br>
n = m.clone.call # =&gt; "bar"</span></p></li><li id="iesucks-gm" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
close_write</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gm</span> <span class="TermText qDef lang-en">Closes the write end of a duplex I/O stream (i.e., one that contains both a<br>
read and a write stream, such as a pipe). Will raise an<br>
IOError if the stream is not duplexed.<br>
<br>
f = IO.popen("/bin/sh^!^r+")<br>
f.close_write<br>
f.print "nowhere"</span></p></li><li id="iesucks-kl" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
attr_reader(symbol, ...)<br>
attr(symbol, ...)<br>
attr_reader(string, ...)<br>
attr(string, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kl</span> <span class="TermText qDef lang-en">Creates instance variables and corresponding methods that return the value<br>
of each instance variable. Equivalent to calling<br>
"attr:name" on each name in turn. String arguments are converted to symbols.</span></p></li><li id="iesucks-jq" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
print()<br>
print(obj, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jq</span> <span class="TermText qDef lang-en">Writes the given object(s) to ios. The stream must be opened for<br>
writing. If the output field separator ($,) is not<br>
nil, it will be inserted between each object. If the output<br>
record separator ($\&lt;/code&gt;) is not &lt;code&gt;nil, it<br>
will be appended to the output. If no arguments are given, prints<br>
$_. Objects that aren't strings will be converted by calling<br>
their to_s method. With no argument, prints the contents of<br>
the variable $_. Returns nil.<br>
<br>
$stdout.print("This is ", 100, " percent.\n")</span></p></li><li id="iesucks-gx" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
-fix</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gx</span> <span class="TermText qDef lang-en">Negates fix (which might return a Bignum).</span></p></li><li id="iesucks-mq" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
number other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mq</span> <span class="TermText qDef lang-en">Returns zero if number equals other, otherwise<br>
nil is returned if the two values are incomparable.</span></p></li><li id="iesucks-wz" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
methods(regular=true)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wz</span> <span class="TermText qDef lang-en">Returns a list of the names of public and protected methods of<br>
obj. This will include all the methods accessible in<br>
obj's ancestors. If the regular parameter is set to<br>
false, Returns an array of obj's public and protected<br>
singleton methods, the array will not include methods in modules included<br>
in obj.<br>
<br>
class Klass<br>
 def klass_method()<br>
 end<br>
end<br>
k = Klass.new<br>
k.methods[0..9] #=&gt; [:klass_method, :nil?, :===,<br>
 # :==~, :!, :eql?<br>
 # :hash, :&lt;=&gt;, :class, :singleton_class]<br>
k.methods.length #=&gt; 57<br>
<br>
k.methods(false) #=&gt; []<br>
def k.singleton_method; end<br>
k.methods(false) #=&gt; [:singleton_method]<br>
<br>
module M123; def m123; end end<br>
k.extend M123<br>
k.methods(false) #=&gt; [:singleton_method]</span></p></li><li id="iesucks-cn" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
min<br>
min {| a,b | block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cn</span> <span class="TermText qDef lang-en">Returns the minimum value in the range. Returns nil if the<br>
begin value of the range is larger than the end value.<br>
<br>
(10..20).min #=&gt; 10</span></p></li><li id="iesucks-tt" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
sub(pattern, replacement)<br>
sub(pattern, hash)<br>
sub(pattern) {|match| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tt</span> <span class="TermText qDef lang-en">Returns a copy of str with the first occurrence of<br>
pattern replaced by the second argument. The<br>
pattern is typically a Regexp; if<br>
given as a String, any regular expression<br>
metacharacters it contains will be interpreted literally, e.g.<br>
'\\d' will match a backlash followed by 'd', instead of a<br>
digit.<br>
<br>
"hello".sub(/[aeiou]/, '<b>') #=&gt; "h</b>llo"<br>
"hello".sub(/([aeiou])/, '&lt;\1&gt;') #=&gt; "h&lt;e&gt;llo"<br>
"hello".sub(/./) {|s| s.ord.to_s + ' ' } #=&gt; "104 ello"<br>
"hello".sub(/(?&lt;foo&gt;[aeiou])/, '<b>\k&lt;foo&gt;</b>') #=&gt; "h<b>e</b>llo"<br>
'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)<br>
 #=&gt; "Is /bin/bash your preferred shell?"</span></p></li><li id="iesucks-ab" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
reverse</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ab</span> <span class="TermText qDef lang-en">Returns a new array containing self's elements in reverse<br>
order.<br>
<br>
[ "a", "b", "c" ].reverse #=&gt; ["c", "b", "a"]<br>
[ 1 ].reverse #=&gt; [1]</span></p></li><li id="iesucks-in" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
ceil</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">in</span> <span class="TermText qDef lang-en">Returns the smallest Integer greater than or equal to<br>
flt.<br>
<br>
1.2.ceil #=&gt; 2<br>
2.0.ceil #=&gt; 2<br>
(-1.2).ceil #=&gt; -1<br>
(-2.0).ceil #=&gt; -2</span></p></li><li id="iesucks-nc" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
copy_stream(src, dst)<br>
copy_stream(src, dst, copy_length)<br>
copy_stream(src, dst, copy_length, src_offset)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nc</span> <span class="TermText qDef lang-en">::copy_stream copies<br>
src to dst. src and dst is either a<br>
filename or an IO.</span></p></li><li id="iesucks-qw" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
to_f</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qw</span> <span class="TermText qDef lang-en">Converts big to a Float. If big doesn't fit<br>
in a Float, the result is infinity.</span></p></li><li id="iesucks-pv" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERATOR<br>
each {...}</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pv</span> <span class="TermText qDef lang-en">Iterates over the block according to how this Enumerable was constructed. If no block is<br>
given, returns self.</span></p></li><li id="iesucks-ty" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
size</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ty</span> <span class="TermText qDef lang-en">Returns the number of elements in the range.<br>
<br>
(10..20).size #=&gt; 11</span></p></li><li id="iesucks-eg" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
encoding</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">eg</span> <span class="TermText qDef lang-en">Returns the Encoding object that represents the<br>
encoding of obj.</span></p></li><li id="iesucks-jt" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
delete(name)<br>
delete(name) { |name| }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jt</span> <span class="TermText qDef lang-en">Deletes the environment variable with name and returns the<br>
value of the variable. If a block is given it will be called when the<br>
named environment does not exist.</span></p></li><li id="iesucks-ft" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
path</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ft</span> <span class="TermText qDef lang-en">Returns the path parameter passed to dir's constructor.<br>
<br>
d = Dir.new("..")<br>
d.path #=&gt; ".."</span></p></li><li id="iesucks-wt" class="wrong-q"><b> <span class="TermText qWord lang-math">BASICOBJECT<br>
method_missing(symbol [, *args] )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wt</span> <span class="TermText qDef lang-en">Invoked by Ruby when obj is sent a message it cannot handle.<br>
symbol is the symbol for the method called, and args are<br>
any arguments that were passed to it. By default, the interpreter raises an<br>
error when this method is called. However, it is possible to override the<br>
method to provide more dynamic behavior. If it is decided that a particular<br>
method should not be handled, then super should be called, so that<br>
ancestors can pick up the missing method. The example below creates a class<br>
Roman, which responds to methods with names consisting of<br>
roman numerals, returning the corresponding integer values.<br>
<br>
class Roman<br>
 def roman_to_int(str)<br>
 # ...<br>
 end<br>
 def method_missing(methId)<br>
 str = methId.id2name<br>
 roman_to_int(str)<br>
 end<br>
end<br>
<br>
r = Roman.new<br>
r.iv #=&gt; 4<br>
r.xxiii #=&gt; 23<br>
r.mm #=&gt; 2000</span></p></li><li id="iesucks-bx" class="wrong-q"><b> <span class="TermText qWord lang-math">MATCHDATA<br>
begin(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bx</span> <span class="TermText qDef lang-en">Returns the offset of the start of the nth element of the match<br>
array in the string. n can be a string or symbol to reference a<br>
named capture.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.begin(0) #=&gt; 1<br>
m.begin(2) #=&gt; 2<br>
<br>
m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match("hoge")<br>
p m.begin(:foo) #=&gt; 0<br>
p m.begin(:bar) #=&gt; 2</span></p></li><li id="iesucks-sm" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
proc { |...| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sm</span> <span class="TermText qDef lang-en">Equivalent to Proc.new.</span></p></li><li id="iesucks-jc" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
advise(advice, offset=0, len=0)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jc</span> <span class="TermText qDef lang-en">advice is one of the following symbols:<br>
<br>
Announce an intention to access data from the current file in a<br>
specific pattern. On platforms that do not support the<br>
&lt;em&gt;posix_fadvise(2)&lt;/em&gt; system call, this method is a no-op.</span></p></li><li id="iesucks-lu" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
read([length [, outbuf]])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lu</span> <span class="TermText qDef lang-en">Reads length bytes from the I/O stream.<br>
<br>
f = File.new("testfile")<br>
f.read(16) #=&gt; "This is line one"<br>
<br>
# reads whole file<br>
open("file") {|f|<br>
 data = f.read # This returns a string even if the file is empty.<br>
 ...<br>
}<br>
<br>
# iterate over fixed length records.<br>
open("fixed-record-file") {|f|<br>
 while record = f.read(256)<br>
 ...<br>
 end<br>
}<br>
<br>
# iterate over variable length records.<br>
# record is prefixed by 32-bit length.<br>
open("variable-record-file") {|f|<br>
 while len = f.read(4)<br>
 len = len.unpack("N")[0] # 32-bit length<br>
 record = f.read(len) # This returns a string even if len is 0.<br>
 end<br>
}</span></p></li><li id="iesucks-vf" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
ary[index] = obj<br>
ary[start, length] = obj or other_ary or nil<br>
ary[range] = obj or other_ary or nil</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vf</span> <span class="TermText qDef lang-en">Element Assignment — Sets the element at index, or replaces a<br>
subarray from the start index for length<br>
elements, or replaces a subarray specified by the range of<br>
indices.<br>
<br>
a = Array.new<br>
a[4] = "4"; #=&gt; [nil, nil, nil, nil, "4"]<br>
a[0, 3] = [ 'a', 'b', 'c' ] #=&gt; ["a", "b", "c", nil, "4"]<br>
a[1..2] = [ 1, 2 ] #=&gt; ["a", 1, 2, nil, "4"]<br>
a[0, 2] = "?" #=&gt; ["?", 2, nil, "4"]<br>
a[0..2] = "A" #=&gt; ["A", "4"]<br>
a[-1] = "Z" #=&gt; ["A", "Z"]<br>
a[1..-1] = nil #=&gt; ["A", nil]<br>
a[1..-1] = [] #=&gt; ["A"]<br>
a[0, 0] = [ 1, 2 ] #=&gt; [1, 2, "A"]<br>
a[3, 0] = "B" #=&gt; [1, 2, "A", "B"]</span></p></li><li id="iesucks-kj" class="wrong-q"><b> <span class="TermText qWord lang-math">STRUCT<br>
members</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kj</span> <span class="TermText qDef lang-en">Returns an array of symbols representing the names of the instance<br>
variables.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
joe.members #=&gt; [:name, :address, :zip]</span></p></li><li id="iesucks-kh" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
-num</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kh</span> <span class="TermText qDef lang-en">Unary Minus—Returns the receiver's value, negated.</span></p></li><li id="iesucks-ku" class="wrong-q"><b> <span class="TermText qWord lang-math">STRUCT<br>
length</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ku</span> <span class="TermText qDef lang-en">Returns the number of instance variables.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
joe.length #=&gt; 3</span></p></li><li id="iesucks-ts" class="wrong-q"><b> <span class="TermText qWord lang-math">BASICOBJECT<br>
!obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ts</span> <span class="TermText qDef lang-en">Boolean negate.</span></p></li><li id="iesucks-pc" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
fdiv(numeric)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pc</span> <span class="TermText qDef lang-en">Returns float division.</span></p></li><li id="iesucks-dz" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
product(other_ary, ...)<br>
product(other_ary, ...) { |p| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dz</span> <span class="TermText qDef lang-en">Returns an array of all combinations of elements from all arrays.<br>
<br>
[1,2,3].product([4,5]) #=&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]<br>
[1,2].product([1,2]) #=&gt; [[1,1],[1,2],[2,1],[2,2]]<br>
[1,2].product([3,4],[5,6]) #=&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],<br>
 # [2,3,5],[2,3,6],[2,4,5],[2,4,6]]<br>
[1,2].product() #=&gt; [[1],[2]]<br>
[1,2].product([]) #=&gt; []</span></p></li><li id="iesucks-wa" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
numerator</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wa</span> <span class="TermText qDef lang-en">Returns the numerator.</span></p></li><li id="iesucks-rx" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
to_f</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rx</span> <span class="TermText qDef lang-en">As flt is already a float, returns self.</span></p></li><li id="iesucks-ws" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
close</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ws</span> <span class="TermText qDef lang-en">Closes ios and flushes any pending writes to the operating system.<br>
The stream is unavailable for any further data operations; an<br>
IOError is raised if such an attempt is made. I/O streams are<br>
automatically closed when they are claimed by the garbage collector.</span></p></li><li id="iesucks-uy" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
ary - other_ary</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uy</span> <span class="TermText qDef lang-en">Array Difference<br>
<br>
[ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ] #=&gt; [ 3, 3, 5 ]</span></p></li><li id="iesucks-al" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
strip</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">al</span> <span class="TermText qDef lang-en">Returns a copy of str with leading and trailing whitespace<br>
removed.<br>
<br>
" hello ".strip #=&gt; "hello"<br>
"\tgoodbye\r\n".strip #=&gt; "goodbye"</span></p></li><li id="iesucks-ba" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
upto(other_str, exclusive=false) {|s| block }<br>
upto(other_str, exclusive=false)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ba</span> <span class="TermText qDef lang-en">Iterates through successive values, starting at str and ending at<br>
other_str inclusive, passing each value in turn to the block. The<br>
String#succ method is used to generate each value. If<br>
optional second argument exclusive is omitted or is false, the last value<br>
will be included; otherwise it will be excluded.<br>
<br>
"a8".upto("b6") {|s| print s, ' ' }<br>
for s in "a8".."b6"<br>
 print s, ' '<br>
end</span></p></li><li id="iesucks-m" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
private_instance_methods(include_super=true)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">m</span> <span class="TermText qDef lang-en">Returns a list of the private instance methods defined in mod. If<br>
the optional parameter is not false, the methods of any<br>
ancestors are included.<br>
<br>
module Mod<br>
 def method1() end<br>
 private :method1<br>
 def method2() end<br>
end<br>
Mod.instance_methods #=&gt; [:method2]<br>
Mod.private_instance_methods #=&gt; [:method1]</span></p></li><li id="iesucks-mk" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
lchmod(mode_int, file_name, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mk</span> <span class="TermText qDef lang-en">Equivalent to File::chmod, but does not follow symbolic links<br>
(so it will change the permissions associated with the link, not the file<br>
referenced by the link). Often not available.</span></p></li><li id="iesucks-mi" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
size</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mi</span> <span class="TermText qDef lang-en">Returns the character length of str.</span></p></li><li id="iesucks-dc" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
split(pattern=$;, [limit])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dc</span> <span class="TermText qDef lang-en">Divides str into substrings based on a delimiter, returning an<br>
array of these substrings.<br>
<br>
" now's the time".split #=&gt; ["now's", "the", "time"]<br>
" now's the time".split(' ') #=&gt; ["now's", "the", "time"]<br>
" now's the time".split(/ /) #=&gt; ["", "now's", "", "the", "time"]<br>
"1, 2.34,56, 7".split(%r{,\s*}) #=&gt; ["1", "2.34", "56", "7"]<br>
"hello".split(//) #=&gt; ["h", "e", "l", "l", "o"]<br>
"hello".split(//, 3) #=&gt; ["h", "e", "llo"]<br>
"hi mom".split(%r{\s*}) #=&gt; ["h", "i", "m", "o", "m"]<br>
<br>
"mellow yellow".split("ello") #=&gt; ["m", "w y", "w"]<br>
"1,2,,3,4,,".split(',') #=&gt; ["1", "2", "", "3", "4"]<br>
"1,2,,3,4,,".split(',', 4) #=&gt; ["1", "2", "", "3,4,,"]<br>
"1,2,,3,4,,".split(',', -4) #=&gt; ["1", "2", "", "3", "4", "", ""]<br>
<br>
"".split(',', -1) #=&gt; []</span></p></li><li id="iesucks-bo" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
obj !~ other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bo</span> <span class="TermText qDef lang-en">Returns true if two objects do not match (using the =~ method),<br>
otherwise false.</span></p></li><li id="iesucks-j" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
intern</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">j</span> <span class="TermText qDef lang-en">Returns the Symbol corresponding to str, creating the<br>
symbol if it did not previously exist. See Symbol#id2name.<br>
<br>
"Koala".intern #=&gt; :Koala<br>
s = 'cat'.to_sym #=&gt; :cat<br>
s == :cat #=&gt; true<br>
s = '@cat'.to_sym #=&gt; :@cat<br>
s == :@cat #=&gt; true</span></p></li><li id="iesucks-ni" class="wrong-q"><b> <span class="TermText qWord lang-math">COMPARABLE<br>
obj &gt;= other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ni</span> <span class="TermText qDef lang-en">Compares two objects based on the receiver's &lt;=&gt; method,<br>
returning true if it returns 0 or 1.</span></p></li><li id="iesucks-ry" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
to_int</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ry</span> <span class="TermText qDef lang-en">Invokes the child class's to_i method to convert<br>
num to an integer.<br>
<br>
1.0.class =&gt; Float<br>
1.0.to_int.class =&gt; Fixnum<br>
1.0.to_i.class =&gt; Fixnum</span></p></li><li id="iesucks-cj" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
getgm</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cj</span> <span class="TermText qDef lang-en">Returns a new Time object representing<br>
time in UTC.<br>
<br>
t = Time.local(2000,1,1,20,15,1) #=&gt; 2000-01-01 20:15:01 -0600<br>
t.gmt? #=&gt; false<br>
y = t.getgm #=&gt; 2000-01-02 02:15:01 UTC<br>
y.gmt? #=&gt; true<br>
t == y #=&gt; true</span></p></li><li id="iesucks-st" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
join(separator=$,)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">st</span> <span class="TermText qDef lang-en">Returns a string created by converting each element of the array to a<br>
string, separated by the given separator. If the<br>
separator is nil, it uses current $,. If both the<br>
separator and $, are nil, it uses empty string.<br>
<br>
[ "a", "b", "c" ].join #=&gt; "abc"<br>
[ "a", "b", "c" ].join("-") #=&gt; "a-b-c"</span></p></li><li id="iesucks-gh" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
invert</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gh</span> <span class="TermText qDef lang-en">Returns a new hash created by using environment variable names as values<br>
and values as names.</span></p></li><li id="iesucks-qe" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
divmod(numeric)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qe</span> <span class="TermText qDef lang-en">Returns an array containing the quotient and modulus obtained by dividing<br>
num by numeric. If q, r = x.divmod(y), then<br>
<br>
q = floor(x/y)<br>
x = q*y+r</span></p></li><li id="iesucks-ia" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
conjugate</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ia</span> <span class="TermText qDef lang-en">Returns self.</span></p></li><li id="iesucks-qq" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
ary &amp; other_ary</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qq</span> <span class="TermText qDef lang-en">Set Intersection — Returns a new array containing elements common to the<br>
two arrays, excluding any duplicates. The order is preserved from the<br>
original array.<br>
<br>
[ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ] #=&gt; [ 1, 3 ]<br>
[ 'a', 'b', 'b', 'z' ] &amp; [ 'a', 'b', 'c' ] #=&gt; [ 'a', 'b' ]</span></p></li><li id="iesucks-kz" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
mode</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kz</span> <span class="TermText qDef lang-en">Returns an integer representing the permission bits of stat. The<br>
meaning of the bits is platform dependent; on Unix systems, see<br>
stat(2).<br>
<br>
File.chmod(0644, "testfile") #=&gt; 1<br>
s = File.stat("testfile")<br>
sprintf("%o", s.mode) #=&gt; "100644"</span></p></li><li id="iesucks-gf" class="wrong-q"><b> <span class="TermText qWord lang-math">METHOD<br>
meth[args, ...]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gf</span> <span class="TermText qDef lang-en">Invokes the meth with the specified arguments, returning the<br>
method's return value.<br>
<br>
m = 12.method("+")<br>
m.call(3) #=&gt; 15<br>
m.call(20) #=&gt; 32</span></p></li><li id="iesucks-je" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
to_f</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">je</span> <span class="TermText qDef lang-en">Returns the result of interpreting leading characters in str as a<br>
floating point number. Extraneous characters past the end of a valid number<br>
are ignored. If there is not a valid number at the start of str,<br>
0.0 is returned. This method never raises an exception.<br>
<br>
"123.45e1".to_f #=&gt; 1234.5<br>
"45.67 degrees".to_f #=&gt; 45.67<br>
"thx1138".to_f #=&gt; 0.0</span></p></li><li id="iesucks-aa" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
autoclose?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">aa</span> <span class="TermText qDef lang-en">Returns true if the underlying file descriptor of ios<br>
will be closed automatically at its finalization, otherwise<br>
false.</span></p></li><li id="iesucks-qb" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
sprintf(format_string [, arguments...] )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qb</span> <span class="TermText qDef lang-en">Returns the string resulting from applying format_string to any<br>
additional arguments. Within the format string, any characters other than<br>
format sequences are copied to the result.<br>
<br>
%[flags][width][.precision]type</span></p></li><li id="iesucks-wg" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
encode(encoding [, options] )<br>
encode(dst_encoding, src_encoding [, options] )<br>
encode([options])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wg</span> <span class="TermText qDef lang-en">The first form returns a copy of str transcoded to encoding<br>
encoding. The second form returns a copy of str<br>
transcoded from src_encoding to dst_encoding. The last form returns a copy<br>
of str transcoded to Encoding.default_internal.</span></p></li><li id="iesucks-bi" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
bytes</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bi</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_byte.</span></p></li><li id="iesucks-bc" class="wrong-q"><b> <span class="TermText qWord lang-math">STRUCT<br>
to_a</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bc</span> <span class="TermText qDef lang-en">Returns the values for this instance as an array.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
joe.to_a[1] #=&gt; "123 Maple, Anytown NC"</span></p></li><li id="iesucks-tu" class="wrong-q"><b> <span class="TermText qWord lang-math">PROC<br>
call(params,...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tu</span> <span class="TermText qDef lang-en">Invokes the block, setting the block's parameters to the values in<br>
params using something close to method calling semantics.<br>
Generates a warning if multiple values are passed to a proc that expects<br>
just one (previously this silently converted the parameters to an array). <br>
Note that prc.() invokes prc.call() with the parameters given. It's a<br>
syntax sugar to hide "call".<br>
<br>
a_proc = Proc.new {|a, <b>b| b.collect {|i| i</b>a }}<br>
a_proc.call(9, 1, 2, 3) #=&gt; [9, 18, 27]<br>
a_proc[9, 1, 2, 3] #=&gt; [9, 18, 27]<br>
a_proc = lambda {|a,b| a}<br>
a_proc.call(1,2,3)</span></p></li><li id="iesucks-ma" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
flt <br>
 <br>
 click to toggle source</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ma</span> <span class="TermText qDef lang-en">true if flt is less than real. The<br>
result of NaN &lt; NaN is undefined, so the<br>
implementation-dependent value is returned.</span></p></li><li id="iesucks-oc" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
absolute_path(file_name [, dir_string] )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oc</span> <span class="TermText qDef lang-en">Converts a pathname to an absolute pathname. Relative paths are referenced<br>
from the current working directory of the process unless<br>
dir_string is given, in which case it will be used as the starting<br>
point. If the given pathname starts with a "~" it is NOT<br>
expanded, it is treated as a normal directory name.<br>
<br>
File.absolute_path("~oracle/bin") #=&gt; "&lt;relative_path&gt;/~oracle/bin"</span></p></li><li id="iesucks-dx" class="wrong-q"><b> <span class="TermText qWord lang-math">BASICOBJECT<br>
singleton_method_added(symbol)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dx</span> <span class="TermText qDef lang-en">Invoked as a callback whenever a singleton method is added to the receiver.<br>
<br>
module Chatty<br>
 def Chatty.singleton_method_added(id)<br>
 puts "Adding #{id.id2name}"<br>
 end<br>
 def self.one() end<br>
 def two() end<br>
 def Chatty.three() end<br>
end</span></p></li><li id="iesucks-ga" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
sticky?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ga</span> <span class="TermText qDef lang-en">Returns true if stat has its sticky bit set,<br>
false if it doesn't or if the operating system doesn't support<br>
this feature.<br>
<br>
File.stat("testfile").sticky? #=&gt; false</span></p></li><li id="iesucks-to" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
method_removed(method_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">to</span> <span class="TermText qDef lang-en">Invoked as a callback whenever an instance method is removed from the<br>
receiver.<br>
<br>
module Chatty<br>
 def self.method_removed(method_name)<br>
 puts "Removing #{method_name.inspect}"<br>
 end<br>
 def self.some_class_method() end<br>
 def some_instance_method() end<br>
 class &lt;&lt; self<br>
 remove_method :some_class_method<br>
 end<br>
 remove_method :some_instance_method<br>
end</span></p></li><li id="iesucks-ot" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
lines(separator=$/)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ot</span> <span class="TermText qDef lang-en">Returns an array of lines in str split using the supplied record<br>
separator ($/ by default). This is a shorthand for<br>
str.each_line(separator).to_a.</span></p></li><li id="iesucks-uk" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
readbyte</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uk</span> <span class="TermText qDef lang-en">Reads a byte as with IO#getbyte, but raises an<br>
EOFError on end of file.</span></p></li><li id="iesucks-ih" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
each_pair { |name, value| }<br>
each_pair</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ih</span> <span class="TermText qDef lang-en">Yields each environment variable name and value.</span></p></li><li id="iesucks-kp" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
inspect",<br>
"BIGNUM<br>
magnitude</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kp</span> <span class="TermText qDef lang-en">Returns the absolute value of big.<br>
<br>
-1234567890987654321.abs #=&gt; 1234567890987654321</span></p></li><li id="iesucks-qf" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
zip(arg, ...)<br>
zip(arg, ...) { |arr| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qf</span> <span class="TermText qDef lang-en">Takes one element from enum and merges corresponding elements from<br>
each args. This generates a sequence of n-element<br>
arrays, where n is one more than the count of arguments. The<br>
length of the resulting sequence will be enum#size. If the<br>
size of any argument is less than enum#size, nil<br>
values are supplied. If a block is given, it is invoked for each output<br>
array, otherwise an array of arrays is returned.<br>
<br>
a = [ 4, 5, 6 ]<br>
b = [ 7, 8, 9 ]<br>
<br>
[1, 2, 3].zip(a, b) #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]<br>
[1, 2].zip(a, b) #=&gt; [[1, 4, 7], [2, 5, 8]]<br>
a.zip([1, 2], [8]) #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</span></p></li><li id="iesucks-u" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
delete!([other_str]+)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">u</span> <span class="TermText qDef lang-en">Performs a delete operation in place, returning str,<br>
or nil if str was not modified.</span></p></li><li id="iesucks-tq" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
pipe?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tq</span> <span class="TermText qDef lang-en">Returns true if the named file is a pipe.</span></p></li><li id="iesucks-z" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
Rational(x[, y])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">z</span> <span class="TermText qDef lang-en">Returns x/y;<br>
<br>
Rational(1, 2) #=&gt; (1/2)<br>
Rational('1/2') #=&gt; (1/2)</span></p></li><li id="iesucks-wk" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
chr</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wk</span> <span class="TermText qDef lang-en">Returns a one-character string at the beginning of the string.<br>
<br>
a = "abcde"<br>
a.chr #=&gt; "a"</span></p></li><li id="iesucks-de" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
rotate!(count=1)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">de</span> <span class="TermText qDef lang-en">Rotates self in place so that the element at<br>
count comes first, and returns self.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.rotate! #=&gt; ["b", "c", "d", "a"]<br>
a #=&gt; ["b", "c", "d", "a"]<br>
a.rotate!(2) #=&gt; ["d", "a", "b", "c"]<br>
a.rotate!(-3) #=&gt; ["a", "b", "c", "d"]</span></p></li><li id="iesucks-bg" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
select(read_array<br>
[, write_array<br>
[, error_array<br>
[, timeout]]])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bg</span> <span class="TermText qDef lang-en">Calls select(2) system call. It monitors given arrays of IO<br>
objects, waits one or more of IO objects ready for reading,<br>
are ready for writing, and have pending exceptions respectively, and<br>
returns an array that contains arrays of those IO<br>
objects. It will return nil if optional timeout<br>
value is given and no IO object is ready in timeout<br>
seconds.<br>
<br>
rp, wp = IO.pipe<br>
mesg = "ping "<br>
100.times {<br>
 rs, ws, = IO.select([rp], [wp])<br>
 if r = rs[0]<br>
 ret = r.read(5)<br>
 print ret<br>
 case ret<br>
 when /ping/<br>
 mesg = "pong\n"<br>
 when /pong/<br>
 mesg = "ping "<br>
 end<br>
 end<br>
 if w = ws[0]<br>
 w.write(mesg)<br>
 end<br>
}</span></p></li><li id="iesucks-qj" class="wrong-q"><b> <span class="TermText qWord lang-math">RANDOM<br>
new_seed</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qj</span> <span class="TermText qDef lang-en">Returns an arbitrary seed value. This is used by ::new when no seed value is specified<br>
as an argument.<br>
<br>
Random.new_seed #=&gt; 115032730400174366788466674494640623225</span></p></li><li id="iesucks-cm" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
readlink(link_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cm</span> <span class="TermText qDef lang-en">Returns the name of the file referenced by the given link. Not available on<br>
all platforms.<br>
<br>
File.symlink("testfile", "link2test") #=&gt; 0<br>
File.readlink("link2test") #=&gt; "testfile"</span></p></li><li id="iesucks-qv" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
reopen(other_IO)<br>
reopen(path, mode_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qv</span> <span class="TermText qDef lang-en">Reassociates ios with the I/O stream given in other_IO or<br>
to a new stream opened on path. This may dynamically change the<br>
actual class of this stream.<br>
<br>
f1 = File.new("testfile")<br>
f2 = File.new("testfile")<br>
f2.readlines[0] #=&gt; "This is line one\n"<br>
f2.reopen(f1) #=&gt; #&lt;File:testfile&gt;<br>
f2.readlines[0] #=&gt; "This is line one\n"</span></p></li><li id="iesucks-su" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
Dir[ array ]<br>
Dir[ string [, string ...] ]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">su</span> <span class="TermText qDef lang-en">Equivalent to calling Dir.glob(array,0)<br>
and Dir.glob([string,...],0).</span></p></li><li id="iesucks-vt" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
rindex(obj)<br>
rindex { |item| block }<br>
rindex</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vt</span> <span class="TermText qDef lang-en">Returns the index of the last object in self<br>
== to obj.<br>
<br>
a = [ "a", "b", "b", "b", "c" ]<br>
a.rindex("b") #=&gt; 3<br>
a.rindex("z") #=&gt; nil<br>
a.rindex { |x| x == "b" } #=&gt; 3</span></p></li><li id="iesucks-ug" class="wrong-q"><b> <span class="TermText qWord lang-math">METHOD<br>
unbind</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ug</span> <span class="TermText qDef lang-en">Dissociates meth from its current receiver. The resulting<br>
UnboundMethod can subsequently be bound to a new object of the<br>
same class (see UnboundMethod).</span></p></li><li id="iesucks-ju" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
gets(sep=$/)<br>
gets(limit)<br>
gets(sep,limit)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ju</span> <span class="TermText qDef lang-en">Returns (and assigns to $_) the next line from the list of<br>
files in ARGV (or $*), or from standard input if<br>
no files are present on the command line. Returns nil at end<br>
of file. The optional argument specifies the record separator. The<br>
separator is included with the contents of each record. A separator of<br>
nil reads the entire contents, and a zero-length separator<br>
reads the input one paragraph at a time, where paragraphs are divided by<br>
two consecutive newlines. If the first argument is an integer, or optional<br>
second argument is given, the returning string would not be longer than the<br>
given value in bytes. If multiple filenames are present in<br>
ARGV, +gets(nil)+ will read the contents one file at a time.<br>
<br>
ARGV &lt;&lt; "testfile"<br>
print while gets</span></p></li><li id="iesucks-vi" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
str[fixnum] = new_str<br>
str[fixnum, fixnum] = new_str<br>
str[range] = aString<br>
str[regexp] = new_str<br>
str[regexp, fixnum] = new_str<br>
str[regexp, name] = new_str<br>
str[other_str] = new_str</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vi</span> <span class="TermText qDef lang-en">Element Assignment—Replaces some or all of the content of str. The<br>
portion of the string affected is determined using the same criteria as<br>
String#[]. If the replacement string is not the same length as<br>
the text it is replacing, the string will be adjusted accordingly. If the<br>
regular expression or string is used as the index doesn't match a position<br>
in the string, IndexError is raised. If the regular expression<br>
form is used, the optional second Fixnum allows you to specify<br>
which portion of the match to replace (effectively using the<br>
MatchData indexing rules. The forms that take a<br>
Fixnum will raise an IndexError if the value is<br>
out of range; the Range form will raise a<br>
RangeError, and the Regexp and<br>
String will raise an IndexError on negative<br>
match.</span></p></li><li id="iesucks-mm" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mm</span> <span class="TermText qDef lang-en">Same as sym.to_s.succ.intern.</span></p></li><li id="iesucks-jj" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
abs2</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jj</span> <span class="TermText qDef lang-en">Returns square of self.</span></p></li><li id="iesucks-mw" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
isatty</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mw</span> <span class="TermText qDef lang-en">Returns true if ios is associated with a terminal<br>
device (tty), false otherwise.<br>
<br>
File.new("testfile").isatty #=&gt; false<br>
File.new("/dev/tty").isatty #=&gt; true</span></p></li><li id="iesucks-qp" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qp</span> <span class="TermText qDef lang-en">Return a string representing this module or class. For basic classes and<br>
modules, this is the name. For singletons, we show information on the thing<br>
we're attached to as well.</span></p></li><li id="iesucks-mu" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
year</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mu</span> <span class="TermText qDef lang-en">Returns the year for time (including the century).<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:27:51 -0600<br>
t.year #=&gt; 2007</span></p></li><li id="iesucks-pr" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
each {| key, value | block }<br>
each_pair {| key, value | block }<br>
each<br>
each_pair</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pr</span> <span class="TermText qDef lang-en">Calls block once for each key in hsh, passing the<br>
key-value pair as parameters.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.each {|key, value| puts "#{key} is #{value}" }</span></p></li><li id="iesucks-tg" class="wrong-q"><b> <span class="TermText qWord lang-math">NILCLASS<br>
to_a</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tg</span> <span class="TermText qDef lang-en">Always returns an empty array.<br>
<br>
nil.to_a #=&gt; []</span></p></li><li id="iesucks-py" class="wrong-q"><b> <span class="TermText qWord lang-math">FILETEST<br>
executable_real?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">py</span> <span class="TermText qDef lang-en">Returns true if the named file is executable by the real user<br>
id of this process.</span></p></li><li id="iesucks-cy" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
getc</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cy</span> <span class="TermText qDef lang-en">Reads the next character from ARGF and returns it as a<br>
String. Returns nil at the end of the stream.<br>
<br>
$ echo "foo" &gt; file<br>
$ ruby argf.rb file<br>
<br>
ARGF.getc #=&gt; "f"<br>
ARGF.getc #=&gt; "o"<br>
ARGF.getc #=&gt; "o"<br>
ARGF.getc #=&gt; "\n"<br>
ARGF.getc #=&gt; nil<br>
ARGF.getc #=&gt; nil</span></p></li><li id="iesucks-bv" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
size</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bv</span> <span class="TermText qDef lang-en">Returns the number of key-value pairs in the hash.<br>
<br>
h = { "d" =&gt; 100, "a" =&gt; 200, "v" =&gt; 300, "e" =&gt; 400 }<br>
h.length #=&gt; 4<br>
h.delete("a") #=&gt; 200<br>
h.length #=&gt; 3</span></p></li><li id="iesucks-mv" class="wrong-q"><b> <span class="TermText qWord lang-math">STRUCT<br>
to_s<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mv</span> <span class="TermText qDef lang-en">Describe the contents of this struct in a string.</span></p></li><li id="iesucks-fh" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
quo(numeric)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fh</span> <span class="TermText qDef lang-en">Returns float / numeric.</span></p></li><li id="iesucks-kr" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
gsub(pattern, replacement)<br>
gsub(pattern, hash)<br>
gsub(pattern) {|match| block }<br>
gsub(pattern)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kr</span> <span class="TermText qDef lang-en">Returns a copy of str with the all occurrences of<br>
pattern substituted for the second argument. The pattern<br>
is typically a Regexp; if given as a String, any<br>
regular expression metacharacters it contains will be interpreted<br>
literally, e.g. '\\d' will match a backlash followed by 'd',<br>
instead of a digit.<br>
<br>
"hello".gsub(/[aeiou]/, '<b>') #=&gt; "h</b>ll*"<br>
"hello".gsub(/([aeiou])/, '&lt;\1&gt;') #=&gt; "h&lt;e&gt;ll&lt;o&gt;"<br>
"hello".gsub(/./) {|s| s.ord.to_s + ' '} #=&gt; "104 101 108 108 111 "<br>
"hello".gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}') #=&gt; "h{e}ll{o}"<br>
'hello'.gsub(/[eo]/, 'e' =&gt; 3, 'o' =&gt; '<b>') #=&gt; "h3ll</b>"</span></p></li><li id="iesucks-pz" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
reverse!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pz</span> <span class="TermText qDef lang-en">Reverses str in place.</span></p></li><li id="iesucks-pd" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
tap{|x|...}</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pd</span> <span class="TermText qDef lang-en">Yields x to the block, and then returns x. The<br>
primary purpose of this method is to "tap into" a method chain, in order to<br>
perform operations on intermediate results within the chain.<br>
<br>
(1..10) .tap {|x| puts "original: #{x.inspect}"}<br>
 .to_a .tap {|x| puts "array: #{x.inspect}"}<br>
 .select {|x| x%2==0} .tap {|x| puts "evens: #{x.inspect}"}<br>
 .map { |x| x*x } .tap {|x| puts "squares: #{x.inspect}"}</span></p></li><li id="iesucks-ru" class="wrong-q"><b> <span class="TermText qWord lang-math">PROC<br>
arity</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ru</span> <span class="TermText qDef lang-en">Returns the number of arguments that would not be ignored. If the block is<br>
declared to take no arguments, returns 0. If the block is known to take<br>
exactly n arguments, returns n. If the block has optional arguments, return<br>
-n-1, where n is the number of mandatory arguments. A proc<br>
with no argument declarations is the same a block declaring ||<br>
as its arguments.<br>
<br>
proc {}.arity #=&gt; 0<br>
proc {||}.arity #=&gt; 0<br>
proc {|a|}.arity #=&gt; 1<br>
proc {|a,b|}.arity #=&gt; 2<br>
proc {|a,b,c|}.arity #=&gt; 3<br>
proc {|*a|}.arity #=&gt; -1<br>
proc {|a,*b|}.arity #=&gt; -2<br>
proc {|a,*b, c|}.arity #=&gt; -3<br>
<br>
proc { |x = 0| }.arity #=&gt; 0<br>
lambda { |a = 0| }.arity #=&gt; -1<br>
proc { |x=0, y| }.arity #=&gt; 1<br>
lambda { |x=0, y| }.arity #=&gt; -2<br>
proc { |x=0, y=0| }.arity #=&gt; 0<br>
lambda { |x=0, y=0| }.arity #=&gt; -1<br>
proc { |x, y=0| }.arity #=&gt; 1<br>
lambda { |x, y=0| }.arity #=&gt; -2<br>
proc { |(x, y), z=0| }.arity #=&gt; 1<br>
lambda { |(x, y), z=0| }.arity #=&gt; -2</span></p></li><li id="iesucks-g" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
flush</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">g</span> <span class="TermText qDef lang-en">Flushes any buffered data within ios to the underlying operating<br>
system (note that this is Ruby internal buffering only; the OS may buffer<br>
the data as well).<br>
<br>
$stdout.print "no newline"<br>
$stdout.flush</span></p></li><li id="iesucks-ea" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
drop_while { |arr| block }<br>
drop_while</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ea</span> <span class="TermText qDef lang-en">Drops elements up to, but not including, the first element for which the<br>
block returns nil or false and returns an array<br>
containing the remaining elements.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.drop_while { |i| i &lt; 3 } #=&gt; [3, 4, 5, 0]</span></p></li><li id="iesucks-qs" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
flt ** other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qs</span> <span class="TermText qDef lang-en">Raises float the other power.<br>
<br>
2.0**3 #=&gt; 8.0</span></p></li><li id="iesucks-mo" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
codepoints</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mo</span> <span class="TermText qDef lang-en">Returns an array of the Integer ordinals of the characters in<br>
str. This is a shorthand for<br>
str.each_codepoint.to_a.</span></p></li><li id="iesucks-qn" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
sort_by! { |obj| block }<br>
sort_by!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qn</span> <span class="TermText qDef lang-en">Sorts self in place using a set of keys generated by mapping<br>
the values in self through the given block.</span></p></li><li id="iesucks-x" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
angle</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">x</span> <span class="TermText qDef lang-en">Returns 0 if the value is positive, pi otherwise.</span></p></li><li id="iesucks-gv" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
bsearch {|x| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gv</span> <span class="TermText qDef lang-en">By using binary search, finds a value from this array which meets the given<br>
condition in O(log n) where n is the size of the array.<br>
<br>
ary = [0, 4, 7, 10, 12]<br>
ary.bsearch {|x| x &gt;= 4 } #=&gt; 4<br>
ary.bsearch {|x| x &gt;= 6 } #=&gt; 7<br>
ary.bsearch {|x| x &gt;= -1 } #=&gt; 0<br>
ary.bsearch {|x| x &gt;= 100 } #=&gt; nil</span></p></li><li id="iesucks-bn" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
binding</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bn</span> <span class="TermText qDef lang-en">Returns a Binding object, describing the variable and method<br>
bindings at the point of call. This object can be used when calling<br>
eval to execute the evaluated command in this environment. See<br>
also the description of class Binding.<br>
<br>
def get_binding(param)<br>
 return binding<br>
end<br>
b = get_binding("hello")<br>
eval("param", b) #=&gt; "hello"</span></p></li><li id="iesucks-ej" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
setuid?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ej</span> <span class="TermText qDef lang-en">Returns true if the named file has the setuid bit set.</span></p></li><li id="iesucks-gg" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
take(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gg</span> <span class="TermText qDef lang-en">Returns first n elements from enum.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.take(3) #=&gt; [1, 2, 3]</span></p></li><li id="iesucks-ec" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
prepend(other_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ec</span> <span class="TermText qDef lang-en">Prepend—Prepend the given string to str.<br>
<br>
a = "world"<br>
a.prepend("hello ") #=&gt; "hello world"<br>
a #=&gt; "hello world"</span></p></li><li id="iesucks-wv" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
identical?(file_1, file_2)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wv</span> <span class="TermText qDef lang-en">Returns true if the named files are identical.<br>
<br>
open("a", "w") {}<br>
p File.identical?("a", "a") #=&gt; true<br>
p File.identical?("a", "./a") #=&gt; true<br>
File.link("a", "b")<br>
p File.identical?("a", "b") #=&gt; true<br>
File.symlink("a", "c")<br>
p File.identical?("a", "c") #=&gt; true<br>
open("d", "w") {}<br>
p File.identical?("a", "d") #=&gt; false</span></p></li><li id="iesucks-ir" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
ungetc(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ir</span> <span class="TermText qDef lang-en">Pushes back one character (passed as a parameter) onto ios, such<br>
that a subsequent buffered character read will return it. Only one<br>
character may be pushed back before a subsequent read operation (that is,<br>
you will be able to read only the last of several characters that have been<br>
pushed back). Has no effect with unbuffered reads (such as<br>
IO#sysread).<br>
<br>
f = File.new("testfile") #=&gt; #&lt;File:testfile&gt;<br>
c = f.getc #=&gt; "8"<br>
f.ungetc(c) #=&gt; nil<br>
f.getc #=&gt; "8"</span></p></li><li id="iesucks-ip" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
even?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ip</span> <span class="TermText qDef lang-en">Returns true if fix is an even number.</span></p></li><li id="iesucks-av" class="wrong-q"><b> <span class="TermText qWord lang-math">FILETEST<br>
symlink?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">av</span> <span class="TermText qDef lang-en">Returns true if the named file is a symbolic link.</span></p></li><li id="iesucks-ch" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
ord</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ch</span> <span class="TermText qDef lang-en">Returns the int itself.<br>
<br>
a.ord #=&gt; 97</span></p></li><li id="iesucks-uc" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
polar</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uc</span> <span class="TermText qDef lang-en">Returns an array; [num.abs, num.arg].</span></p></li><li id="iesucks-ar" class="wrong-q"><b> <span class="TermText qWord lang-math">NILCLASS<br>
nil?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ar</span> <span class="TermText qDef lang-en">call_seq:<br>
<br>
nil.nil? -&gt; true</span></p></li><li id="iesucks-ax" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ax</span> <span class="TermText qDef lang-en">Produce a nicely formatted string-version of rxp. Perhaps<br>
surprisingly, #inspect actually produces the more natural<br>
version of the string than #to_s.<br>
<br>
/ab+c/x.inspect #=&gt; "/ab+c/ix"</span></p></li><li id="iesucks-eo" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
instance_of?(class)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">eo</span> <span class="TermText qDef lang-en">Returns true if obj is an instance of the given<br>
class. See also Object#kind_of?.<br>
<br>
class A; end<br>
class B &lt; A; end<br>
class C &lt; B; end<br>
<br>
b = B.new<br>
b.instance_of? A #=&gt; false<br>
b.instance_of? B #=&gt; true<br>
b.instance_of? C #=&gt; false</span></p></li><li id="iesucks-ua" class="wrong-q"><b> <span class="TermText qWord lang-math">BASICOBJECT<br>
instance_exec(arg...) {|var...| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ua</span> <span class="TermText qDef lang-en">Executes the given block within the context of the receiver (obj).<br>
In order to set the context, the variable self is set to<br>
obj while the code is executing, giving the code access to<br>
obj's instance variables. Arguments are passed as block<br>
parameters.<br>
<br>
class KlassWithSecret<br>
 def initialize<br>
 @secret = 99<br>
 end<br>
end<br>
k = KlassWithSecret.new<br>
k.instance_exec(5) {|x| @secret+x } #=&gt; 104</span></p></li><li id="iesucks-wi" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wi</span> <span class="TermText qDef lang-en">Returns a string containing the regular expression and its options (using<br>
the (?opts:source) notation. This string can be fed back in to<br>
Regexp::new to a regular expression with the same semantics as<br>
the original. (However, Regexp#== may not return true when<br>
comparing the two, as the source of the regular expression itself may<br>
differ, as the example shows). Regexp#inspect produces a<br>
generally more readable version of rxp.<br>
<br>
r1 = /ab+c/x #=&gt; /ab+c/ix<br>
s1 = r1.to_s #=&gt; "(?ix-m:ab+c)"<br>
r2 = Regexp.new(s1) #=&gt; /(?ix-m:ab+c)/<br>
r1 == r2 #=&gt; false<br>
r1.source #=&gt; "ab+c"<br>
r2.source #=&gt; "(?ix-m:ab+c)"</span></p></li><li id="iesucks-d" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
respond_to_missing?(symbol, include_all)<br>
respond_to_missing?(string, include_all)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">d</span> <span class="TermText qDef lang-en">DO NOT USE THIS DIRECTLY.</span></p></li><li id="iesucks-vo" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
map! {|item| block }<br>
map!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vo</span> <span class="TermText qDef lang-en">Invokes the given block once for each element of self,<br>
replacing the element with the value returned by the block.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.map! {|x| x + "!" }<br>
a #=&gt; [ "a!", "b!", "c!", "d!" ]</span></p></li><li id="iesucks-br" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
to_a</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">br</span> <span class="TermText qDef lang-en">Converts hsh to a nested array of [ key,<br>
value ] arrays.<br>
<br>
h = { "c" =&gt; 300, "a" =&gt; 100, "d" =&gt; 400, "c" =&gt; 300 }<br>
h.to_a #=&gt; [["c", 300], ["a", 100], ["d", 400]]</span></p></li><li id="iesucks-bd" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
each_value { |value| }<br>
each_value</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bd</span> <span class="TermText qDef lang-en">Yields each environment variable value.</span></p></li><li id="iesucks-sv" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
hash</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sv</span> <span class="TermText qDef lang-en">Compute a hash based on the value of big.</span></p></li><li id="iesucks-om" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
any? [{ |obj| block }]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">om</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block ever returns a value other than<br>
false or nil. If the block is not given, Ruby<br>
adds an implicit block of { |obj| obj } that will cause any? to return true<br>
if at least one of the collection members is not false or<br>
nil.<br>
<br>
%w[ant bear cat].any? { |word| word.length &gt;= 3 } #=&gt; true<br>
%w[ant bear cat].any? { |word| word.length &gt;= 4 } #=&gt; true<br>
[nil, true, 99].any? #=&gt; true</span></p></li><li id="iesucks-cr" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
ary * int<br>
ary * str</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cr</span> <span class="TermText qDef lang-en">Repetition — With a String argument, equivalent<br>
to ary.join(str).<br>
<br>
[ 1, 2, 3 ] * 3 #=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]<br>
[ 1, 2, 3 ] * ^!^ #=&gt; "1,2,3"</span></p></li><li id="iesucks-vx" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
remove_instance_variable(symbol)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vx</span> <span class="TermText qDef lang-en">Removes the named instance variable from obj, returning that<br>
variable's value.<br>
<br>
class Dummy<br>
 attr_reader :var<br>
 def initialize<br>
 @var = 99<br>
 end<br>
 def remove<br>
 remove_instance_variable(:@var)<br>
 end<br>
end<br>
d = Dummy.new<br>
d.var #=&gt; 99<br>
d.remove #=&gt; 99<br>
d.var #=&gt; nil</span></p></li><li id="iesucks-cl" class="wrong-q"><b> <span class="TermText qWord lang-math">EXCEPTION<br>
message</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cl</span> <span class="TermText qDef lang-en">Returns the result of invoking exception.to_s. Normally this<br>
returns the exception's message or name. By supplying a to_str method,<br>
exceptions are agreeing to be used where Strings are expected.</span></p></li><li id="iesucks-ay" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
sample<br>
sample(random: rng)<br>
sample(n)<br>
sample(n, random: rng)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ay</span> <span class="TermText qDef lang-en">Choose a random element or n random elements from the array.<br>
<br>
a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]<br>
a.sample #=&gt; 7<br>
a.sample(4) #=&gt; [6, 4, 2, 5]</span></p></li><li id="iesucks-cq" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
round([ndigits])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cq</span> <span class="TermText qDef lang-en">Rounds sub seconds to a given precision in decimal digits (0 digits by<br>
default). It returns a new Time object.<br>
ndigits should be zero or positive integer.<br>
<br>
require 'time'<br>
<br>
t = Time.utc(2010,3,30, 5,43,"25.123456789".to_r)<br>
p t.iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567890Z"<br>
p t.round.iso8601(10) #=&gt; "2010-03-30T05:43:25.0000000000Z"<br>
p t.round(0).iso8601(10) #=&gt; "2010-03-30T05:43:25.0000000000Z"<br>
p t.round(1).iso8601(10) #=&gt; "2010-03-30T05:43:25.1000000000Z"<br>
p t.round(2).iso8601(10) #=&gt; "2010-03-30T05:43:25.1200000000Z"<br>
p t.round(3).iso8601(10) #=&gt; "2010-03-30T05:43:25.1230000000Z"<br>
p t.round(4).iso8601(10) #=&gt; "2010-03-30T05:43:25.1235000000Z"<br>
p t.round(5).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234600000Z"<br>
p t.round(6).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234570000Z"<br>
p t.round(7).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234568000Z"<br>
p t.round(8).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567900Z"<br>
p t.round(9).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567890Z"<br>
p t.round(10).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567890Z"<br>
<br>
t = Time.utc(1999,12,31, 23,59,59)<br>
p((t + 0.4).round.iso8601(3)) #=&gt; "1999-12-31T23:59:59.000Z"<br>
p((t + 0.49).round.iso8601(3)) #=&gt; "1999-12-31T23:59:59.000Z"<br>
p((t + 0.5).round.iso8601(3)) #=&gt; "2000-01-01T00:00:00.000Z"<br>
p((t + 1.4).round.iso8601(3)) #=&gt; "2000-01-01T00:00:00.000Z"<br>
p((t + 1.49).round.iso8601(3)) #=&gt; "2000-01-01T00:00:00.000Z"<br>
p((t + 1.5).round.iso8601(3)) #=&gt; "2000-01-01T00:00:01.000Z"<br>
<br>
t = Time.utc(1999,12,31, 23,59,59)<br>
p (t + 0.123456789).round(4).iso8601(6) #=&gt; "1999-12-31T23:59:59.123500Z"</span></p></li><li id="iesucks-dy" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
instance_variable_set(symbol, obj)<br>
instance_variable_set(string, obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dy</span> <span class="TermText qDef lang-en">Sets the instance variable names by symbol to object,<br>
thereby frustrating the efforts of the class's author to attempt to provide<br>
proper encapsulation. The variable did not have to exist prior to this<br>
call. If the instance variable name is passed as a string, that string is<br>
converted to a symbol.<br>
<br>
class Fred<br>
 def initialize(p1, p2)<br>
 @a, @b = p1, p2<br>
 end<br>
end<br>
fred = Fred.new('cat', 99)<br>
fred.instance_variable_set(:@a, 'dog') #=&gt; "dog"<br>
fred.instance_variable_set(:@c, 'cat') #=&gt; "cat"<br>
fred.inspect #=&gt; "#&lt;Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\"&gt;"</span></p></li><li id="iesucks-it" class="wrong-q"><b> <span class="TermText qWord lang-math">COMPARABLE<br>
obj == other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">it</span> <span class="TermText qDef lang-en">Compares two objects based on the receiver's &lt;=&gt; method,<br>
returning true if it returns 0. Also returns true if obj and<br>
other are the same object.</span></p></li><li id="iesucks-un" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
repeated_permutation(n) { |p| block }<br>
repeated_permutation(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">un</span> <span class="TermText qDef lang-en">When invoked with a block, yield all repeated permutations of length<br>
n of the elements of the array, then return the array itself.<br>
<br>
a = [1, 2]<br>
a.repeated_permutation(1).to_a #=&gt; [[1], [2]]<br>
a.repeated_permutation(2).to_a #=&gt; [[1,1],[1,2],[2,1],[2,2]]<br>
a.repeated_permutation(3).to_a #=&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],<br>
 # [2,1,1],[2,1,2],[2,2,1],[2,2,2]]<br>
a.repeated_permutation(0).to_a #=&gt; [[]] # one permutation of length 0</span></p></li><li id="iesucks-le" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
pwd</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">le</span> <span class="TermText qDef lang-en">Returns the path to the current working directory of this process as a<br>
string.<br>
<br>
Dir.chdir("/tmp") #=&gt; 0<br>
Dir.getwd #=&gt; "/tmp"</span></p></li><li id="iesucks-t" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">t</span> <span class="TermText qDef lang-en">Equality—Two regexps are equal if their patterns are identical, they have<br>
the same character set code, and their casefold? values are<br>
the same.<br>
<br>
/abc/ == /abc/ #=&gt; false<br>
/abc/ == /abc/ #=&gt; false<br>
/abc/ == /abc/ #=&gt; false<br>
/abc/ == /abc/ #=&gt; false</span></p></li><li id="iesucks-nw" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
bsearch {|obj| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nw</span> <span class="TermText qDef lang-en">By using binary search, finds a value in range which meets the given<br>
condition in O(log n) where n is the size of the array.<br>
<br>
ary = [0, 4, 7, 10, 12]<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 4 } #=&gt; 1<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 6 } #=&gt; 2<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 8 } #=&gt; 3<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 100 } #=&gt; nil<br>
<br>
(0.0...Float::INFINITY).bsearch {|x| Math.log(x) &gt;= 0 } #=&gt; 1.0</span></p></li><li id="iesucks-re" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
insert(index, obj...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">re</span> <span class="TermText qDef lang-en">Inserts the given values before the element with the given<br>
index.<br>
<br>
a = %w{ a b c d }<br>
a.insert(2, 99) #=&gt; ["a", "b", 99, "c", "d"]<br>
a.insert(-2, 1, 2, 3) #=&gt; ["a", "b", 99, "c", 1, 2, 3, "d"]</span></p></li><li id="iesucks-pa" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
lstat</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pa</span> <span class="TermText qDef lang-en">Same as IO#stat, but does not follow the last symbolic link.<br>
Instead, reports on the link itself.<br>
<br>
File.symlink("testfile", "link2test") #=&gt; 0<br>
File.stat("testfile").size #=&gt; 66<br>
f = File.new("link2test")<br>
f.lstat.size #=&gt; 8<br>
f.stat.size #=&gt; 66</span></p></li><li id="iesucks-ra" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
last_match<br>
last_match(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ra</span> <span class="TermText qDef lang-en">The first form returns the MatchData object<br>
generated by the last successful pattern match. Equivalent to reading the<br>
special global variable $~ (see Special global variables in Regexp for details).<br>
<br>
/c(.)t/ =~ 'cat' #=&gt; 0<br>
Regexp.last_match #=&gt; #&lt;MatchData "cat" 1:"a"&gt;<br>
Regexp.last_match(0) #=&gt; "cat"<br>
Regexp.last_match(1) #=&gt; "a"<br>
Regexp.last_match(2) #=&gt; nil<br>
<br>
/(?&lt;lhs&gt;\w+)\s<b>=\s</b>(?&lt;rhs&gt;\w+)/ =~ "var = val"<br>
Regexp.last_match #=&gt; #&lt;MatchData "var = val" lhs:"var" rhs:"val"&gt;<br>
Regexp.last_match(:lhs) #=&gt; "var"<br>
Regexp.last_match(:rhs) #=&gt; "val"</span></p></li><li id="iesucks-ks" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
fdatasync</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ks</span> <span class="TermText qDef lang-en">Immediately writes all buffered data in ios to disk.</span></p></li><li id="iesucks-me" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">me</span> <span class="TermText qDef lang-en">Comparison—Returns -1, 0, or +1 depending on whether big is<br>
less than, equal to, or greater than numeric. This is the<br>
basis for the tests in Comparable.</span></p></li><li id="iesucks-up" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
ary + other_ary</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">up</span> <span class="TermText qDef lang-en">Concatenation — Returns a new array built by concatenating the two arrays<br>
together to produce a third array.<br>
<br>
[ 1, 2, 3 ] + [ 4, 5 ] #=&gt; [ 1, 2, 3, 4, 5 ]<br>
a = [ "a", "b", "c" ]<br>
a + [ "d", "e", "f" ]<br>
a #=&gt; [ "a", "b", "c", "d", "e", "f" ]</span></p></li><li id="iesucks-vm" class="wrong-q"><b> <span class="TermText qWord lang-math">ENCODING<br>
replicate(name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vm</span> <span class="TermText qDef lang-en">Returns a replicated encoding of enc whose name is name.<br>
The new encoding should have the same byte structure of enc. If<br>
name is used by another encoding, raise ArgumentError.</span></p></li><li id="iesucks-ap" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
slice(idx)<br>
slice(b, n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ap</span> <span class="TermText qDef lang-en">Returns sym.to_s[].</span></p></li><li id="iesucks-gl" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
mod &gt; other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gl</span> <span class="TermText qDef lang-en">Returns true if mod is an ancestor of other. Returns<br>
nil if there's no relationship between the two. (Think of the<br>
relationship in terms of the class definition: "class A&lt;B" implies<br>
"B&gt;A").</span></p></li><li id="iesucks-pu" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big[n]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pu</span> <span class="TermText qDef lang-en">Bit Reference—Returns the nth bit in the (assumed) binary<br>
representation of big, where big<br>
is the least significant bit.<br>
<br>
a = 9**15<br>
50.downto(0) do |n|<br>
 print a[n]<br>
end</span></p></li><li id="iesucks-da" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
chmod(mode_int, file_name, ... )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">da</span> <span class="TermText qDef lang-en">Changes permission bits on the named file(s) to the bit pattern represented<br>
by mode_int. Actual effects are operating system dependent (see<br>
the beginning of this section). On Unix systems, see chmod(2)<br>
for details. Returns the number of files processed.<br>
<br>
File.chmod(0644, "testfile", "out") #=&gt; 2</span></p></li><li id="iesucks-vg" class="wrong-q"><b> <span class="TermText qWord lang-math">NILCLASS<br>
to_h</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vg</span> <span class="TermText qDef lang-en">Always returns an empty hash.<br>
<br>
nil.to_h #=&gt; {}</span></p></li><li id="iesucks-sf" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
initialize_copy",<br>
"HASH<br>
to_s<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sf</span> <span class="TermText qDef lang-en">Return the contents of this hash as a string.<br>
<br>
h = { "c" =&gt; 300, "a" =&gt; 100, "d" =&gt; 400, "c" =&gt; 300 }<br>
h.to_s #=&gt; "{\"c\"=&gt;300, \"a\"=&gt;100, \"d\"=&gt;400}"</span></p></li><li id="iesucks-dv" class="wrong-q"><b> <span class="TermText qWord lang-math">MATCHDATA<br>
string</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dv</span> <span class="TermText qDef lang-en">Returns a frozen copy of the string passed in to match.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.string #=&gt; "THX1138."</span></p></li><li id="iesucks-sg" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
time + numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sg</span> <span class="TermText qDef lang-en">Addition — Adds some number of seconds (possibly fractional) to<br>
time and returns that value as a new Time<br>
object.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:22:21 -0600<br>
t + (60 <b> 60 </b> 24) #=&gt; 2007-11-20 08:22:21 -0600</span></p></li><li id="iesucks-ig" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
flt &gt; real</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ig</span> <span class="TermText qDef lang-en">true if flt is greater than real.<br>
The result of NaN &gt; NaN is undefined, so the<br>
implementation-dependent value is returned.</span></p></li><li id="iesucks-xb" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
float + other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">xb</span> <span class="TermText qDef lang-en">Returns a new float which is the sum of float and<br>
other.</span></p></li><li id="iesucks-mf" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
world_writable?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mf</span> <span class="TermText qDef lang-en">If file_name is writable by others, returns an integer<br>
representing the file permission bits of file_name. Returns<br>
nil otherwise. The meaning of the bits is platform dependent;<br>
on Unix systems, see stat(2).<br>
<br>
File.world_writable?("/tmp") #=&gt; 511<br>
m = File.world_writable?("/tmp")<br>
sprintf("%o", m) #=&gt; "777"</span></p></li><li id="iesucks-np" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
const_missing(sym)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">np</span> <span class="TermText qDef lang-en">Invoked when a reference is made to an undefined constant in mod.<br>
It is passed a symbol for the undefined constant, and returns a value to be<br>
used for that constant. The following code is an example of the same:<br>
<br>
def Foo.const_missing(name)<br>
 name # return the constant name as Symbol<br>
end<br>
<br>
Foo::UNDEFINED_CONST #=&gt; :UNDEFINED_CONST: symbol returned</span></p></li><li id="iesucks-fg" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
unshift(obj, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fg</span> <span class="TermText qDef lang-en">Prepends objects to the front of self, moving other elements<br>
upwards. See also #shift for the<br>
opposite effect.<br>
<br>
a = [ "b", "c", "d" ]<br>
a.unshift("a") #=&gt; ["a", "b", "c", "d"]<br>
a.unshift(1, 2) #=&gt; [ 1, 2, "a", "b", "c", "d"]</span></p></li><li id="iesucks-wj" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
Integer(arg,base=0)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wj</span> <span class="TermText qDef lang-en">Converts arg to a Fixnum or Bignum. Numeric types are converted directly (with floating<br>
point numbers being truncated). base (0, or between 2 and 36)<br>
is a base for integer string representation. If arg is a<br>
String, when base is omitted or equals to zero, radix<br>
indicators (0, 0b, and 0x) are<br>
honored. In any case, strings should be strictly conformed to numeric<br>
representation. This behavior is different from that of<br>
String#to_i. Non string values will be converted using<br>
to_int, and to_i.<br>
<br>
Integer(123.999) #=&gt; 123<br>
Integer("0x1a") #=&gt; 26<br>
Integer(Time.new) #=&gt; 1204973019<br>
Integer("0930", 10) #=&gt; 930<br>
Integer("111", 2) #=&gt; 7</span></p></li><li id="iesucks-h" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
reverse_each { |item| block }<br>
reverse_each</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">h</span> <span class="TermText qDef lang-en">Same as #each, but traverses<br>
self in reverse order.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.reverse_each {|x| print x, " " }</span></p></li><li id="iesucks-ww" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
module other_module</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ww</span> <span class="TermText qDef lang-en">Comparison—Returns -1, 0, +1 or nil depending on whether<br>
module includes other_module, they are the same,<br>
or if module is included by other_module. This is<br>
the basis for the tests in Comparable.</span></p></li><li id="iesucks-qc" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
b</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qc</span> <span class="TermText qDef lang-en">Returns a copied string whose encoding is ASCII-8BIT.</span></p></li><li id="iesucks-dw" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
ctime</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dw</span> <span class="TermText qDef lang-en">Returns a canonical string representation of time.<br>
<br>
Time.now.asctime #=&gt; "Wed Apr 9 08:56:03 2003"</span></p></li><li id="iesucks-ac" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
concat(other_ary)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ac</span> <span class="TermText qDef lang-en">Appends the elements of other_ary to self.<br>
<br>
[ "a", "b" ].concat( ["c", "d"] ) #=&gt; [ "a", "b", "c", "d" ]<br>
a = [ 1, 2, 3 ]<br>
a.concat( [ 4, 5 ] )<br>
a #=&gt; [ 1, 2, 3, 4, 5 ]</span></p></li><li id="iesucks-ri" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
push(obj, ... )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ri</span> <span class="TermText qDef lang-en">Append — Pushes the given object(s) on to the end of this array. This<br>
expression returns the array itself, so several appends may be chained<br>
together. See also #pop for the<br>
opposite effect.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.push("d", "e", "f")<br>
 #=&gt; ["a", "b", "c", "d", "e", "f"]<br>
[1, 2, 3,].push(4).push(5)<br>
 #=&gt; [1, 2, 3, 4, 5]</span></p></li><li id="iesucks-sn" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
include?(object)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sn</span> <span class="TermText qDef lang-en">Returns true if the given object is present in<br>
self (that is, if any element ==<br>
object), otherwise returns false.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.include?("b") #=&gt; true<br>
a.include?("z") #=&gt; false</span></p></li><li id="iesucks-ms" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
bytes</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ms</span> <span class="TermText qDef lang-en">Returns an array of bytes in str. This is a shorthand for<br>
str.each_byte.to_a.</span></p></li><li id="iesucks-sp" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
~fix</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sp</span> <span class="TermText qDef lang-en">One's complement: returns a number where each bit is flipped.</span></p></li><li id="iesucks-vz" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
unpack(format)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vz</span> <span class="TermText qDef lang-en">Decodes str (which may contain binary data) according to the<br>
format string, returning an array of each value extracted. The format<br>
string consists of a sequence of single-character directives, summarized in<br>
the table at the end of this entry. Each directive may be followed by a<br>
number, indicating the number of times to repeat with this directive. An<br>
asterisk ("*") will use up all remaining elements. The<br>
directives sSiIlL may each be followed by an underscore<br>
("_") or exclamation mark ("!") to use the<br>
underlying platform's native size for the specified type; otherwise, it<br>
uses a platform-independent consistent size. Spaces are ignored in the<br>
format string. See also Array#pack.<br>
<br>
"abc \00\\00aabc \00\\00"".unpack('A6Z6') #=&gt; ["abc", "abc "]<br>
"abc \00\\00"".unpack('a3a3') #=&gt; ["abc", " \000\000"]<br>
"abc \00aabc \00"".unpack('Z<b>Z</b>') #=&gt; ["abc ", "abc "]<br>
"aa".unpack('b8B8') #=&gt; ["10000110", "01100001"]<br>
"aaa".unpack('h2H2c') #=&gt; ["16", "61", 97]<br>
"\xfe\xff\xfe\xff".unpack('sS') #=&gt; [-2, 65534]<br>
"now=20is".unpack('M*') #=&gt; ["now is"]<br>
"whole".unpack('xax2aX2aX1aX2a') #=&gt; ["h", "e", "l", "l", "o"]</span></p></li><li id="iesucks-fe" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
tv_nsec</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fe</span> <span class="TermText qDef lang-en">Returns the number of nanoseconds for time.<br>
<br>
t = Time.now #=&gt; 2007-11-17 15:18:03 +0900<br>
"%10.9f" % t.to_f #=&gt; "1195280283.536151409"<br>
t.nsec #=&gt; 536151406</span></p></li><li id="iesucks-a" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
caller(start=1, length=nil)<br>
caller(range)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">a</span> <span class="TermText qDef lang-en">Returns the current execution stack—an array containing strings in the form<br>
file:line or file:line: in `method'.<br>
<br>
def a(skip)<br>
 caller(skip)<br>
end<br>
def b(skip)<br>
 a(skip)<br>
end<br>
def c(skip)<br>
 b(skip)<br>
end<br>
c(0) #=&gt; ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `&lt;main&gt;'"]<br>
c(1) #=&gt; ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `&lt;main&gt;'"]<br>
c(2) #=&gt; ["prog:8:in `c'", "prog:12:in `&lt;main&gt;'"]<br>
c(3) #=&gt; ["prog:13:in `&lt;main&gt;'"]<br>
c(4) #=&gt; []<br>
c(5) #=&gt; nil</span></p></li><li id="iesucks-jo" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
store(name, value)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jo</span> <span class="TermText qDef lang-en">Sets the environment variable name to value. If<br>
the value given is nil the environment variable is deleted.</span></p></li><li id="iesucks-dg" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
chr([encoding])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dg</span> <span class="TermText qDef lang-en">Returns a string containing the character represented by the receiver's<br>
value according to encoding.<br>
<br>
65.chr #=&gt; "A"<br>
230.chr #=&gt; "\346"<br>
255.chr(Encoding::UTF_8) #=&gt; "\303\277"</span></p></li><li id="iesucks-w" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
compare_by_identity?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">w</span> <span class="TermText qDef lang-en">Returns true if hsh will compare its keys by their<br>
identity. Also see Hash#compare_by_identity.</span></p></li><li id="iesucks-tp" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
find_all { |obj| block }<br>
find_all</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tp</span> <span class="TermText qDef lang-en">Returns an array containing all elements of enum for which the<br>
given block returns a true value.<br>
<br>
(1..10).find_all { |i| i % 3 == 0 } #=&gt; [3, 6, 9]<br>
<br>
[1,2,3,4,5].select { |num| num.even? } #=&gt; [2, 4]</span></p></li><li id="iesucks-rd" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
float real</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rd</span> <span class="TermText qDef lang-en">Returns -1, 0, +1 or nil depending on whether float is less<br>
than, equal to, or greater than real. This is the basis for<br>
the tests in Comparable.</span></p></li><li id="iesucks-us" class="wrong-q"><b> <span class="TermText qWord lang-math">STRUCT<br>
select {|i| block }<br>
select</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">us</span> <span class="TermText qDef lang-en">Invokes the block passing in successive elements from struct,<br>
returning an array containing those elements for which the block returns a<br>
true value (equivalent to Enumerable#select).<br>
<br>
Lots = Struct.new(:a, :b, :c, :d, :e, :f)<br>
l = Lots.new(11, 22, 33, 44, 55, 66)<br>
l.select {|v| (v % 2).zero? } #=&gt; [22, 44, 66]</span></p></li><li id="iesucks-am" class="wrong-q"><b> <span class="TermText qWord lang-math">BASICOBJECT<br>
new</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">am</span> <span class="TermText qDef lang-en">Not documented</span></p></li><li id="iesucks-dm" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
writable?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dm</span> <span class="TermText qDef lang-en">Returns true if stat is writable by the effective<br>
user id of this process.<br>
<br>
File.stat("testfile").writable? #=&gt; true</span></p></li><li id="iesucks-lg" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
first<br>
first(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lg</span> <span class="TermText qDef lang-en">Returns the first element, or the first n elements, of the<br>
enumerable. If the enumerable is empty, the first form returns<br>
nil, and the second form returns an empty array.<br>
<br>
%w[foo bar baz].first #=&gt; "foo"<br>
%w[foo bar baz].first(2) #=&gt; ["foo", "bar"]<br>
%w[foo bar baz].first(10) #=&gt; ["foo", "bar", "baz"]<br>
[].first #=&gt; nil</span></p></li><li id="iesucks-tn" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
ungetbyte(string)<br>
ungetbyte(integer)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tn</span> <span class="TermText qDef lang-en">Pushes back bytes (passed as a parameter) onto ios, such that a<br>
subsequent buffered read will return it. Only one byte may be pushed back<br>
before a subsequent read operation (that is, you will be able to read only<br>
the last of several bytes that have been pushed back). Has no effect with<br>
unbuffered reads (such as IO#sysread).<br>
<br>
f = File.new("testfile") #=&gt; #&lt;File:testfile&gt;<br>
b = f.getbyte #=&gt; 0x38<br>
f.ungetbyte(b) #=&gt; nil<br>
f.getbyte #=&gt; 0x38</span></p></li><li id="iesucks-lc" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
pos</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lc</span> <span class="TermText qDef lang-en">Returns the current offset (in bytes) of the current file in<br>
ARGF.<br>
<br>
ARGF.pos #=&gt; 0<br>
ARGF.gets #=&gt; "This is line one\n"<br>
ARGF.pos #=&gt; 17</span></p></li><li id="iesucks-mz" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
singleton_method_added</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mz</span> <span class="TermText qDef lang-en">Trap attempts to add methods to Numeric objects. Always raises<br>
a TypeError</span></p></li><li id="iesucks-ji" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big ** exponent</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ji</span> <span class="TermText qDef lang-en">Raises big to the exponent power (which may be an<br>
integer, float, or anything that will coerce to a number). The result may<br>
be a Fixnum, Bignum, or<br>
Float<br>
<br>
123456789 ** 2 #=&gt; 15241578750190521<br>
123456789 ** 1.2 #=&gt; 5126464716.09932<br>
123456789 ** -2 #=&gt; 6.5610001194102e-17</span></p></li><li id="iesucks-tc" class="wrong-q"><b> <span class="TermText qWord lang-math">BASICOBJECT<br>
obj != other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tc</span> <span class="TermText qDef lang-en">Returns true if two objects are not-equal, otherwise false.</span></p></li><li id="iesucks-gi" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
chdir( [ string] )<br>
chdir( [ string] ) {| path | block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gi</span> <span class="TermText qDef lang-en">Changes the current working directory of the process to the given string.<br>
When called without an argument, changes the directory to the value of the<br>
environment variable HOME, or LOGDIR.<br>
SystemCallError (probably Errno::ENOENT) if the<br>
target directory does not exist.<br>
<br>
Dir.chdir("/var/spool/mail")<br>
puts Dir.pwd<br>
Dir.chdir("/tmp") do<br>
 puts Dir.pwd<br>
 Dir.chdir("/usr") do<br>
 puts Dir.pwd<br>
 end<br>
 puts Dir.pwd<br>
end<br>
puts Dir.pwd</span></p></li><li id="iesucks-fz" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
readline(sep=$/)<br>
readline(limit)<br>
readline(sep, limit)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fz</span> <span class="TermText qDef lang-en">Reads a line as with IO#gets, but raises an<br>
EOFError on end of file.</span></p></li><li id="iesucks-cf" class="wrong-q"><b> <span class="TermText qWord lang-math">METHOD<br>
name</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cf</span> <span class="TermText qDef lang-en">Returns the name of the method.</span></p></li><li id="iesucks-wf" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
symbol other_symbol</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wf</span> <span class="TermText qDef lang-en">Compares symbol with other_symbol after calling<br>
to_s on each of the symbols.<br>
Returns -1, 0, +1 or nil depending on whether symbol is less<br>
than, equal to, or greater than other_symbol.<br>
<br>
+nil+ is returned if the two values are incomparable.</span></p></li><li id="iesucks-id" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
ctime(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">id</span> <span class="TermText qDef lang-en">Returns the change time for the named file (the time at which directory<br>
information about the file was changed, not the file itself).<br>
<br>
File.ctime("testfile") #=&gt; Wed Apr 09 08:53:13 CDT 2003</span></p></li><li id="iesucks-ff" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
shift</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ff</span> <span class="TermText qDef lang-en">Removes an environment variable name-value pair from ENV and returns it as an Array. Returns nil if when the<br>
environment is empty.</span></p></li><li id="iesucks-hh" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hh</span> <span class="TermText qDef lang-en">Replaces the contents and taintedness of str with the<br>
corresponding values in other_str.<br>
<br>
s = "hello" #=&gt; "hello"<br>
s.replace "world" #=&gt; "world"</span></p></li><li id="iesucks-gd" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gd</span> <span class="TermText qDef lang-en">Returns the representation of sym as a symbol literal.<br>
<br>
:fred.inspect #=&gt; ":fred"</span></p></li><li id="iesucks-bs" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
include?(obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bs</span> <span class="TermText qDef lang-en">Returns true if any member of enum equals<br>
obj. Equality is tested using ==.<br>
<br>
IO.constants.include? :SEEK_SET #=&gt; true<br>
IO.constants.include? :SEEK_NO_FURTHER #=&gt; false</span></p></li><li id="iesucks-gt" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
oct</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gt</span> <span class="TermText qDef lang-en">Treats leading characters of str as a string of octal digits (with<br>
an optional sign) and returns the corresponding number. Returns 0 if the<br>
conversion fails.<br>
<br>
"123".oct #=&gt; 83<br>
"-377".oct #=&gt; -255<br>
"bad".oct #=&gt; 0<br>
"0377bad".oct #=&gt; 255</span></p></li><li id="iesucks-vv" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
chown(owner_int, group_int )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vv</span> <span class="TermText qDef lang-en">Changes the owner and group of file to the given numeric owner and<br>
group id's. Only a process with superuser privileges may change the owner<br>
of a file. The current owner of a file may change the file's group to any<br>
group to which the owner belongs. A nil or -1 owner or group<br>
id is ignored. Follows symbolic links. See also File#lchown.<br>
<br>
File.new("testfile").chown(502, 1000)</span></p></li><li id="iesucks-ur" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
ENV[name]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ur</span> <span class="TermText qDef lang-en">Retrieves the value for environment variable name<br>
as a String. Returns nil if the<br>
named variable does not exist.</span></p></li><li id="iesucks-kn" class="wrong-q"><b> <span class="TermText qWord lang-math">COMPARABLE<br>
obj <br>
 <br>
 click to toggle source</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kn</span> <span class="TermText qDef lang-en">Compares two objects based on the receiver's &lt;=&gt; method,<br>
returning true if it returns -1.</span></p></li><li id="iesucks-io" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
begin</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">io</span> <span class="TermText qDef lang-en">Returns the object that defines the beginning of the range.<br>
<br>
(1..10).begin #=&gt; 1</span></p></li><li id="iesucks-vj" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
closed?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vj</span> <span class="TermText qDef lang-en">Returns true if the current file has been closed; false<br>
otherwise. Use ARGF.close to actually close the current file.</span></p></li><li id="iesucks-be" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
inspect",<br>
"FLOAT<br>
magnitude</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">be</span> <span class="TermText qDef lang-en">Returns the absolute value of flt.<br>
<br>
(-34.56).abs #=&gt; 34.56<br>
-34.56.abs #=&gt; 34.56</span></p></li><li id="iesucks-xe" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
prepended( othermod )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">xe</span> <span class="TermText qDef lang-en">The equivalent of included, but for prepended modules.<br>
<br>
module A<br>
 def self.prepended(mod)<br>
 puts "#{self} prepended to #{mod}"<br>
 end<br>
end<br>
module Enumerable<br>
 prepend A<br>
end<br>
 # =&gt; prints "A prepended to Enumerable"</span></p></li><li id="iesucks-ik" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
ino</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ik</span> <span class="TermText qDef lang-en">Returns the inode number for stat.<br>
<br>
File.stat("testfile").ino #=&gt; 1083669</span></p></li><li id="iesucks-op" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
+num</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">op</span> <span class="TermText qDef lang-en">Unary Plus—Returns the receiver's value.</span></p></li><li id="iesucks-lk" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
codepoints</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lk</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_codepoint.</span></p></li><li id="iesucks-aq" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
blksize</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">aq</span> <span class="TermText qDef lang-en">Returns the native file system's block size. Will return nil<br>
on platforms that don't support this information.<br>
<br>
File.stat("testfile").blksize #=&gt; 4096</span></p></li><li id="iesucks-gs" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
filename</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gs</span> <span class="TermText qDef lang-en">Returns the current filename. "-" is returned when the current file is<br>
STDIN.<br>
<br>
$ echo "foo" &gt; foo<br>
$ echo "bar" &gt; bar<br>
$ echo "glark" &gt; glark<br>
<br>
$ ruby argf.rb foo bar glark<br>
<br>
ARGF.filename #=&gt; "foo"<br>
ARGF.read(5) #=&gt; "foo\nb"<br>
ARGF.filename #=&gt; "bar"<br>
ARGF.skip<br>
ARGF.filename #=&gt; "glark"</span></p></li><li id="iesucks-iv" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
[]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">iv</span> <span class="TermText qDef lang-en">Returns a new array populated with the given objects.<br>
<br>
Array.[]( 1, 'a', /^A/ ) # =&gt; [1, "a", /^A/]<br>
Array[ 1, 'a', /^A/ ] # =&gt; [1, "a", /^A/]<br>
[ 1, 'a', /^A/ ] # =&gt; [1, "a", /^A/]</span></p></li><li id="iesucks-ce" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ce</span> <span class="TermText qDef lang-en">Returns fix modulo other. See<br>
numeric.divmod for more information.</span></p></li><li id="iesucks-is" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
ljust(integer, padstr=' ')</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">is</span> <span class="TermText qDef lang-en">If integer is greater than the length of str, returns a<br>
new String of length integer with str left<br>
justified and padded with padstr; otherwise, returns str.<br>
<br>
"hello".ljust(4) #=&gt; "hello"<br>
"hello".ljust(20) #=&gt; "hello "<br>
"hello".ljust(20, '1234') #=&gt; "hello123412341234123"</span></p></li><li id="iesucks-wd" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
eof<br>
eof?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wd</span> <span class="TermText qDef lang-en">Returns true if ios is at end of file that means there are no more<br>
data to read. The stream must be opened for reading or an<br>
IOError will be raised.<br>
<br>
f = File.new("testfile")<br>
dummy = f.readlines<br>
f.eof #=&gt; true</span></p></li><li id="iesucks-kf" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
const_get(sym, inherit=true)<br>
const_get(str, inherit=true)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kf</span> <span class="TermText qDef lang-en">Checks for a constant with the given name in mod If<br>
inherit is set, the lookup will also search the ancestors (and<br>
Object if mod is a Module.)<br>
<br>
Math.const_get(:PI) #=&gt; 3.14159265358979</span></p></li><li id="iesucks-ns" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
iterator?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ns</span> <span class="TermText qDef lang-en">Returns true if yield would execute a block in<br>
the current context. The iterator? form is mildly deprecated.<br>
<br>
def try<br>
 if block_given?<br>
 yield<br>
 else<br>
 "no block"<br>
 end<br>
end<br>
try #=&gt; "no block"<br>
try { "hello" } #=&gt; "hello"<br>
try do "hello" end #=&gt; "hello"</span></p></li><li id="iesucks-fo" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
public_method(sym)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fo</span> <span class="TermText qDef lang-en">Similar to method, searches public method only.</span></p></li><li id="iesucks-cu" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
fileno<br>
to_i</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cu</span> <span class="TermText qDef lang-en">Returns an integer representing the numeric file descriptor for<br>
ios.<br>
<br>
$stdin.fileno #=&gt; 0<br>
$stdout.fileno #=&gt; 1</span></p></li><li id="iesucks-db" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
pop<br>
pop(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">db</span> <span class="TermText qDef lang-en">Removes the last element from self and returns it, or<br>
nil if the array is empty.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.pop #=&gt; "d"<br>
a.pop(2) #=&gt; ["b", "c"]<br>
a #=&gt; ["a"]</span></p></li><li id="iesucks-sr" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
executable?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sr</span> <span class="TermText qDef lang-en">Returns true if stat is executable or if the<br>
operating system doesn't distinguish executable files from nonexecutable<br>
files. The tests are made using the effective owner of the process.<br>
<br>
File.stat("testfile").executable? #=&gt; false</span></p></li><li id="iesucks-iz" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
to_c</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">iz</span> <span class="TermText qDef lang-en">Returns a complex which denotes the string form. The parser ignores<br>
leading whitespaces and trailing garbage. Any digit sequences can be<br>
separated by an underscore. Returns zero for null or garbage string.<br>
<br>
'9'.to_c #=&gt; (9+0i)<br>
'2.5'.to_c #=&gt; (2.5+0i)<br>
'2.5/1'.to_c #=&gt; ((5/2)+0i)<br>
'-3/2'.to_c #=&gt; ((-3/2)+0i)<br>
'-i'.to_c #=&gt; (0-1i)<br>
'45i'.to_c #=&gt; (0+45i)<br>
'3-4i'.to_c #=&gt; (3-4i)<br>
'-4e2-4e-2i'.to_c #=&gt; (-400.0-0.04i)<br>
'-0.0-0.0i'.to_c #=&gt; (-0.0-0.0i)<br>
'1/2+3/4i'.to_c #=&gt; ((1/2)+(3/4)*i)<br>
'ruby'.to_c #=&gt; (0+0i)</span></p></li><li id="iesucks-ic" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
reduce(initial, sym)<br>
reduce(sym)<br>
reduce(initial) { |memo, obj| block }<br>
reduce { |memo, obj| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ic</span> <span class="TermText qDef lang-en">Combines all elements of enum by applying a binary operation,<br>
specified by a block or a symbol that names a method or operator.<br>
<br>
# Sum some numbers<br>
(5..10).reduce(:+) #=&gt; 45<br>
# Same using a block and inject<br>
(5..10).inject { |sum, n| sum + n } #=&gt; 45<br>
# Multiply some numbers<br>
(5..10).reduce(1, :*) #=&gt; 151200<br>
# Same using a block<br>
(5..10).inject(1) { |product, n| product * n } #=&gt; 151200<br>
# find the longest word<br>
longest = %w{ cat sheep bear }.inject do |memo, word|<br>
 memo.length &gt; word.length ? memo : word<br>
end<br>
longest #=&gt; "sheep"</span></p></li><li id="iesucks-wq" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
grep(pattern)<br>
grep(pattern) { |obj| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wq</span> <span class="TermText qDef lang-en">Returns an array of every element in enum for which Pattern<br>
=== element. If the optional block is supplied, each<br>
matching element is passed to it, and the block's result is stored in the<br>
output array.<br>
<br>
(1..100).grep 38..44 #=&gt; [38, 39, 40, 41, 42, 43, 44]<br>
c = IO.constants<br>
c.grep(/SEEK/) #=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]<br>
res = c.grep(/SEEK/) { |v| IO.const_get(v) }<br>
res #=&gt; [0, 1, 2]</span></p></li><li id="iesucks-nq" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
downto(limit) {|i| block }<br>
downto(limit)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nq</span> <span class="TermText qDef lang-en">Iterates block, passing decreasing values from int down<br>
to and including limit.<br>
<br>
5.downto(1) { |n| print n, ".. " }<br>
print " Liftoff!\n"</span></p></li><li id="iesucks-ql" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
rand(max=0)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ql</span> <span class="TermText qDef lang-en">If called without an argument, or if max.to_i.abs == 0, rand<br>
returns a pseudo-random floating point number between 0.0 and 1.0,<br>
including 0.0 and excluding 1.0.<br>
<br>
rand #=&gt; 0.2725926052826416</span></p></li><li id="iesucks-sk" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
method_defined?(symbol)<br>
method_defined?(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sk</span> <span class="TermText qDef lang-en">Returns true if the named method is defined by mod<br>
(or its included modules and, if mod is a class, its ancestors).<br>
Public and protected methods are matched. String<br>
arguments are converted to symbols.<br>
<br>
module A<br>
 def method1() end<br>
end<br>
class B<br>
 def method2() end<br>
end<br>
class C &lt; B<br>
 include A<br>
 def method3() end<br>
end<br>
<br>
A.method_defined? :method1 #=&gt; true<br>
C.method_defined? "method1" #=&gt; true<br>
C.method_defined? "method2" #=&gt; true<br>
C.method_defined? "method3" #=&gt; true<br>
C.method_defined? "method4" #=&gt; false</span></p></li><li id="iesucks-hw" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
lchown(owner_int, group_int, file_name,..)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hw</span> <span class="TermText qDef lang-en">Equivalent to File::chown, but does not follow symbolic links<br>
(so it will change the owner associated with the link, not the file<br>
referenced by the link). Often not available. Returns number of files in<br>
the argument list.</span></p></li><li id="iesucks-fv" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fv</span> <span class="TermText qDef lang-en">Return the modulo after division of float by<br>
other.<br>
<br>
6543.21.modulo(137) #=&gt; 104.21<br>
6543.21.modulo(137.24) #=&gt; 92.9299999999996</span></p></li><li id="iesucks-qy" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big ^ numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qy</span> <span class="TermText qDef lang-en">Performs bitwise +exclusive or+ between big and numeric.</span></p></li><li id="iesucks-af" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
step(n=1) {| obj | block }<br>
step(n=1)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">af</span> <span class="TermText qDef lang-en">Iterates over the range, passing each nth element to the<br>
block. If begin and end are numeric, n is added for each<br>
iteration. Otherwise step invokes succ to iterate<br>
through range elements.<br>
<br>
range = Xs.new(1)..Xs.new(10)<br>
range.step(2) {|x| puts x}<br>
puts<br>
range.step(3) {|x| puts x}</span></p></li><li id="iesucks-mt" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
sunday?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mt</span> <span class="TermText qDef lang-en">Returns true if time represents Sunday.<br>
<br>
t = Time.local(1990, 4, 1) #=&gt; 1990-04-01 00:00:00 -0600<br>
t.sunday? #=&gt; true</span></p></li><li id="iesucks-rq" class="wrong-q"><b> <span class="TermText qWord lang-math">METHOD<br>
original_name</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rq</span> <span class="TermText qDef lang-en">Returns the original name of the method.</span></p></li><li id="iesucks-tx" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
public_instance_method(symbol)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tx</span> <span class="TermText qDef lang-en">Similar to instance_method, searches public method only.</span></p></li><li id="iesucks-ml" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
class_variable_get(symbol)<br>
class_variable_get(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ml</span> <span class="TermText qDef lang-en">Returns the value of the given class variable (or throws a<br>
NameError exception). The @@ part of the variable<br>
name should be included for regular class variables String arguments are converted to symbols.<br>
<br>
class Fred<br>
 @@foo = 99<br>
end<br>
Fred.class_variable_get(:@@foo) #=&gt; 99</span></p></li><li id="iesucks-jw" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
delete(obj)<br>
delete(obj) { block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jw</span> <span class="TermText qDef lang-en">Deletes all items from self that are equal to<br>
obj.<br>
<br>
a = [ "a", "b", "b", "b", "c" ]<br>
a.delete("b") #=&gt; "b"<br>
a #=&gt; ["a", "c"]<br>
a.delete("z") #=&gt; nil<br>
a.delete("z") { "not found" } #=&gt; "not found"</span></p></li><li id="iesucks-rh" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
private_class_method(symbol, ...)<br>
private_class_method(string, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rh</span> <span class="TermText qDef lang-en">Makes existing class methods private. Often used to hide the default<br>
constructor new.<br>
<br>
class SimpleSingleton # Not thread safe<br>
 private_class_method :new<br>
 def SimpleSingleton.create(*args, &amp;block)<br>
 @me = new(*args, &amp;block) if ! @me<br>
 @me<br>
 end<br>
end</span></p></li><li id="iesucks-ho" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
floor</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ho</span> <span class="TermText qDef lang-en">Returns the largest integer less than or equal to num.<br>
Numeric implements this by converting anInteger to a<br>
Float and invoking Float#floor.<br>
<br>
1.floor #=&gt; 1<br>
(-1).floor #=&gt; -1</span></p></li><li id="iesucks-mh" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
autoload(module, filename)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mh</span> <span class="TermText qDef lang-en">Registers filename to be loaded (using<br>
Kernel::require) the first time that module (which<br>
may be a String or a symbol) is accessed.<br>
<br>
autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")</span></p></li><li id="iesucks-ut" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
realpath(pathname [, dir_string])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ut</span> <span class="TermText qDef lang-en">Returns the real (absolute) pathname of pathname in the actual<br>
filesystem not containing symlinks or useless dots.</span></p></li><li id="iesucks-wr" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
size</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wr</span> <span class="TermText qDef lang-en">Returns the size of file in bytes.<br>
<br>
File.new("testfile").size #=&gt; 66</span></p></li><li id="iesucks-md" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
foreach(name, sep=$/ [, open_args]) {|line| block }<br>
foreach(name, limit [, open_args]) {|line| block }<br>
foreach(name, sep, limit [, open_args]) {|line| block }<br>
foreach(...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">md</span> <span class="TermText qDef lang-en">Executes the block for every line in the named I/O port, where lines are<br>
separated by sep.<br>
<br>
IO.foreach("testfile") {|x| print "GOT ", x }</span></p></li><li id="iesucks-ak" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
each_line(sep=$/) {|line| block }<br>
each_line(limit) {|line| block }<br>
each_line(sep,limit) {|line| block }<br>
each_line(...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ak</span> <span class="TermText qDef lang-en">Executes the block for every line in ios, where lines are<br>
separated by sep. ios must be opened for reading or an<br>
IOError will be raised.<br>
<br>
f = File.new("testfile")<br>
f.each {|line| puts "#{f.lineno}: #{line}" }</span></p></li><li id="iesucks-dk" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
nonzero?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dk</span> <span class="TermText qDef lang-en">Returns self if num is not zero, nil<br>
otherwise. This behavior is useful when chaining comparisons:<br>
<br>
a = %w( z Bb bB bb BB a aA Aa AA A )<br>
b = a.sort {|a,b| (a.downcase &lt;=&gt; b.downcase).nonzero? || a &lt;=&gt; b }<br>
b #=&gt; ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]</span></p></li><li id="iesucks-sj" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
scrub!<br>
scrub!(repl)<br>
scrub!{|bytes|}</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sj</span> <span class="TermText qDef lang-en">If the string is invalid byte sequence then replace invalid bytes with<br>
given replacement character, else returns self. If block is given, replace<br>
invalid bytes with returned value of the block.<br>
<br>
"abc\u3042\x81".scrub! #=&gt; "abc\u3042\uFFFD"<br>
"abc\u3042\x81".scrub!("<b>") #=&gt; "abc\u3042</b>"<br>
"abc\u3042\xE3\x80".scrub!{|bytes| '&lt;'+bytes.unpack('H*')[0]+'&gt;' } #=&gt; "abc\u3042&lt;e380&gt;"</span></p></li><li id="iesucks-bj" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
byteslice(fixnum)<br>
byteslice(fixnum, fixnum)<br>
byteslice(range)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bj</span> <span class="TermText qDef lang-en">Byte Reference—If passed a single Fixnum, returns a substring<br>
of one byte at that position. If passed two Fixnum objects,<br>
returns a substring starting at the offset given by the first, and a length<br>
given by the second. If given a Range, a substring containing<br>
bytes at offsets given by the range is returned. In all three cases, if an<br>
offset is negative, it is counted from the end of str. Returns<br>
nil if the initial offset falls outside the string, the length<br>
is negative, or the beginning of the range is greater than the end. The<br>
encoding of the resulted string keeps original encoding.<br>
<br>
"hello".byteslice(1) #=&gt; "e"<br>
"hello".byteslice(-1) #=&gt; "o"<br>
"hello".byteslice(1, 2) #=&gt; "el"<br>
"\x80\u3042".byteslice(1, 3) #=&gt; "\u3042"<br>
"\x03\u3042\xff".byteslice(1..3) #=&gt; "\u3042"</span></p></li><li id="iesucks-hf" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
binmode?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hf</span> <span class="TermText qDef lang-en">Returns true if ios is binmode.</span></p></li><li id="iesucks-hp" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
mod === obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hp</span> <span class="TermText qDef lang-en">Case Equality—Returns true if anObject is an instance<br>
of mod or one of mod's descendants. Of limited use for<br>
modules, but can be used in case statements to classify<br>
objects by class.</span></p></li><li id="iesucks-ph" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
str + other_str</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ph</span> <span class="TermText qDef lang-en">Concatenation—Returns a new String containing<br>
other_str concatenated to str.<br>
<br>
"Hello from " + self.to_s #=&gt; "Hello from main"</span></p></li><li id="iesucks-fq" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
ary <br>
 <br>
 click to toggle source</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fq</span> <span class="TermText qDef lang-en">Append—Pushes the given object on to the end of this array. This expression<br>
returns the array itself, so several appends may be chained together.<br>
<br>
[ 1, 2 ] &lt;&lt; "c" &lt;&lt; "d" &lt;&lt; [ 3, 4 ]<br>
 #=&gt; [ 1, 2, "c", "d", [ 3, 4 ] ]</span></p></li><li id="iesucks-rm" class="wrong-q"><b> <span class="TermText qWord lang-math">RANDOM<br>
prng1 == prng2</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rm</span> <span class="TermText qDef lang-en">Returns true if the two generators have the same internal state, otherwise<br>
false. Equivalent generators will return the same sequence of<br>
pseudo-random numbers. Two generators will generally have the same state<br>
only if they were initialized with the same seed<br>
<br>
Random.new == Random.new # =&gt; false<br>
Random.new(1234) == Random.new(1234) # =&gt; true</span></p></li><li id="iesucks-jz" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
slice_before(pattern)<br>
slice_before { |elt| bool }<br>
slice_before(initial_state) { |elt, state| bool }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jz</span> <span class="TermText qDef lang-en">Creates an enumerator for each chunked elements. The beginnings of chunks<br>
are defined by pattern and the block.<br>
<br>
enum.slice_before(pattern).each { |ary| ... }<br>
enum.slice_before { |elt| bool }.each { |ary| ... }<br>
enum.slice_before(initial_state) { |elt, state| bool }.each { |ary| ... }</span></p></li><li id="iesucks-oa" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
tr_s(from_str, to_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oa</span> <span class="TermText qDef lang-en">Processes a copy of str as described under String#tr,<br>
then removes duplicate characters in regions that were affected by the<br>
translation.<br>
<br>
"hello".tr_s('l', 'r') #=&gt; "hero"<br>
"hello".tr_s('el', '<b>') #=&gt; "h</b>o"<br>
"hello".tr_s('el', 'hx') #=&gt; "hhxo"</span></p></li><li id="iesucks-rs" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
hash</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rs</span> <span class="TermText qDef lang-en">Compute a hash-code for this hash. Two hashes with the same content will<br>
have the same hash code (and will compare using eql?).</span></p></li><li id="iesucks-b" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
truncate</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">b</span> <span class="TermText qDef lang-en">Returns num truncated to an integer. Numeric<br>
implements this by converting its value to a float and invoking<br>
Float#truncate.</span></p></li><li id="iesucks-fk" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
getc</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fk</span> <span class="TermText qDef lang-en">Reads a one-character string from ios. Returns nil if<br>
called at end of file.<br>
<br>
f = File.new("testfile")<br>
f.getc #=&gt; "h"<br>
f.getc #=&gt; "e"</span></p></li><li id="iesucks-of" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
include(module, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">of</span> <span class="TermText qDef lang-en">Invokes Module.append_features on each parameter in reverse<br>
order.</span></p></li><li id="iesucks-bt" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
none? [{ |obj| block }]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bt</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block never returns true for<br>
all elements. If the block is not given, none? will return<br>
true only if none of the collection members is true.<br>
<br>
%w{ant bear cat}.none? { |word| word.length == 5 } #=&gt; true<br>
%w{ant bear cat}.none? { |word| word.length &gt;= 4 } #=&gt; false<br>
[].none? #=&gt; true<br>
[nil].none? #=&gt; true<br>
[nil, false].none? #=&gt; true</span></p></li><li id="iesucks-hk" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
to_path</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hk</span> <span class="TermText qDef lang-en">Returns the pathname used to create file as a string. Does not<br>
normalize the name.<br>
<br>
File.new("testfile").path #=&gt; "testfile"<br>
File.new("/tmp/../tmp/xxx", "w").path #=&gt; "/tmp/../tmp/xxx"</span></p></li><li id="iesucks-dj" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
new(begin, end, exclude_end=false)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dj</span> <span class="TermText qDef lang-en">Constructs a range using the given begin and end.<br>
If the exclude_end parameter is omitted or is<br>
false, the rng will include the end object;<br>
otherwise, it will be excluded.</span></p></li><li id="iesucks-bw" class="wrong-q"><b> <span class="TermText qWord lang-math">FALSECLASS<br>
inspect",<br>
"FALSECLASS<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bw</span> <span class="TermText qDef lang-en">'nuf said...</span></p></li><li id="iesucks-bp" class="wrong-q"><b> <span class="TermText qWord lang-math">RANDOM<br>
new(seed = Random.new_seed)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bp</span> <span class="TermText qDef lang-en">Creates a new PRNG using seed to set the initial state. If<br>
seed is omitted, the generator is initialized with ::new_seed.</span></p></li><li id="iesucks-gu" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
remove_const(sym)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gu</span> <span class="TermText qDef lang-en">Removes the definition of the given constant, returning that constant's<br>
previous value. If that constant referred to a module, this will not<br>
change that module's name and can lead to confusion.</span></p></li><li id="iesucks-kb" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
slice!(index)<br>
slice!(start, length)<br>
slice!(range)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kb</span> <span class="TermText qDef lang-en">Deletes the element(s) given by an index (optionally up to<br>
length elements) or by a range.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.slice!(1) #=&gt; "b"<br>
a #=&gt; ["a", "c"]<br>
a.slice!(-1) #=&gt; "c"<br>
a #=&gt; ["a"]<br>
a.slice!(100) #=&gt; nil<br>
a #=&gt; ["a"]</span></p></li><li id="iesucks-dl" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
gmt?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dl</span> <span class="TermText qDef lang-en">Returns true if time represents a time in UTC (GMT).<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:15:23 -0600<br>
t.utc? #=&gt; false<br>
t = Time.gm(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.utc? #=&gt; true<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:16:03 -0600<br>
t.gmt? #=&gt; false<br>
t = Time.gm(2000,1,1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.gmt? #=&gt; true</span></p></li><li id="iesucks-my" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
tr!(from_str, to_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">my</span> <span class="TermText qDef lang-en">Translates str in place, using the same rules as<br>
String#tr. Returns str, or nil if no<br>
changes were made.</span></p></li><li id="iesucks-bf" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
rng === obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bf</span> <span class="TermText qDef lang-en">Returns true if obj is an element of the range,<br>
false otherwise. Conveniently, === is the<br>
comparison operator used by case statements.<br>
<br>
case 79<br>
when 1..50 then print "low\n"<br>
when 51..75 then print "medium\n"<br>
when 76..100 then print "high\n"<br>
end</span></p></li><li id="iesucks-ae" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
send(symbol [, args...])<br>
__send__(symbol [, args...])<br>
send(string [, args...])<br>
__send__(string [, args...])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ae</span> <span class="TermText qDef lang-en">Invokes the method identified by symbol, passing it any arguments<br>
specified. You can use __send__ if the name send<br>
clashes with an existing method in obj. When the method is<br>
identified by a string, the string is converted to a symbol.<br>
<br>
class Klass<br>
 def hello(*args)<br>
 "Hello " + args.join(' ')<br>
 end<br>
end<br>
k = Klass.new<br>
k.send :hello, "gentle", "readers" #=&gt; "Hello gentle readers"</span></p></li><li id="iesucks-oz" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oz</span> <span class="TermText qDef lang-en">Returns the contents of the environment as a String.</span></p></li><li id="iesucks-la" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
pipe<br>
pipe(ext_enc)<br>
pipe("ext_enc:int_enc" [, opt])<br>
pipe(ext_enc, int_enc [, opt])<br>
pipe(...) {|read_io, write_io| ... }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">la</span> <span class="TermText qDef lang-en">Creates a pair of pipe endpoints (connected to each other) and returns them<br>
as a two-element array of IO objects: [<br>
read_io, write_io ].<br>
<br>
rd, wr = IO.pipe<br>
<br>
if fork<br>
 wr.close<br>
 puts "Parent got: &lt;#{rd.read}&gt;"<br>
 rd.close<br>
 Process.wait<br>
else<br>
 rd.close<br>
 puts "Sending message to parent"<br>
 wr.write "Hi Dad"<br>
 wr.close<br>
end</span></p></li><li id="iesucks-sw" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
new(size=0, obj=nil)<br>
new(array)<br>
new(size) {|index| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sw</span> <span class="TermText qDef lang-en">Returns a new array.<br>
<br>
first_array = ["Matz", "Guido"]<br>
<br>
second_array = Array.new(first_array) #=&gt; ["Matz", "Guido"]<br>
<br>
first_array.equal? second_array #=&gt; false</span></p></li><li id="iesucks-qi" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
truncate(file_name, integer)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qi</span> <span class="TermText qDef lang-en">Truncates the file file_name to be at most integer bytes<br>
long. Not available on all platforms.<br>
<br>
f = File.new("out", "w")<br>
f.write("1234567890") #=&gt; 10<br>
f.close #=&gt; nil<br>
File.truncate("out", 5) #=&gt; 0<br>
File.size("out") #=&gt; 5</span></p></li><li id="iesucks-rg" class="wrong-q"><b> <span class="TermText qWord lang-math">RANDOM<br>
srand(number = Random.new_seed)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rg</span> <span class="TermText qDef lang-en">Seeds the system pseudo-random number generator, Random::DEFAULT, with<br>
number. The previous seed value is returned.<br>
<br>
srand 1234 # =&gt; 268519324636777531569100071560086917274<br>
[ rand, rand ] # =&gt; [0.1915194503788923, 0.6221087710398319]<br>
[ rand(10), rand(1000) ] # =&gt; [4, 664]<br>
srand 1234 # =&gt; 1234<br>
[ rand, rand ] # =&gt; [0.1915194503788923, 0.6221087710398319]</span></p></li><li id="iesucks-mg" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
print(obj, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mg</span> <span class="TermText qDef lang-en">Prints each object in turn to $stdout. If the output field<br>
separator ($,) is not nil, its contents will<br>
appear between each field. If the output record separator<br>
($\&lt;/code&gt;) is not nil, it will be appended to the output. If<br>
no arguments are given, prints &lt;code&gt;$_. Objects that aren't<br>
strings will be converted by calling their to_s method.<br>
<br>
print "cat", [1,2,3], 99, "\n"<br>
$, = ", "<br>
$\ = "\n"<br>
print "cat", [1,2,3], 99</span></p></li><li id="iesucks-sa" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
ceil</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sa</span> <span class="TermText qDef lang-en">Returns the smallest Integer greater than or equal to<br>
num. Class Numeric achieves<br>
this by converting itself to a Float then invoking<br>
Float#ceil.<br>
<br>
1.ceil #=&gt; 1<br>
1.2.ceil #=&gt; 2<br>
(-1.2).ceil #=&gt; -1<br>
(-1.0).ceil #=&gt; -1</span></p></li><li id="iesucks-xd" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
options</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">xd</span> <span class="TermText qDef lang-en">Returns the set of bits corresponding to the options used when creating<br>
this Regexp (see Regexp::new for<br>
details. Note that additional bits may be set in the returned options:<br>
these are used internally by the regular expression code. These extra bits<br>
are ignored if the options are passed to Regexp::new.<br>
<br>
Regexp::IGNORECASE #=&gt; 1<br>
Regexp::EXTENDED #=&gt; 2<br>
Regexp::MULTILINE #=&gt; 4<br>
<br>
/cat/.options #=&gt; 0<br>
/cat/x.options #=&gt; 3<br>
Regexp.new('cat', true).options #=&gt; 1<br>
/\xa1\xa2/.options #=&gt; 16<br>
<br>
r = /cat/x<br>
Regexp.new(r.source, r.options) #=&gt; /cat/ix</span></p></li><li id="iesucks-gj" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
instance_variable_get(symbol)<br>
instance_variable_get(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gj</span> <span class="TermText qDef lang-en">Returns the value of the given instance variable, or nil if the instance<br>
variable is not set. The @ part of the variable name should be<br>
included for regular instance variables. Throws a NameError<br>
exception if the supplied symbol is not valid as an instance variable name.<br>
String arguments are converted to symbols.<br>
<br>
class Fred<br>
 def initialize(p1, p2)<br>
 @a, @b = p1, p2<br>
 end<br>
end<br>
fred = Fred.new('cat', 99)<br>
fred.instance_variable_get(:@a) #=&gt; "cat"<br>
fred.instance_variable_get("@b") #=&gt; 99</span></p></li><li id="iesucks-at" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
isdst</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">at</span> <span class="TermText qDef lang-en">Returns true if time occurs during Daylight Saving Time in its time zone.<br>
<br>
# CST6CDT:<br>
 Time.local(2000, 1, 1).zone #=&gt; "CST"<br>
 Time.local(2000, 1, 1).isdst #=&gt; false<br>
 Time.local(2000, 1, 1).dst? #=&gt; false<br>
 Time.local(2000, 7, 1).zone #=&gt; "CDT"<br>
 Time.local(2000, 7, 1).isdst #=&gt; true<br>
 Time.local(2000, 7, 1).dst? #=&gt; true<br>
<br>
# Asia/Tokyo:<br>
 Time.local(2000, 1, 1).zone #=&gt; "JST"<br>
 Time.local(2000, 1, 1).isdst #=&gt; false<br>
 Time.local(2000, 1, 1).dst? #=&gt; false<br>
 Time.local(2000, 7, 1).zone #=&gt; "JST"<br>
 Time.local(2000, 7, 1).isdst #=&gt; false<br>
 Time.local(2000, 7, 1).dst? #=&gt; false</span></p></li><li id="iesucks-rp" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
has_value?(value)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rp</span> <span class="TermText qDef lang-en">Returns true if the given value is present for some key in<br>
hsh.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.has_value?(100) #=&gt; true<br>
h.has_value?(999) #=&gt; false</span></p></li><li id="iesucks-rj" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
lineno</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rj</span> <span class="TermText qDef lang-en">Returns the current line number in ios. The stream must be opened<br>
for reading. lineno counts the number of times gets is called rather than the number of<br>
newlines encountered. The two values will differ if gets is called with a separator other than<br>
newline.<br>
<br>
f = File.new("testfile")<br>
f.lineno #=&gt; 0<br>
f.gets #=&gt; "This is line one\n"<br>
f.lineno #=&gt; 1<br>
f.gets #=&gt; "This is line two\n"<br>
f.lineno #=&gt; 2</span></p></li><li id="iesucks-oj" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oj</span> <span class="TermText qDef lang-en">Convert this range object to a printable form (using inspect<br>
to convert the begin and end objects).</span></p></li><li id="iesucks-bl" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
to_a(sep=$/)<br>
to_a(limit)<br>
to_a(sep, limit)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bl</span> <span class="TermText qDef lang-en">Reads ARGF's current file in its entirety, returning an<br>
Array of its lines, one line per element. Lines are assumed to<br>
be separated by sep.<br>
<br>
lines = ARGF.readlines<br>
lines[0] #=&gt; "This is line one\n"</span></p></li><li id="iesucks-kx" class="wrong-q"><b> <span class="TermText qWord lang-math">ENCODING<br>
default_internal</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kx</span> <span class="TermText qDef lang-en">Returns default internal encoding. Strings will be transcoded to the<br>
default internal encoding in the following places if the default internal<br>
encoding is not nil:</span></p></li><li id="iesucks-bh" class="wrong-q"><b> <span class="TermText qWord lang-math">EXCEPTION<br>
set_backtrace(backtrace)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bh</span> <span class="TermText qDef lang-en">Sets the backtrace information associated with exc. The<br>
backtrace must be an array of String<br>
objects or a single String in the format<br>
described in #backtrace.</span></p></li><li id="iesucks-qd" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
`cmd`</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qd</span> <span class="TermText qDef lang-en">Returns the standard output of running cmd in a subshell. The<br>
built-in syntax %x{...} uses this method. Sets $?<br>
to the process status.<br>
<br>
%xdate` #=&gt; "Wed Apr 9 08:56:30 CDT 2003\n"<br>
%xls testdir`.split[1] #=&gt; "main.rb"<br>
%xecho oops ^!^ exit 99` #=&gt; "oops\n"<br>
$?.exitstatus #=&gt; 99</span></p></li><li id="iesucks-uw" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
owned?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uw</span> <span class="TermText qDef lang-en">Returns true if the effective user id of the process is the<br>
same as the owner of stat.<br>
<br>
File.stat("testfile").owned? #=&gt; true<br>
File.stat("/etc/passwd").owned? #=&gt; false</span></p></li><li id="iesucks-qx" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
readable?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qx</span> <span class="TermText qDef lang-en">Returns true if stat is readable by the effective<br>
user id of this process.<br>
<br>
File.stat("testfile").readable? #=&gt; true</span></p></li><li id="iesucks-fr" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
include?(name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fr</span> <span class="TermText qDef lang-en">Returns true if there is an environment variable with the<br>
given name.</span></p></li><li id="iesucks-qa" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
chroot( string )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qa</span> <span class="TermText qDef lang-en">Changes this process's idea of the file system root. Only a privileged<br>
process may make this call. Not available on all platforms. On Unix<br>
systems, see chroot(2) for more information.</span></p></li><li id="iesucks-uj" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
frozen?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uj</span> <span class="TermText qDef lang-en">Returns the freeze status of obj.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.freeze #=&gt; ["a", "b", "c"]<br>
a.frozen? #=&gt; true</span></p></li><li id="iesucks-kg" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
syswrite(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kg</span> <span class="TermText qDef lang-en">Writes the given string to ios using a low-level write. Returns<br>
the number of bytes written. Do not mix with other methods that write to<br>
ios or you may get unpredictable results. Raises<br>
SystemCallError on error.<br>
<br>
f = File.new("out", "w")<br>
f.syswrite("ABCDEF") #=&gt; 6</span></p></li><li id="iesucks-fd" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
chars</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fd</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_char.</span></p></li><li id="iesucks-mb" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
each_byte {|fixnum| block }<br>
each_byte</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mb</span> <span class="TermText qDef lang-en">Passes each byte in str to the given block, or returns an<br>
enumerator if no block is given.<br>
<br>
"hello".each_byte {|c| print c, ' ' }</span></p></li><li id="iesucks-hm" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
setbyte(index, integer)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hm</span> <span class="TermText qDef lang-en">modifies the indexth byte as integer.</span></p></li><li id="iesucks-tv" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
caller_locations(start=1, length=nil)<br>
caller_locations(range)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tv</span> <span class="TermText qDef lang-en">Returns the current execution stack—an array containing backtrace location<br>
objects.</span></p></li><li id="iesucks-co" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
valid_encoding?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">co</span> <span class="TermText qDef lang-en">Returns true for a string which encoded correctly.<br>
<br>
"\xc2\xa1".force_encoding("UTF-8").valid_encoding? #=&gt; true<br>
"\xc2".force_encoding("UTF-8").valid_encoding? #=&gt; false<br>
"\x80".force_encoding("UTF-8").valid_encoding? #=&gt; false</span></p></li><li id="iesucks-cd" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cd</span> <span class="TermText qDef lang-en">Returns "ARGF".</span></p></li><li id="iesucks-dq" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
included_modules</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dq</span> <span class="TermText qDef lang-en">Returns the list of modules included in mod.<br>
<br>
module Mixin<br>
end<br>
<br>
module Outer<br>
 include Mixin<br>
end<br>
<br>
Mixin.included_modules #=&gt; []<br>
Outer.included_modules #=&gt; [Mixin]</span></p></li><li id="iesucks-jm" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
to_s(base=10)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jm</span> <span class="TermText qDef lang-en">Returns a string containing the representation of big radix<br>
base (2 through 36).<br>
<br>
12345654321.to_s #=&gt; "12345654321"<br>
12345654321.to_s(2) #=&gt; "1011011111110110111011110000110001"<br>
12345654321.to_s(8) #=&gt; "133766736061"<br>
12345654321.to_s(16) #=&gt; "2dfdbbc31"<br>
78546939656932.to_s(36) #=&gt; "rubyrules"</span></p></li><li id="iesucks-cx" class="wrong-q"><b> <span class="TermText qWord lang-math">ENCODING<br>
find(string)<br>
find(symbol)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cx</span> <span class="TermText qDef lang-en">Search the encoding with specified name. name should be a<br>
string or symbol.<br>
<br>
Encoding.find("US-ASCII") #=&gt; #&lt;Encoding:US-ASCII&gt;<br>
Encoding.find(:Shift_JIS) #=&gt; #&lt;Encoding:Shift_JIS&gt;</span></p></li><li id="iesucks-wm" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
eval(string [, binding [, filename [,lineno]]])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wm</span> <span class="TermText qDef lang-en">Evaluates the Ruby expression(s) in string. If binding is<br>
given, which must be a Binding object, the evaluation is<br>
performed in its context. If the optional filename and<br>
lineno parameters are present, they will be used when reporting<br>
syntax errors.<br>
<br>
def get_binding(str)<br>
 return binding<br>
end<br>
str = "hello"<br>
eval "str + ' Fred'" #=&gt; "hello Fred"<br>
eval "str + ' Fred'", get_binding("bye") #=&gt; "bye Fred"</span></p></li><li id="iesucks-vh" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fix * numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vh</span> <span class="TermText qDef lang-en">Performs multiplication: the class of the resulting object depends on the<br>
class of numeric and on the magnitude of the result.</span></p></li><li id="iesucks-pq" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
each_key {| key | block }<br>
each_key</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pq</span> <span class="TermText qDef lang-en">Calls block once for each key in hsh, passing the key as<br>
a parameter.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.each_key {|key| puts key }</span></p></li><li id="iesucks-lr" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
key(value)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lr</span> <span class="TermText qDef lang-en">Returns the key of an occurrence of a given value. If the value is not<br>
found, returns nil.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300, "d" =&gt; 300 }<br>
h.key(200) #=&gt; "b"<br>
h.key(300) #=&gt; "c"<br>
h.key(999) #=&gt; nil</span></p></li><li id="iesucks-fl" class="wrong-q"><b> <span class="TermText qWord lang-math">PROC<br>
curry<br>
curry(arity)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fl</span> <span class="TermText qDef lang-en">Returns a curried proc. If the optional arity argument is given,<br>
it determines the number of arguments. A curried proc receives some<br>
arguments. If a sufficient number of arguments are supplied, it passes the<br>
supplied arguments to the original proc and returns the result. Otherwise,<br>
returns another curried proc that takes the rest of arguments.<br>
<br>
b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; 6<br>
p b.curry(5)[1][2][3][4][5] #=&gt; 6<br>
p b.curry(5)[1, 2][3, 4][5] #=&gt; 6<br>
p b.curry(1)[1] #=&gt; 1<br>
<br>
b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; 10<br>
p b.curry(5)[1][2][3][4][5] #=&gt; 15<br>
p b.curry(5)[1, 2][3, 4][5] #=&gt; 15<br>
p b.curry(1)[1] #=&gt; 1<br>
<br>
b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; wrong number of arguments (4 for 3)<br>
p b.curry(5) #=&gt; wrong number of arguments (5 for 3)<br>
p b.curry(1) #=&gt; wrong number of arguments (1 for 3)<br>
<br>
b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; 10<br>
p b.curry(5)[1][2][3][4][5] #=&gt; 15<br>
p b.curry(5)[1, 2][3, 4][5] #=&gt; 15<br>
p b.curry(1) #=&gt; wrong number of arguments (1 for 3)<br>
<br>
b = proc { :foo }<br>
p b.curry[] #=&gt; :foo</span></p></li><li id="iesucks-if" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
partition(sep)<br>
partition(regexp)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">if</span> <span class="TermText qDef lang-en">Searches sep or pattern (regexp) in the string and<br>
returns the part before it, the match, and the part after it. If it is not<br>
found, returns two empty strings and str.<br>
<br>
"hello".partition("l") #=&gt; ["he", "l", "lo"]<br>
"hello".partition("x") #=&gt; ["hello", "", ""]<br>
"hello".partition(/.l/) #=&gt; ["h", "el", "lo"]</span></p></li><li id="iesucks-ti" class="wrong-q"><b> <span class="TermText qWord lang-math">NILCLASS<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ti</span> <span class="TermText qDef lang-en">Always returns the string "nil".</span></p></li><li id="iesucks-pe" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
local_variables</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pe</span> <span class="TermText qDef lang-en">Returns the names of the current local variables.<br>
<br>
fred = 1<br>
for i in 1..10<br>
 # ...<br>
end<br>
local_variables #=&gt; [:fred, :i]</span></p></li><li id="iesucks-ps" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
method(sym)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ps</span> <span class="TermText qDef lang-en">Looks up the named method as a receiver in obj, returning a<br>
Method object (or raising NameError). The<br>
Method object acts as a closure in obj's object<br>
instance, so instance variables and the value of self remain<br>
available.<br>
<br>
class Demo<br>
 def initialize(n)<br>
 @iv = n<br>
 end<br>
 def hello()<br>
 "Hello, @iv = #{@iv}"<br>
 end<br>
end<br>
<br>
k = Demo.new(99)<br>
m = k.method(:hello)<br>
m.call #=&gt; "Hello, @iv = 99"<br>
<br>
l = Demo.new('Fred')<br>
m = l.method("hello")<br>
m.call #=&gt; "Hello, @iv = Fred"</span></p></li><li id="iesucks-mx" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
scan(pattern)<br>
scan(pattern) {|match, ...| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mx</span> <span class="TermText qDef lang-en">Both forms iterate through str, matching the pattern (which may be<br>
a Regexp or a String). For each match, a result<br>
is generated and either added to the result array or passed to the block.<br>
If the pattern contains no groups, each individual result consists of the<br>
matched string, $&amp;. If the pattern contains groups, each<br>
individual result is itself an array containing one entry per group.<br>
<br>
a = "cruel world"<br>
a.scan(/\w+/) #=&gt; ["cruel", "world"]<br>
a.scan(/.../) #=&gt; ["cru", "el ", "wor"]<br>
a.scan(/(...)/) #=&gt; [["cru"], ["el "], ["wor"]]<br>
a.scan(/(..)(..)/) #=&gt; [["cr", "ue"], ["l ", "wo"]]</span></p></li><li id="iesucks-p" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
const_defined?(sym, inherit=true)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">p</span> <span class="TermText qDef lang-en">Checks for a constant with the given name in mod If<br>
inherit is set, the lookup will also search the ancestors (and<br>
Object if mod is a Module.)<br>
<br>
Math.const_defined? "PI" #=&gt; true<br>
IO.const_defined? :SYNC #=&gt; true<br>
IO.const_defined? :SYNC, false #=&gt; false</span></p></li><li id="iesucks-ke" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERATOR<br>
new(size = nil) { |yielder| ... }<br>
new(obj, method = :each, *args)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ke</span> <span class="TermText qDef lang-en">Creates a new Enumerator object, which can be<br>
used as an Enumerable.<br>
<br>
fib = Enumerator.new do |y|<br>
 a = b = 1<br>
 loop do<br>
 y &lt;&lt; a<br>
 a, b = b, a + b<br>
 end<br>
end<br>
<br>
p fib.take(10) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></p></li><li id="iesucks-hb" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
flat_map { |obj| block }<br>
flat_map</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hb</span> <span class="TermText qDef lang-en">Returns a new array with the concatenated results of running block<br>
once for every element in enum.<br>
<br>
[1, 2, 3, 4].flat_map { |e| [e, -e] } #=&gt; [1, -1, 2, -2, 3, -3, 4, -4]<br>
[[1, 2], [3, 4]].flat_map { |e| e + [100] } #=&gt; [1, 2, 100, 3, 4, 100]</span></p></li><li id="iesucks-vr" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
to_i",<br>
"IO<br>
to_io</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vr</span> <span class="TermText qDef lang-en">Returns ios.</span></p></li><li id="iesucks-so" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
float / other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">so</span> <span class="TermText qDef lang-en">Returns a new float which is the result of dividing float by<br>
other.</span></p></li><li id="iesucks-cg" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
coerce(numeric)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cg</span> <span class="TermText qDef lang-en">If aNumeric is the same type as num, returns an array<br>
containing aNumeric and num. Otherwise, returns an array<br>
with both aNumeric and num represented as<br>
Float objects. This coercion mechanism is used by Ruby to<br>
handle mixed-type numeric operations: it is intended to find a compatible<br>
common type between the two operands of the operator.<br>
<br>
1.coerce(2.5) #=&gt; [2.5, 1.0]<br>
1.2.coerce(3) #=&gt; [3.0, 1.2]<br>
1.coerce(2) #=&gt; [2, 1]</span></p></li><li id="iesucks-lw" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
eql?(other)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lw</span> <span class="TermText qDef lang-en">Returns true if self and other are<br>
the same object, or are both arrays with the same content (according to Object#eql?).</span></p></li><li id="iesucks-rk" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
gets(sep=$/)<br>
gets(limit)<br>
gets(sep, limit)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rk</span> <span class="TermText qDef lang-en">Returns the next line from the current file in ARGF.</span></p></li><li id="iesucks-kd" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
eql?(other)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kd</span> <span class="TermText qDef lang-en">Returns true if hash and other are both<br>
hashes with the same content.</span></p></li><li id="iesucks-ij" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
dump</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ij</span> <span class="TermText qDef lang-en">Produces a version of str with all non-printing characters<br>
replaced by \nnn notation and all special characters escaped.<br>
<br>
"hello \n ''".dump #=&gt; "\"hello \\n ''\"</span></p></li><li id="iesucks-hy" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
writable_real?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hy</span> <span class="TermText qDef lang-en">Returns true if stat is writable by the real user id<br>
of this process.<br>
<br>
File.stat("testfile").writable_real? #=&gt; true</span></p></li><li id="iesucks-va" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
ary | other_ary</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">va</span> <span class="TermText qDef lang-en">Set Union — Returns a new array by joining ary with<br>
other_ary, excluding any duplicates and preserving the order<br>
from the original array.<br>
<br>
[ "a", "b", "c" ] | [ "c", "d", "a" ] #=&gt; [ "a", "b", "c", "d" ]</span></p></li><li id="iesucks-ll" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
rng == obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ll</span> <span class="TermText qDef lang-en">Returns true only if obj is a Range, has equivalent begin and end items (by<br>
comparing them with ==), and has the same exclude_end? setting as the<br>
range.<br>
<br>
(0..2) == (0..2) #=&gt; true<br>
(0..2) == Range.new(0,2) #=&gt; true<br>
(0..2) == (0...2) #=&gt; false</span></p></li><li id="iesucks-jh" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
denominator</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jh</span> <span class="TermText qDef lang-en">Returns the denominator (always positive). The result is machine<br>
dependent.</span></p></li><li id="iesucks-eu" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
flatten<br>
flatten(level)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">eu</span> <span class="TermText qDef lang-en">Returns a new array that is a one-dimensional flattening of this hash. That<br>
is, for every key or value that is an array, extract its elements into the<br>
new array. Unlike Array#flatten,<br>
this method does not flatten recursively by default. The optional<br>
level argument determines the level of recursion to flatten.<br>
<br>
a = {1=&gt; "one", 2 =&gt; [2,"two"], 3 =&gt; "three"}<br>
a.flatten # =&gt; [1, "one", 2, [2, "two"], 3, "three"]<br>
a.flatten(2) # =&gt; [1, "one", 2, 2, "two", 3, "three"]</span></p></li><li id="iesucks-wo" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
public_method_defined?(symbol)<br>
public_method_defined?(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wo</span> <span class="TermText qDef lang-en">Returns true if the named public method is defined by<br>
mod (or its included modules and, if mod is a class, its<br>
ancestors). String arguments are converted to<br>
symbols.<br>
<br>
module A<br>
 def method1() end<br>
end<br>
class B<br>
 protected<br>
 def method2() end<br>
end<br>
class C &lt; B<br>
 include A<br>
 def method3() end<br>
end<br>
<br>
A.method_defined? :method1 #=&gt; true<br>
C.public_method_defined? "method1" #=&gt; true<br>
C.public_method_defined? "method2" #=&gt; false<br>
C.method_defined? "method2" #=&gt; true</span></p></li><li id="iesucks-hx" class="wrong-q"><b> <span class="TermText qWord lang-math">STRUCT<br>
struct[symbol] = obj<br>
struct[fixnum] = obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hx</span> <span class="TermText qDef lang-en">Attribute Assignment—Assigns to the instance variable named by<br>
symbol or fixnum the value obj and returns it.<br>
Will raise a NameError if the named variable does not exist,<br>
or an IndexError if the index is out of range.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
<br>
joe["name"] = "Luke"<br>
joe[:zip] = "90210"<br>
<br>
joe.name #=&gt; "Luke"<br>
joe.zip #=&gt; "90210"</span></p></li><li id="iesucks-oo" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
obj =~ other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oo</span> <span class="TermText qDef lang-en">Pattern Match—Overridden by descendants (notably Regexp and<br>
String) to provide meaningful pattern-match semantics.</span></p></li><li id="iesucks-gn" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
atime</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gn</span> <span class="TermText qDef lang-en">Returns the last access time for this file as an object of class<br>
Time.<br>
<br>
File.stat("testfile").atime #=&gt; Wed Dec 31 18:00:00 CST 1969</span></p></li><li id="iesucks-cp" class="wrong-q"><b> <span class="TermText qWord lang-math">FALSECLASS<br>
false | obj<br>
nil | obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cp</span> <span class="TermText qDef lang-en">Or—Returns false if obj is nil or<br>
false; true otherwise.</span></p></li><li id="iesucks-ge" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
fail<br>
fail(string)<br>
fail(exception [, string [, array]])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ge</span> <span class="TermText qDef lang-en">With no arguments, raises the exception in $! or raises a<br>
RuntimeError if $! is nil. With a<br>
single String argument, raises a RuntimeError<br>
with the string as a message. Otherwise, the first parameter should be the<br>
name of an Exception class (or an object that returns an<br>
Exception object when sent an exception message).<br>
The optional second parameter sets the message associated with the<br>
exception, and the third parameter is an array of callback information.<br>
Exceptions are caught by the rescue clause of<br>
begin...end blocks.<br>
<br>
raise "Failed to create socket"<br>
raise ArgumentError, "No parameters", caller</span></p></li><li id="iesucks-k" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">k</span> <span class="TermText qDef lang-en">Returns a string representing obj. The default to_s<br>
prints the object's class and an encoding of the object id. As a special<br>
case, the top-level object that is the initial execution context of Ruby<br>
programs returns "main."</span></p></li><li id="iesucks-v" class="wrong-q"><b> <span class="TermText qWord lang-math">RANGE<br>
member?(obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">v</span> <span class="TermText qDef lang-en">Returns true if obj is an element of the range,<br>
false otherwise. If begin and end are numeric, comparison is<br>
done according to the magnitude of the values.<br>
<br>
("a".."z").include?("g") #=&gt; true<br>
("a".."z").include?("A") #=&gt; false<br>
("a".."z").include?("cc") #=&gt; false</span></p></li><li id="iesucks-ct" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
to_enum(method = :each, *args)<br>
to_enum(method = :each, *args) {|*args| block}</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ct</span> <span class="TermText qDef lang-en">Creates a new Enumerator which will enumerate<br>
by calling method on obj, passing<br>
args if any.<br>
<br>
str = "xyz"<br>
<br>
enum = str.enum_for(:each_byte)<br>
enum.each { |b| puts b }<br>
# =&gt; 120<br>
# =&gt; 121<br>
# =&gt; 122<br>
<br>
# protect an array from being modified by some_method<br>
a = [1, 2, 3]<br>
some_method(a.to_enum)</span></p></li><li id="iesucks-ko" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
to_r</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ko</span> <span class="TermText qDef lang-en">Returns the value as a rational.<br>
<br>
2.0.to_r #=&gt; (2/1)<br>
2.5.to_r #=&gt; (5/2)<br>
-0.75.to_r #=&gt; (-3/4)<br>
0.0.to_r #=&gt; (0/1)</span></p></li><li id="iesucks-lp" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
div(other)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lp</span> <span class="TermText qDef lang-en">Performs integer division: returns integer value.</span></p></li><li id="iesucks-eq" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
write(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">eq</span> <span class="TermText qDef lang-en">Writes the given string to ios. The stream must be opened for<br>
writing. If the argument is not a string, it will be converted to a string<br>
using to_s. Returns the number of bytes written.<br>
<br>
count = $stdout.write("This is a test\n")<br>
puts "That was #{count} bytes of data"</span></p></li><li id="iesucks-cz" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
integer?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cz</span> <span class="TermText qDef lang-en">Always returns true.</span></p></li><li id="iesucks-ve" class="wrong-q"><b> <span class="TermText qWord lang-math">FILETEST<br>
owned?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ve</span> <span class="TermText qDef lang-en">Returns true if the named file exists and the effective used<br>
id of the calling process is the owner of the file.</span></p></li><li id="iesucks-ie" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
hour</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ie</span> <span class="TermText qDef lang-en">Returns the hour of the day (0..23) for time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:26:20 -0600<br>
t.hour #=&gt; 8</span></p></li><li id="iesucks-fj" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
shuffle<br>
shuffle(random: rng)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fj</span> <span class="TermText qDef lang-en">Returns a new array with elements of self shuffled.<br>
<br>
a = [ 1, 2, 3 ] #=&gt; [1, 2, 3]<br>
a.shuffle #=&gt; [2, 3, 1]</span></p></li><li id="iesucks-l" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
partition { |obj| block }<br>
partition</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">l</span> <span class="TermText qDef lang-en">Returns two arrays, the first containing the elements of enum for<br>
which the block evaluates to true, the second containing the rest.<br>
<br>
(1..6).partition { |v| v.even? } #=&gt; [[2, 4, 6], [1, 3, 5]]</span></p></li><li id="iesucks-fy" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
include?(key)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fy</span> <span class="TermText qDef lang-en">Returns true if the given key is present in hsh.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.has_key?("a") #=&gt; true<br>
h.has_key?("z") #=&gt; false</span></p></li><li id="iesucks-ef" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
divmod(numeric)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ef</span> <span class="TermText qDef lang-en">See Numeric#divmod.</span></p></li><li id="iesucks-ck" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
skip</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ck</span> <span class="TermText qDef lang-en">For example:<br>
<br>
Sets the current file to the next file in ARGV. If there aren't any more<br>
files it has no effect.</span></p></li><li id="iesucks-sd" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
to_io</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sd</span> <span class="TermText qDef lang-en">Returns an IO object representing the current file. This will<br>
be a File object unless the current file is a stream such as<br>
STDIN.<br>
<br>
ARGF.to_io #=&gt; #&lt;File:glark.txt&gt;<br>
ARGF.to_io #=&gt; #&lt;IO:&lt;STDIN&gt;&gt;</span></p></li><li id="iesucks-hs" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
rxp === str</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hs</span> <span class="TermText qDef lang-en">Case Equality—Used in case statements.<br>
<br>
a = "HELLO"<br>
case a<br>
when /^[a-z]*$/; print "Lower case\n"<br>
when /^[A-Z]*$/; print "Upper case\n"<br>
else; print "Mixed case\n"<br>
end<br>
#=&gt; "Upper case"</span></p></li><li id="iesucks-cw" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
keys</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cw</span> <span class="TermText qDef lang-en">Returns every environment variable name in an Array</span></p></li><li id="iesucks-sc" class="wrong-q"><b> <span class="TermText qWord lang-math">ENCODING<br>
aliases</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sc</span> <span class="TermText qDef lang-en">Returns the hash of available encoding alias and original encoding name.<br>
<br>
Encoding.aliases<br>
#=&gt; {"BINARY"=&gt;"ASCII-8BIT", "ASCII"=&gt;"US-ASCII", "ANSI_X3.4-1986"=&gt;"US-ASCII",<br>
 "SJIS"=&gt;"Shift_JIS", "eucJP"=&gt;"EUC-JP", "CP932"=&gt;"Windows-31J"}</span></p></li><li id="iesucks-hr" class="wrong-q"><b> <span class="TermText qWord lang-math">RANDOM<br>
seed</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hr</span> <span class="TermText qDef lang-en">Returns the seed value used to initialize the generator. This may be used<br>
to initialize another generator with the same state at a later time,<br>
causing it to produce the same sequence of numbers.<br>
<br>
prng1 = Random.new(1234)<br>
prng1.seed #=&gt; 1234<br>
prng1.rand(100) #=&gt; 47<br>
<br>
prng2 = Random.new(prng1.seed)<br>
prng2.rand(100) #=&gt; 47</span></p></li><li id="iesucks-na" class="wrong-q"><b> <span class="TermText qWord lang-math">CLASS<br>
superclass</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">na</span> <span class="TermText qDef lang-en">Returns the superclass of class, or nil.<br>
<br>
File.superclass #=&gt; IO<br>
IO.superclass #=&gt; Object<br>
Object.superclass #=&gt; BasicObject<br>
class Foo; end<br>
class Bar &lt; Foo; end<br>
Bar.superclass #=&gt; Foo</span></p></li><li id="iesucks-ow" class="wrong-q"><b> <span class="TermText qWord lang-math">NILCLASS<br>
false ^ obj<br>
nil ^ obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ow</span> <span class="TermText qDef lang-en">Exclusive Or—If obj is nil or false,<br>
returns false; otherwise, returns true.</span></p></li><li id="iesucks-nl" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
putc(obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nl</span> <span class="TermText qDef lang-en">If obj is Numeric, write the character whose code is<br>
the least-significant byte of obj, otherwise write the first byte<br>
of the string representation of obj to ios. Note: This<br>
method is not safe for use with multi-byte characters as it will truncate<br>
them.<br>
<br>
$stdout.putc "A"<br>
$stdout.putc 65</span></p></li><li id="iesucks-vn" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
friday?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vn</span> <span class="TermText qDef lang-en">Returns true if time represents Friday.<br>
<br>
t = Time.local(1987, 12, 18) #=&gt; 1987-12-18 00:00:00 -0600<br>
t.friday? #=&gt; true</span></p></li><li id="iesucks-ao" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big - other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ao</span> <span class="TermText qDef lang-en">Subtracts other from big, returning the result.</span></p></li><li id="iesucks-gb" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
reject {|item| block }<br>
reject</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gb</span> <span class="TermText qDef lang-en">Returns a new array containing the items in self for which the<br>
given block is not true.</span></p></li><li id="iesucks-og" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">og</span> <span class="TermText qDef lang-en">Returns "ENV"</span></p></li><li id="iesucks-es" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
default_proc = proc_obj or nil</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">es</span> <span class="TermText qDef lang-en">Sets the default proc to be executed on each failed key lookup.<br>
<br>
h.default_proc = proc do |hash, key|<br>
 hash[key] = key + key<br>
end<br>
h[2] #=&gt; 4<br>
h["cat"] #=&gt; "catcat"</span></p></li><li id="iesucks-ib" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
hash</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ib</span> <span class="TermText qDef lang-en">Return a hash based on the string's length and content.</span></p></li><li id="iesucks-gr" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
minmax<br>
minmax { |a, b| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gr</span> <span class="TermText qDef lang-en">Returns two elements array which contains the minimum and the maximum value<br>
in the enumerable. The first form assumes all objects implement<br>
Comparable; the second uses the block to return a<br>
&lt;=&gt; b.<br>
<br>
a = %w(albatross dog horse)<br>
a.minmax #=&gt; ["albatross", "horse"]<br>
a.minmax { |a, b| a.length &lt;=&gt; b.length } #=&gt; ["dog", "albatross"]</span></p></li><li id="iesucks-bz" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
take(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bz</span> <span class="TermText qDef lang-en">Returns first n elements from the array.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.take(3) #=&gt; [1, 2, 3]</span></p></li><li id="iesucks-cs" class="wrong-q"><b> <span class="TermText qWord lang-math">MATCHDATA<br>
regexp</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cs</span> <span class="TermText qDef lang-en">Returns the regexp.<br>
<br>
m = /a.*b/.match("abc")<br>
m.regexp #=&gt; /a.*b/</span></p></li><li id="iesucks-ev" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big * other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ev</span> <span class="TermText qDef lang-en">Multiplies big and other, returning the result.</span></p></li><li id="iesucks-ee" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
world_writable?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ee</span> <span class="TermText qDef lang-en">If stat is writable by others, returns an integer representing the<br>
file permission bits of stat. Returns nil otherwise.<br>
The meaning of the bits is platform dependent; on Unix systems, see<br>
stat(2).<br>
<br>
m = File.stat("/tmp").world_writable? #=&gt; 511<br>
sprintf("%o", m) #=&gt; "777"</span></p></li><li id="iesucks-ou" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
rewind</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ou</span> <span class="TermText qDef lang-en">Positions ios to the beginning of input, resetting<br>
lineno to zero.<br>
<br>
f = File.new("testfile")<br>
f.readline #=&gt; "This is line one\n"<br>
f.rewind #=&gt; 0<br>
f.lineno #=&gt; 0<br>
f.readline #=&gt; "This is line one\n"</span></p></li><li id="iesucks-hd" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
gmtoff</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hd</span> <span class="TermText qDef lang-en">Returns the offset in seconds between the timezone of time and<br>
UTC.<br>
<br>
t = Time.gm(2000,1,1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.gmt_offset #=&gt; 0<br>
l = t.getlocal #=&gt; 2000-01-01 14:15:01 -0600<br>
l.gmt_offset #=&gt; -21600</span></p></li><li id="iesucks-qz" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
wday</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qz</span> <span class="TermText qDef lang-en">Returns an integer representing the day of the week, 0..6, with Sunday ==<br>
0.<br>
<br>
t = Time.now #=&gt; 2007-11-20 02:35:35 -0600<br>
t.wday #=&gt; 2<br>
t.sunday? #=&gt; false<br>
t.monday? #=&gt; false<br>
t.tuesday? #=&gt; true<br>
t.wednesday? #=&gt; false<br>
t.thursday? #=&gt; false<br>
t.friday? #=&gt; false<br>
t.saturday? #=&gt; false</span></p></li><li id="iesucks-ro" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
public<br>
public(symbol, ...)<br>
public(string, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ro</span> <span class="TermText qDef lang-en">With no arguments, sets the default visibility for subsequently defined<br>
methods to public. With arguments, sets the named methods to have public<br>
visibility. String arguments are converted to<br>
symbols.</span></p></li><li id="iesucks-vc" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
encode!(encoding [, options] )<br>
encode!(dst_encoding, src_encoding [, options] )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vc</span> <span class="TermText qDef lang-en">The first form transcodes the contents of str from str.encoding to<br>
encoding. The second form transcodes the contents of<br>
str from src_encoding to dst_encoding. The options Hash gives details for conversion. See #encode for details. Returns the<br>
string even if no changes were made.</span></p></li><li id="iesucks-sh" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
fcntl(integer_cmd, arg)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sh</span> <span class="TermText qDef lang-en">Provides a mechanism for issuing low-level commands to control or query<br>
file-oriented I/O streams. Arguments and results are platform dependent. If<br>
arg is a number, its value is passed directly. If it is a string,<br>
it is interpreted as a binary sequence of bytes (Array#pack<br>
might be a useful way to build this string). On Unix platforms, see<br>
fcntl(2) for details. Not implemented on all platforms.</span></p></li><li id="iesucks-bk" class="wrong-q"><b> <span class="TermText qWord lang-math">EXCEPTION<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bk</span> <span class="TermText qDef lang-en">Return this exception's class name and message</span></p></li><li id="iesucks-ah" class="wrong-q"><b> <span class="TermText qWord lang-math">TRUECLASS<br>
inspect",<br>
"TRUECLASS<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ah</span> <span class="TermText qDef lang-en">The string representation of true is "true".</span></p></li><li id="iesucks-vu" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
getbyte(index)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vu</span> <span class="TermText qDef lang-en">returns the indexth byte as an integer.</span></p></li><li id="iesucks-tk" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
gcdlcm(int2)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tk</span> <span class="TermText qDef lang-en">Returns an array; [int.gcd(int2), int.lcm(int2)].<br>
<br>
2.gcdlcm(2) #=&gt; [2, 2]<br>
3.gcdlcm(-7) #=&gt; [1, 21]<br>
((1&lt;&lt;31)-1).gcdlcm((1&lt;&lt;61)-1) #=&gt; [1, 4951760154835678088235319297]</span></p></li><li id="iesucks-nm" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
denominator</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nm</span> <span class="TermText qDef lang-en">Returns the denominator (always positive).</span></p></li><li id="iesucks-qt" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
each_char {|cstr| block }<br>
each_char</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qt</span> <span class="TermText qDef lang-en">Passes each character in str to the given block, or returns an<br>
enumerator if no block is given.<br>
<br>
"hello".each_char {|c| print c, ' ' }</span></p></li><li id="iesucks-rb" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
minmax_by { |obj| block }<br>
minmax_by</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rb</span> <span class="TermText qDef lang-en">Returns a two element array containing the objects in enum that<br>
correspond to the minimum and maximum values respectively from the given<br>
block.<br>
<br>
a = %w(albatross dog horse)<br>
a.minmax_by { |x| x.length } #=&gt; ["dog", "albatross"]</span></p></li><li id="iesucks-c" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
basename(file_name [, suffix] )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">c</span> <span class="TermText qDef lang-en">Returns the last component of the filename given in file_name,<br>
which can be formed using both File::SEPARATOR and<br>
File::ALT_SEPARETOR as the separator when<br>
File::ALT_SEPARATOR is not nil. If<br>
suffix is given and present at the end of file_name, it<br>
is removed.<br>
<br>
File.basename("/home/gumby/work/ruby.rb") #=&gt; "ruby.rb"<br>
File.basename("/home/gumby/work/ruby.rb", ".rb") #=&gt; "ruby"</span></p></li><li id="iesucks-wn" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
readchar</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wn</span> <span class="TermText qDef lang-en">Reads the next character from ARGF and returns it as a<br>
String. Raises an EOFError after the last<br>
character of the last file has been read.<br>
<br>
$ echo "foo" &gt; file<br>
$ ruby argf.rb file<br>
<br>
ARGF.readchar #=&gt; "f"<br>
ARGF.readchar #=&gt; "o"<br>
ARGF.readchar #=&gt; "o"<br>
ARGF.readchar #=&gt; "\n"<br>
ARGF.readchar #=&gt; end of file reached (EOFError)</span></p></li><li id="iesucks-qo" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
invert</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qo</span> <span class="TermText qDef lang-en">Returns a new hash created by using hsh's values as keys, and the<br>
keys as values.<br>
<br>
h = { "n" =&gt; 100, "m" =&gt; 100, "y" =&gt; 300, "d" =&gt; 200, "a" =&gt; 0 }<br>
h.invert #=&gt; {0=&gt;"a", 100=&gt;"m", 200=&gt;"d", 300=&gt;"y"}</span></p></li><li id="iesucks-li" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
next</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">li</span> <span class="TermText qDef lang-en">Returns the Integer equal to int + 1.<br>
<br>
1.next #=&gt; 2<br>
(-1).next #=&gt; 0</span></p></li><li id="iesucks-fx" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
clone</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fx</span> <span class="TermText qDef lang-en">Produces a shallow copy of obj—the instance variables of<br>
obj are copied, but not the objects they reference. Copies the<br>
frozen and tainted state of obj. See also the discussion under<br>
Object#dup.<br>
<br>
class Klass<br>
 attr_accessor :str<br>
end<br>
s1 = Klass.new #=&gt; #&lt;Klass:0x401b3a38&gt;<br>
s1.str = "Hello" #=&gt; "Hello"<br>
s2 = s1.clone #=&gt; #&lt;Klass:0x401b3998 @str="Hello"&gt;<br>
s2.str[1,4] = "i" #=&gt; "i"<br>
s1.inspect #=&gt; "#&lt;Klass:0x401b3a38 @str=\"Hi\"&gt;"<br>
s2.inspect #=&gt; "#&lt;Klass:0x401b3998 @str=\"Hi\"&gt;"</span></p></li><li id="iesucks-si" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fix <br>
 <br>
 click to toggle source</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">si</span> <span class="TermText qDef lang-en">Returns true if the value of fix is less than or<br>
equal to that of real.</span></p></li><li id="iesucks-wu" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
include?(module)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wu</span> <span class="TermText qDef lang-en">Returns true if module is included in mod or<br>
one of mod's ancestors.<br>
<br>
module A<br>
end<br>
class B<br>
 include A<br>
end<br>
class C &lt; B<br>
end<br>
B.include?(A) #=&gt; true<br>
C.include?(A) #=&gt; true<br>
A.include?(A) #=&gt; false</span></p></li><li id="iesucks-ud" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
chop!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ud</span> <span class="TermText qDef lang-en">Processes str as for String#chop, returning<br>
str, or nil if str is the empty string. See<br>
also String#chomp!.</span></p></li><li id="iesucks-ne" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
squeeze([other_str]*)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ne</span> <span class="TermText qDef lang-en">Builds a set of characters from the other_str parameter(s) using<br>
the procedure described for String#count. Returns a new string<br>
where runs of the same character that occur in this set are replaced by a<br>
single character. If no arguments are given, all runs of identical<br>
characters are replaced by a single character.<br>
<br>
"yellow moon".squeeze #=&gt; "yelow mon"<br>
" now is the".squeeze(" ") #=&gt; " now is the"<br>
"putters shoot balls".squeeze("m-z") #=&gt; "puters shot balls"</span></p></li><li id="iesucks-pn" class="wrong-q"><b> <span class="TermText qWord lang-math">BASICOBJECT<br>
equal?(other)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pn</span> <span class="TermText qDef lang-en">Equality — At the Object level, == returns<br>
true only if obj and other are the<br>
same object. Typically, this method is overridden in descendant classes to<br>
provide class-specific meaning.<br>
<br>
obj = "a"<br>
other = obj.dup<br>
<br>
a == other #=&gt; true<br>
a.equal? other #=&gt; false<br>
a.equal? a #=&gt; true</span></p></li><li id="iesucks-he" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
to_int</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">he</span> <span class="TermText qDef lang-en">Returns flt truncated to an Integer.</span></p></li><li id="iesucks-by" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
new(str="")</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">by</span> <span class="TermText qDef lang-en">Returns a new string object containing a copy of str.</span></p></li><li id="iesucks-et" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
hash</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">et</span> <span class="TermText qDef lang-en">Produce a hash based on the text and options of this regular expression.</span></p></li><li id="iesucks-wp" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
mktime(year)<br>
mktime(year, month)<br>
mktime(year, month, day)<br>
mktime(year, month, day, hour)<br>
mktime(year, month, day, hour, min)<br>
mktime(year, month, day, hour, min, sec_with_frac)<br>
mktime(year, month, day, hour, min, sec, usec_with_frac)<br>
mktime(sec, min, hour, day, month, year, wday, yday, isdst, tz)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wp</span> <span class="TermText qDef lang-en">Same as ::gm, but interprets the values<br>
in the local time zone.<br>
<br>
Time.local(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 -0600</span></p></li><li id="iesucks-rw" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
read</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rw</span> <span class="TermText qDef lang-en">Reads the next entry from dir and returns it as a string. Returns<br>
nil at the end of the stream.<br>
<br>
d = Dir.new("testdir")<br>
d.read #=&gt; "."<br>
d.read #=&gt; ".."<br>
d.read #=&gt; "config.h"</span></p></li><li id="iesucks-fb" class="wrong-q"><b> <span class="TermText qWord lang-math">COMPARABLE<br>
between?(min, max)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fb</span> <span class="TermText qDef lang-en">Returns false if obj &lt;=&gt;<br>
min is less than zero or if anObject<br>
&lt;=&gt; max is greater than zero, true<br>
otherwise.<br>
<br>
3.between?(1, 5) #=&gt; true<br>
6.between?(1, 5) #=&gt; false<br>
'cat'.between?('ant', 'dog') #=&gt; true<br>
'gnu'.between?('ant', 'dog') #=&gt; false</span></p></li><li id="iesucks-pm" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
fnmatch?( pattern, path, [flags] )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pm</span> <span class="TermText qDef lang-en">Returns true if path matches against pattern The pattern<br>
is not a regular expression; instead it follows rules similar to shell<br>
filename globbing. It may contain the following metacharacters:<br>
<br>
File.fnmatch('cat', 'cat') #=&gt; true # match entire string<br>
File.fnmatch('cat', 'category') #=&gt; false # only match partial string<br>
<br>
File.fnmatch('c{at,ub}s', 'cats') #=&gt; false # { } isn't supported by default<br>
File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=&gt; true # { } is supported on FNM_EXTGLOB<br>
<br>
File.fnmatch('c?t', 'cat') #=&gt; true # '?' match only 1 character<br>
File.fnmatch('c??t', 'cat') #=&gt; false # ditto<br>
File.fnmatch('c<b>', 'cats') #=&gt; true # '</b>' match 0 or more characters<br>
File.fnmatch('c*t', 'c/a/b/t') #=&gt; true # ditto<br>
File.fnmatch('ca[a-z]', 'cat') #=&gt; true # inclusive bracket expression<br>
File.fnmatch('ca[^t]', 'cat') #=&gt; false # exclusive bracket expression ('^' or '!')<br>
<br>
File.fnmatch('cat', 'CAT') #=&gt; false # case sensitive<br>
File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=&gt; true # case insensitive<br>
<br>
File.fnmatch('?', '/', File::FNM_PATHNAME) #=&gt; false # wildcard doesn't match '/' on FNM_PATHNAME<br>
File.fnmatch('*', '/', File::FNM_PATHNAME) #=&gt; false # ditto<br>
File.fnmatch('[/]', '/', File::FNM_PATHNAME) #=&gt; false # ditto<br>
<br>
File.fnmatch('\?', '?') #=&gt; true # escaped wildcard becomes ordinary<br>
File.fnmatch('\a', 'a') #=&gt; true # escaped ordinary remains ordinary<br>
File.fnmatch('\a', '\a', File::FNM_NOESCAPE) #=&gt; true # FNM_NOESCAPE makes '\' ordinary<br>
File.fnmatch('[\?]', '?') #=&gt; true # can escape inside bracket expression<br>
<br>
File.fnmatch('*', '.profile') #=&gt; false # wildcard doesn't match leading<br>
File.fnmatch('*', '.profile', File::FNM_DOTMATCH) #=&gt; true # period by default.<br>
File.fnmatch('.*', '.profile') #=&gt; true<br>
<br>
rbfiles = '*<b>' '/' '</b>.rb' # you don't have to do like this. just write in single string.<br>
File.fnmatch(rbfiles, 'main.rb') #=&gt; false<br>
File.fnmatch(rbfiles, './main.rb') #=&gt; false<br>
File.fnmatch(rbfiles, 'lib/song.rb') #=&gt; true<br>
File.fnmatch('**.rb', 'main.rb') #=&gt; true<br>
File.fnmatch('**.rb', './main.rb') #=&gt; false<br>
File.fnmatch('**.rb', 'lib/song.rb') #=&gt; true<br>
File.fnmatch('*', 'dave/.profile') #=&gt; true<br>
<br>
pattern = '<b>' '/' '</b>'<br>
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME) #=&gt; false<br>
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=&gt; true<br>
<br>
pattern = '**' '/' 'foo'<br>
File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME) #=&gt; true<br>
File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME) #=&gt; true<br>
File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME) #=&gt; true<br>
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME) #=&gt; false<br>
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=&gt; true</span></p></li><li id="iesucks-wy" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
throw(tag [, obj])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wy</span> <span class="TermText qDef lang-en">Transfers control to the end of the active catch block waiting<br>
for tag. Raises ArgumentError if there is no<br>
catch block for the tag. The optional second<br>
parameter supplies a return value for the catch block, which<br>
otherwise defaults to nil. For examples, see<br>
Kernel::catch.</span></p></li><li id="iesucks-au" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
hash</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">au</span> <span class="TermText qDef lang-en">Generates a Fixnum hash value for this object. <br>
This function must have the property that a.eql?(b) implies<br>
a.hash == b.hash.</span></p></li><li id="iesucks-se" class="wrong-q"><b> <span class="TermText qWord lang-math">CLASS<br>
allocate()</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">se</span> <span class="TermText qDef lang-en">Allocates space for a new object of class's class and does not<br>
call initialize on the new instance. The returned object must be an<br>
instance of class.<br>
<br>
klass = Class.new do<br>
 def initialize(*args)<br>
 @initialized = true<br>
 end<br>
<br>
 def initialized?<br>
 @initialized || false<br>
 end<br>
end<br>
<br>
klass.allocate.initialized? #=&gt; false</span></p></li><li id="iesucks-jg" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
new<br>
new(obj)<br>
new {|hash, key| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jg</span> <span class="TermText qDef lang-en">Returns a new, empty hash. If this hash is subsequently accessed by a key<br>
that doesn't correspond to a hash entry, the value returned depends on the<br>
style of new used to create the hash. In the first form, the<br>
access returns nil. If obj is specified, this single<br>
object will be used for all default values. If a block is<br>
specified, it will be called with the hash object and the key, and should<br>
return the default value. It is the block's responsibility to store the<br>
value in the hash if required.<br>
<br>
h = Hash.new("Go Fish")<br>
h["a"] = 100<br>
h["b"] = 200<br>
h["a"] #=&gt; 100<br>
h["c"] #=&gt; "Go Fish"<br>
# The following alters the single default object<br>
h["c"].upcase! #=&gt; "GO FISH"<br>
h["d"] #=&gt; "GO FISH"<br>
h.keys #=&gt; ["a", "b"]<br>
<br>
# While this creates a new default object each time<br>
h = Hash.new { |hash, key| hash[key] = "Go Fish: #{key}" }<br>
h["c"] #=&gt; "Go Fish: c"<br>
h["c"].upcase! #=&gt; "GO FISH: C"<br>
h["d"] #=&gt; "Go Fish: d"<br>
h.keys #=&gt; ["c", "d"]</span></p></li><li id="iesucks-lo" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
rassoc(obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lo</span> <span class="TermText qDef lang-en">Searches through the array whose elements are also arrays.<br>
<br>
a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]<br>
a.rassoc("two") #=&gt; [2, "two"]<br>
a.rassoc("four") #=&gt; nil</span></p></li><li id="iesucks-ob" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
load(filename, wrap=false)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ob</span> <span class="TermText qDef lang-en">Loads and executes the Ruby program in the file filename. If the<br>
filename does not resolve to an absolute path, the file is searched for in<br>
the library directories listed in $:. If the optional<br>
wrap parameter is true, the loaded script will be<br>
executed under an anonymous module, protecting the calling program's global<br>
namespace. In no circumstance will any local variables in the loaded file<br>
be propagated to the loading environment.</span></p></li><li id="iesucks-nt" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
each_slice(n) { ... }<br>
each_slice(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nt</span> <span class="TermText qDef lang-en">Iterates the given block for each slice of &lt;n&gt; elements. If no block<br>
is given, returns an enumerator.<br>
<br>
(1..10).each_slice(3) { |a| p a }<br>
# outputs below<br>
[1, 2, 3]<br>
[4, 5, 6]<br>
[7, 8, 9]<br>
[10]</span></p></li><li id="iesucks-ki" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
dup</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ki</span> <span class="TermText qDef lang-en">Produces a shallow copy of obj—the instance variables of<br>
obj are copied, but not the objects they reference.<br>
dup copies the tainted state of obj. See also the<br>
discussion under Object#clone. In general, clone<br>
and dup may have different semantics in descendant classes.<br>
While clone is used to duplicate an object, including its<br>
internal state, dup typically uses the class of the descendant<br>
object to create the new instance.</span></p></li><li id="iesucks-wl" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
Array(arg)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wl</span> <span class="TermText qDef lang-en">Returns arg as an Array.<br>
<br>
Array(1..5) #=&gt; [1, 2, 3, 4, 5]</span></p></li><li id="iesucks-pj" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
instance_variables</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pj</span> <span class="TermText qDef lang-en">Returns an array of instance variable names for the receiver. Note that<br>
simply defining an accessor does not create the corresponding instance<br>
variable.<br>
<br>
class Fred<br>
 attr_accessor :a1<br>
 def initialize<br>
 @iv = 3<br>
 end<br>
end<br>
Fred.new.instance_variables #=&gt; [:@iv]</span></p></li><li id="iesucks-tm" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
rstrip!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tm</span> <span class="TermText qDef lang-en">Removes trailing whitespace from str, returning nil<br>
if no change was made. See also String#lstrip! and<br>
String#strip!.<br>
<br>
" hello ".rstrip #=&gt; " hello"<br>
"hello".rstrip! #=&gt; nil</span></p></li><li id="iesucks-oi" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
ancestors</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">oi</span> <span class="TermText qDef lang-en">Returns a list of modules included in mod (including mod<br>
itself).<br>
<br>
module Mod<br>
 include Math<br>
 include Comparable<br>
end<br>
<br>
Mod.ancestors #=&gt; [Mod, Comparable, Math]<br>
Math.ancestors #=&gt; [Math]</span></p></li><li id="iesucks-jy" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
chop</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jy</span> <span class="TermText qDef lang-en">Equivalent to ($_.dup).chop!, except nil is never<br>
returned. See String#chop!. Available only when -p/-n command<br>
line option specified.</span></p></li><li id="iesucks-q" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fix numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">q</span> <span class="TermText qDef lang-en">Comparison—Returns -1, 0, +1 or nil depending on whether fix<br>
is less than, equal to, or greater than numeric. This is the<br>
basis for the tests in Comparable.</span></p></li><li id="iesucks-fm" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
pos = integer</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fm</span> <span class="TermText qDef lang-en">Synonym for Dir#seek, but returns the position parameter.<br>
<br>
d = Dir.new("testdir") #=&gt; #&lt;Dir:0x401b3c40&gt;<br>
d.read #=&gt; "."<br>
i = d.pos #=&gt; 12<br>
d.read #=&gt; ".."<br>
d.pos = i #=&gt; 12<br>
d.read #=&gt; ".."</span></p></li><li id="iesucks-tj" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
min</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tj</span> <span class="TermText qDef lang-en">Returns the minute of the hour (0..59) for time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:25:51 -0600<br>
t.min #=&gt; 25</span></p></li><li id="iesucks-ss" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
lstat(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ss</span> <span class="TermText qDef lang-en">Same as File::stat, but does not follow the last symbolic<br>
link. Instead, reports on the link itself.<br>
<br>
File.symlink("testfile", "link2test") #=&gt; 0<br>
File.stat("testfile").size #=&gt; 66<br>
File.lstat("link2test").size #=&gt; 8<br>
File.stat("link2test").size #=&gt; 66</span></p></li><li id="iesucks-vp" class="wrong-q"><b> <span class="TermText qWord lang-math">PROC<br>
hash</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vp</span> <span class="TermText qDef lang-en">Returns a hash value corresponding to proc body.</span></p></li><li id="iesucks-ox" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
upto(limit) {|i| block }<br>
upto(limit)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ox</span> <span class="TermText qDef lang-en">Iterates block, passing in integer values from int up to<br>
and including limit.<br>
<br>
5.upto(10) { |i| print i, " " }</span></p></li><li id="iesucks-ai" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
lineno = integer</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ai</span> <span class="TermText qDef lang-en">Manually sets the current line number to the given value. $.<br>
is updated only on the next read.<br>
<br>
f = File.new("testfile")<br>
f.gets #=&gt; "This is line one\n"<br>
$. #=&gt; 1<br>
f.lineno = 1000<br>
f.lineno #=&gt; 1000<br>
$. #=&gt; 1 # lineno of last read<br>
f.gets #=&gt; "This is line two\n"<br>
$. #=&gt; 1001 # lineno of last read</span></p></li><li id="iesucks-jr" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
length</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jr</span> <span class="TermText qDef lang-en">Returns the number of elements in self. May be zero.<br>
<br>
[ 1, 2, 3, 4, 5 ].length #=&gt; 5<br>
[].length #=&gt; 0</span></p></li><li id="iesucks-bm" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
inspect</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bm</span> <span class="TermText qDef lang-en">Returns a string representing time. Equivalent to calling strftime with the appropriate format<br>
string.<br>
<br>
t = Time.now<br>
t.to_s =&gt; "2012-11-10 18:16:12 +0100"<br>
t.strftime "%Y-%m-%d %H:%M:%S %z" =&gt; "2012-11-10 18:16:12 +0100"<br>
<br>
t.utc.to_s =&gt; "2012-11-10 17:16:12 UTC"<br>
t.strftime "%Y-%m-%d %H:%M:%S UTC" =&gt; "2012-11-10 17:16:12 UTC"</span></p></li><li id="iesucks-ky" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
tr_s!(from_str, to_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ky</span> <span class="TermText qDef lang-en">Performs String#tr_s processing on str in place,<br>
returning str, or nil if no changes were made.</span></p></li><li id="iesucks-km" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
succ!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">km</span> <span class="TermText qDef lang-en">Equivalent to String#succ, but modifies the receiver in place.</span></p></li><li id="iesucks-fp" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
argv</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fp</span> <span class="TermText qDef lang-en">Returns the ARGV array, which contains the arguments passed to<br>
your script, one per element.<br>
<br>
$ ruby argf.rb -v glark.txt<br>
<br>
ARGF.argv #=&gt; ["-v", "glark.txt"]</span></p></li><li id="iesucks-ep" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
each_value {| value | block }<br>
each_value</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ep</span> <span class="TermText qDef lang-en">Calls block once for each key in hsh, passing the value<br>
as a parameter.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.each_value {|value| puts value }</span></p></li><li id="iesucks-uz" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
warn(msg, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uz</span> <span class="TermText qDef lang-en">Displays each of the given messages followed by a record separator on<br>
STDERR unless warnings have been disabled (for example with the<br>
-W0 flag).<br>
<br>
 warn("warning 1", "warning 2")<br>
<br>
&lt;em&gt;produces:&lt;/em&gt;<br>
<br>
 warning 1<br>
 warning 2</span></p></li><li id="iesucks-tr" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
to_s<br>
to_str</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tr</span> <span class="TermText qDef lang-en">Returns the receiver.</span></p></li><li id="iesucks-nj" class="wrong-q"><b> <span class="TermText qWord lang-math">RANDOM<br>
rand<br>
rand(max)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nj</span> <span class="TermText qDef lang-en">Alias of Random::DEFAULT.rand.</span></p></li><li id="iesucks-dn" class="wrong-q"><b> <span class="TermText qWord lang-math">CLASS<br>
new(super_class=Object)<br>
new(super_class=Object) { |mod| ... }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dn</span> <span class="TermText qDef lang-en">Creates a new anonymous (unnamed) class with the given superclass (or<br>
Object if no parameter is given). You can give a class a name<br>
by assigning the class object to a constant.<br>
<br>
fred = Class.new do<br>
 def meth1<br>
 "hello"<br>
 end<br>
 def meth2<br>
 "bye"<br>
 end<br>
end<br>
<br>
a = fred.new #=&gt; #&lt;#&lt;Class:0x100381890&gt;:0x100376b98&gt;<br>
a.meth1 #=&gt; "hello"<br>
a.meth2 #=&gt; "bye"</span></p></li><li id="iesucks-en" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
obj === other</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">en</span> <span class="TermText qDef lang-en">Case Equality - For class Object, effectively the<br>
same as calling #==, but typically overridden by descendants<br>
to provide meaningful semantics in case statements.</span></p></li><li id="iesucks-ln" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
public_instance_methods(include_super=true)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ln</span> <span class="TermText qDef lang-en">Returns a list of the public instance methods defined in mod. If<br>
the optional parameter is not false, the methods of any<br>
ancestors are included.</span></p></li><li id="iesucks-hv" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
ios <br>
 <br>
 click to toggle source</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hv</span> <span class="TermText qDef lang-en">String Output---Writes obj to<br>
ios. obj will be converted to a string using<br>
to_s.<br>
<br>
$stdout &lt;&lt; "Hello " &lt;&lt; "world!\n"</span></p></li><li id="iesucks-pi" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
map { |item| block }<br>
map</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pi</span> <span class="TermText qDef lang-en">Invokes the given block once for each element of self.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.map { |x| x + "!" } #=&gt; ["a!", "b!", "c!", "d!"]<br>
a #=&gt; ["a", "b", "c", "d"]</span></p></li><li id="iesucks-on" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
inspect<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">on</span> <span class="TermText qDef lang-en">Creates a string representation of self.<br>
<br>
[ "a", "b", "c" ].to_s #=&gt; "[\"a\", \"b\", \"c\"]"</span></p></li><li id="iesucks-aj" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
seek( integer )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">aj</span> <span class="TermText qDef lang-en">Seeks to a particular location in dir. integer must be a<br>
value returned by Dir#tell.<br>
<br>
d = Dir.new("testdir") #=&gt; #&lt;Dir:0x401b3c40&gt;<br>
d.read #=&gt; "."<br>
i = d.tell #=&gt; 12<br>
d.read #=&gt; ".."<br>
d.seek(i) #=&gt; #&lt;Dir:0x401b3c40&gt;<br>
d.read #=&gt; ".."</span></p></li><li id="iesucks-jl" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
localtime<br>
localtime(utc_offset)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jl</span> <span class="TermText qDef lang-en">Converts time to local time (using the local time zone in effect<br>
for this process) modifying the receiver.<br>
<br>
t = Time.utc(2000, "jan", 1, 20, 15, 1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.utc? #=&gt; true<br>
<br>
t.localtime #=&gt; 2000-01-01 14:15:01 -0600<br>
t.utc? #=&gt; false<br>
<br>
t.localtime("+09:00") #=&gt; 2000-01-02 05:15:01 +0900<br>
t.utc? #=&gt; false</span></p></li><li id="iesucks-rt" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
group_by { |obj| block }<br>
group_by</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rt</span> <span class="TermText qDef lang-en">Groups the collection by result of the block. Returns a hash where the<br>
keys are the evaluated result from the block and the values are arrays of<br>
elements in the collection that correspond to the key.<br>
<br>
(1..6).group_by { |i| i%3 } #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</span></p></li><li id="iesucks-s" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
extend_object(obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">s</span> <span class="TermText qDef lang-en">Extends the specified object by adding this module's constants and methods<br>
(which are added as singleton methods). This is the callback method used by<br>
Object#extend.<br>
<br>
module Picky<br>
 def Picky.extend_object(o)<br>
 if String === o<br>
 puts "Can't add Picky to a String"<br>
 else<br>
 puts "Picky added to #{o.class}"<br>
 super<br>
 end<br>
 end<br>
end<br>
(s = Array.new).extend Picky # Call Object.extend<br>
(s = "quick brown fox").extend Picky</span></p></li><li id="iesucks-iw" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
empty?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">iw</span> <span class="TermText qDef lang-en">Returns true if hsh contains no key-value pairs.<br>
<br>
{}.empty? #=&gt; true</span></p></li><li id="iesucks-ew" class="wrong-q"><b> <span class="TermText qWord lang-math">NUMERIC<br>
abs</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ew</span> <span class="TermText qDef lang-en">Returns the absolute value of num.<br>
<br>
12.abs #=&gt; 12<br>
(-34.56).abs #=&gt; 34.56<br>
-34.56.abs #=&gt; 34.56</span></p></li><li id="iesucks-js" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
even?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">js</span> <span class="TermText qDef lang-en">Returns true if big is an even number.</span></p></li><li id="iesucks-vk" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
untrust</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vk</span> <span class="TermText qDef lang-en">Mark the object as untrusted.</span></p></li><li id="iesucks-jv" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
inspect",<br>
"FIXNUM<br>
magnitude</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jv</span> <span class="TermText qDef lang-en">Returns the absolute value of fix.<br>
<br>
-12345.abs #=&gt; 12345<br>
12345.abs #=&gt; 12345</span></p></li><li id="iesucks-rr" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
spawn([env,] command... [,options])<br>
spawn([env,] command... [,options])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rr</span> <span class="TermText qDef lang-en">spawn executes specified command and return its pid.<br>
<br>
env: hash<br>
 name =&gt; val : set the environment variable<br>
 name =&gt; nil : unset the environment variable<br>
command...:<br>
 commandline : command line string which is passed to the standard shell<br>
 cmdname, arg1, ... : command name and one or more arguments (no shell)<br>
 [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)<br>
options: hash<br>
 clearing environment variables:<br>
 :unsetenv_others =&gt; true : clear environment variables except specified by env<br>
 :unsetenv_others =&gt; false : don't clear (default)<br>
 process group:<br>
 :pgroup =&gt; true or 0 : make a new process group<br>
 :pgroup =&gt; pgid : join to specified process group<br>
 :pgroup =&gt; nil : don't change the process group (default)<br>
 create new process group: Windows only<br>
 :new_pgroup =&gt; true : the new process is the root process of a new process group<br>
 :new_pgroup =&gt; false : don't create a new process group (default)<br>
 resource limit: resourcename is core, cpu, data, etc. See Process.setrlimit.<br>
 :rlimit_resourcename =&gt; limit<br>
 :rlimit_resourcename =&gt; [cur_limit, max_limit]<br>
 umask:<br>
 :umask =&gt; int<br>
 redirection:<br>
 key:<br>
 FD : single file descriptor in child process<br>
 [FD, FD, ...] : multiple file descriptor in child process<br>
 value:<br>
 FD : redirect to the file descriptor in parent process<br>
 string : redirect to file with open(string, "r" or "w")<br>
 [string] : redirect to file with open(string, File::RDONLY)<br>
 [string, open_mode] : redirect to file with open(string, open_mode, 0644)<br>
 [string, open_mode, perm] : redirect to file with open(string, open_mode, perm)<br>
 [:child, FD] : redirect to the redirected file descriptor<br>
 :close : close the file descriptor in child process<br>
 FD is one of follows<br>
 :in : the file descriptor 0 which is the standard input<br>
 :out : the file descriptor 1 which is the standard output<br>
 :err : the file descriptor 2 which is the standard error<br>
 integer : the file descriptor of specified the integer<br>
 io : the file descriptor specified as io.fileno<br>
 file descriptor inheritance: close non-redirected non-standard fds (3, 4, 5, ...) or not<br>
 :close_others =&gt; true : don't inherit<br>
 current directory:<br>
 :chdir =&gt; str</span></p></li><li id="iesucks-aw" class="wrong-q"><b> <span class="TermText qWord lang-math">FILETEST<br>
socket?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">aw</span> <span class="TermText qDef lang-en">Returns true if the named file is a socket.</span></p></li><li id="iesucks-dr" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
size</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dr</span> <span class="TermText qDef lang-en">Returns the size of stat in bytes.<br>
<br>
File.stat("testfile").size #=&gt; 66</span></p></li><li id="iesucks-ag" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
write(name, string, [offset] ) =&gt; fixnum<br>
write(name, string, [offset], open_args ) =&gt; fixnum</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ag</span> <span class="TermText qDef lang-en">Opens the file, optionally seeks to the given offset, writes<br>
string, then returns the length written. write<br>
ensures the file is closed before returning. If offset is not<br>
given, the file is truncated. Otherwise, it is not truncated.<br>
<br>
encoding: string or encoding<br>
<br>
 specifies encoding of the read string. encoding will be ignored<br>
 if length is specified.<br>
<br>
mode: string<br>
<br>
 specifies mode argument for open(). it should start with "w" or "a" or "r+"<br>
 otherwise it would cause error.<br>
<br>
perm: fixnum<br>
<br>
 specifies perm argument for open().<br>
<br>
open_args: array<br>
<br>
 specifies arguments for open() as an array.<br>
<br>
 IO.write("testfile", "0123456789", 20) # =&gt; 10<br>
 # File could contain: "This is line one\nThi0123456789two\nThis is line three\nAnd so on...\n"<br>
 IO.write("testfile", "0123456789") #=&gt; 10<br>
 # File would now read: "0123456789"</span></p></li><li id="iesucks-no" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
tell</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">no</span> <span class="TermText qDef lang-en">Returns the current position in dir. See also<br>
Dir#seek.<br>
<br>
d = Dir.new("testdir")<br>
d.tell #=&gt; 0<br>
d.read #=&gt; "."<br>
d.tell #=&gt; 12</span></p></li><li id="iesucks-ng" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
readchar</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ng</span> <span class="TermText qDef lang-en">Reads a one-character string from ios. Raises an<br>
EOFError on end of file.<br>
<br>
f = File.new("testfile")<br>
f.readchar #=&gt; "h"<br>
f.readchar #=&gt; "e"</span></p></li><li id="iesucks-iq" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
to_a</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">iq</span> <span class="TermText qDef lang-en">Returns a ten-element array of values for time:<br>
<br>
[sec, min, hour, day, month, year, wday, yday, isdst, zone]</span></p></li><li id="iesucks-tb" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
day</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tb</span> <span class="TermText qDef lang-en">Returns the day of the month (1..n) for time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:27:03 -0600<br>
t.day #=&gt; 19<br>
t.mday #=&gt; 19</span></p></li><li id="iesucks-pp" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
directory?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pp</span> <span class="TermText qDef lang-en">Returns true if the named file is a directory, or a symlink<br>
that points at a directory, and false otherwise.<br>
<br>
File.directory?(".")</span></p></li><li id="iesucks-fu" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
casecmp(other_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fu</span> <span class="TermText qDef lang-en">Case-insensitive version of String#&lt;=&gt;.<br>
<br>
"abcdef".casecmp("abcde") #=&gt; 1<br>
"aBcDeF".casecmp("abcdef") #=&gt; 0<br>
"abcdef".casecmp("abcdefg") #=&gt; -1<br>
"abcdef".casecmp("ABCDEF") #=&gt; 0</span></p></li><li id="iesucks-lm" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
rjust(integer, padstr=' ')</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lm</span> <span class="TermText qDef lang-en">If integer is greater than the length of str, returns a<br>
new String of length integer with str right<br>
justified and padded with padstr; otherwise, returns str.<br>
<br>
"hello".rjust(4) #=&gt; "hello"<br>
"hello".rjust(20) #=&gt; " hello"<br>
"hello".rjust(20, '1234') #=&gt; "123412341234123hello"</span></p></li><li id="iesucks-ue" class="wrong-q"><b> <span class="TermText qWord lang-math">EXCEPTION<br>
new(msg = nil)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ue</span> <span class="TermText qDef lang-en">Construct a new Exception object, optionally<br>
passing in a message.</span></p></li><li id="iesucks-kw" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
external_encoding</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kw</span> <span class="TermText qDef lang-en">Returns the Encoding object that represents the<br>
encoding of the file. If io is write mode and no encoding is specified,<br>
returns nil.</span></p></li><li id="iesucks-pb" class="wrong-q"><b> <span class="TermText qWord lang-math">FLOAT<br>
floor</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pb</span> <span class="TermText qDef lang-en">Returns the largest integer less than or equal to flt.<br>
<br>
1.2.floor #=&gt; 1<br>
2.0.floor #=&gt; 2<br>
(-1.2).floor #=&gt; -2<br>
(-2.0).floor #=&gt; -2</span></p></li><li id="iesucks-th" class="wrong-q"><b> <span class="TermText qWord lang-math">EXCEPTION<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">th</span> <span class="TermText qDef lang-en">Returns exception's message (or the name of the exception if no message is<br>
set).</span></p></li><li id="iesucks-bb" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
size</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bb</span> <span class="TermText qDef lang-en">Returns the number of bytes in the machine representation of a<br>
Fixnum.<br>
<br>
1.size #=&gt; 4<br>
-1.size #=&gt; 4<br>
2147483647.size #=&gt; 4</span></p></li><li id="iesucks-pt" class="wrong-q"><b> <span class="TermText qWord lang-math">ENV<br>
size</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pt</span> <span class="TermText qDef lang-en">Returns the number of environment variables.</span></p></li><li id="iesucks-ix" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
new(filename, mode="r" [, opt])<br>
new(filename [, mode [, perm]] [, opt])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ix</span> <span class="TermText qDef lang-en">Opens the file named by filename according to the given<br>
mode and returns a new File object.<br>
<br>
f = File.new("testfile", "r")<br>
f = File.new("newfile", "w+")<br>
f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)</span></p></li><li id="iesucks-rf" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
delete_if {| key, value | block }<br>
delete_if</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rf</span> <span class="TermText qDef lang-en">Deletes every key-value pair from hsh for which block<br>
evaluates to true.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }<br>
h.delete_if {|key, value| key &gt;= "b" } #=&gt; {"a"=&gt;100}</span></p></li><li id="iesucks-gw" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
time - other_time<br>
time - numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gw</span> <span class="TermText qDef lang-en">Difference — Returns a new Time object that<br>
represents the difference between time and<br>
other_time, or subtracts the given number of seconds in<br>
numeric from time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:23:10 -0600<br>
t2 = t + 2592000 #=&gt; 2007-12-19 08:23:10 -0600<br>
t2 - t #=&gt; 2592000.0<br>
t2 - 2592000 #=&gt; 2007-11-19 08:23:10 -0600</span></p></li><li id="iesucks-fi" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
select {|key, value| block}<br>
select</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fi</span> <span class="TermText qDef lang-en">Returns a new hash consisting of entries for which the block returns true.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }<br>
h.select {|k,v| k &gt; "a"} #=&gt; {"b" =&gt; 200, "c" =&gt; 300}<br>
h.select {|k,v| v &lt; 200} #=&gt; {"a" =&gt; 100}</span></p></li><li id="iesucks-rc" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
file</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rc</span> <span class="TermText qDef lang-en">Returns the current file as an IO or File object.<br>
#&lt;IO:&lt;STDIN&gt;&gt; is returned when the current file is STDIN.<br>
<br>
$ echo "foo" &gt; foo<br>
$ echo "bar" &gt; bar<br>
<br>
$ ruby argf.rb foo bar<br>
<br>
ARGF.file #=&gt; #&lt;File:foo&gt;<br>
ARGF.read(5) #=&gt; "foo\nb"<br>
ARGF.file #=&gt; #&lt;File:bar&gt;</span></p></li><li id="iesucks-um" class="wrong-q"><b> <span class="TermText qWord lang-math">EXCEPTION<br>
backtrace</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">um</span> <span class="TermText qDef lang-en">Returns any backtrace associated with the exception. The backtrace is an<br>
array of strings, each containing either "filename:lineNo: in `method"' or<br>
"filename:lineNo."<br>
<br>
def a<br>
 raise "boom"<br>
end<br>
<br>
def b<br>
 a()<br>
end<br>
<br>
begin<br>
 b()<br>
rescue =&gt; detail<br>
 print detail.backtrace.join("\n")<br>
end</span></p></li><li id="iesucks-r" class="wrong-q"><b> <span class="TermText qWord lang-math">TRUECLASS<br>
true ^ obj</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">r</span> <span class="TermText qDef lang-en">Exclusive Or—Returns true if obj is nil<br>
or false, false otherwise.</span></p></li><li id="iesucks-mr" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
atime(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mr</span> <span class="TermText qDef lang-en">Returns the last access time for the named file as a Time object).<br>
<br>
File.atime("testfile") #=&gt; Wed Apr 09 08:51:48 CDT 2003</span></p></li><li id="iesucks-kc" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
chomp<br>
chomp(string)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kc</span> <span class="TermText qDef lang-en">Equivalent to $_ = $_.chomp(string). See<br>
String#chomp. Available only when -p/-n command line option<br>
specified.</span></p></li><li id="iesucks-n" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
zone</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">n</span> <span class="TermText qDef lang-en">Returns the name of the time zone used for time. As of Ruby 1.8,<br>
returns "UTC" rather than "GMT" for UTC times.<br>
<br>
t = Time.gm(2000, "jan", 1, 20, 15, 1)<br>
t.zone #=&gt; "UTC"<br>
t = Time.local(2000, "jan", 1, 20, 15, 1)<br>
t.zone #=&gt; "CST"</span></p></li><li id="iesucks-pl" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
for_fd(fd, mode [, opt])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pl</span> <span class="TermText qDef lang-en">Synonym for IO.new.</span></p></li><li id="iesucks-mj" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
unlink(file_name, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mj</span> <span class="TermText qDef lang-en">Deletes the named files, returning the number of names passed as arguments.<br>
Raises an exception on any error. See also Dir::rmdir.</span></p></li><li id="iesucks-ha" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
downcase</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ha</span> <span class="TermText qDef lang-en">Returns a copy of str with all uppercase letters replaced with<br>
their lowercase counterparts. The operation is locale insensitive—only<br>
characters "A" to "Z" are affected. Note: case replacement is effective<br>
only in ASCII region.<br>
<br>
"hEllO".downcase #=&gt; "hello"</span></p></li><li id="iesucks-fn" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
binmode?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fn</span> <span class="TermText qDef lang-en">For example:<br>
<br>
Returns true if +ARGF+ is being read in binary mode; false otherwise. (To<br>
enable binary mode use +ARGF.binmode+.</span></p></li><li id="iesucks-rl" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
lineno</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rl</span> <span class="TermText qDef lang-en">Returns the current line number of ARGF as a whole.<br>
This value can be set manually with ARGF.lineno=.<br>
<br>
ARGF.lineno #=&gt; 0<br>
ARGF.readline #=&gt; "This is line 1\n"<br>
ARGF.lineno #=&gt; 1</span></p></li><li id="iesucks-hn" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fix ^ integer</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hn</span> <span class="TermText qDef lang-en">Bitwise EXCLUSIVE OR.</span></p></li><li id="iesucks-kv" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
pack ( aTemplateString )</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kv</span> <span class="TermText qDef lang-en">Packs the contents of arr into a binary sequence according to the<br>
directives in aTemplateString (see the table below) Directives<br>
"A," "a," and "Z" may be followed by a count, which gives the width of the<br>
resulting field. The remaining directives also may take a count, indicating<br>
the number of array elements to convert. If the count is an asterisk<br>
("*"), all remaining array elements will be converted. Any of<br>
the directives "sSiIlL" may be followed by an underscore<br>
("_") or exclamation mark ("!") to use the<br>
underlying platform's native size for the specified type; otherwise, they<br>
use a platform-independent size. Spaces are ignored in the template string.<br>
See also String#unpack.<br>
<br>
a = [ "a", "b", "c" ]<br>
n = [ 65, 66, 67 ]<br>
a.pack("A3A3A3") #=&gt; "a b c "<br>
a.pack("a3a3a3") #=&gt; "a\000\000b\000\000c\000\000"<br>
n.pack("ccc") #=&gt; "ABC"</span></p></li><li id="iesucks-mc" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
each_line(sep=$/) {|line| block }<br>
each_line(sep=$/,limit) {|line| block }<br>
each_line(...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">mc</span> <span class="TermText qDef lang-en">Returns an enumerator which iterates over each line (separated by<br>
sep, which defaults to your platform's newline character) of each<br>
file in ARGV. If a block is supplied, each line in turn will<br>
be yielded to the block, otherwise an enumerator is returned. The optional<br>
limit argument is a Fixnum specifying the maximum<br>
length of each line; longer lines will be split according to this limit.<br>
<br>
ARGF.lines do |line|<br>
 puts ARGF.filename if ARGF.lineno == 1<br>
 puts "#{ARGF.lineno}: #{line}"<br>
end</span></p></li><li id="iesucks-pg" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
times {|i| block }<br>
times</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pg</span> <span class="TermText qDef lang-en">Iterates block int times, passing in values from zero to<br>
int - 1.<br>
<br>
5.times do |i|<br>
 print i, " "<br>
end</span></p></li><li id="iesucks-sq" class="wrong-q"><b> <span class="TermText qWord lang-math">MATCHDATA<br>
to_s</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sq</span> <span class="TermText qDef lang-en">Returns the entire matched string.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.to_s #=&gt; "HX1138"</span></p></li><li id="iesucks-cb" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
prepend(module, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cb</span> <span class="TermText qDef lang-en">Invokes Module.prepend_features on each parameter in reverse<br>
order.</span></p></li><li id="iesucks-hc" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
store(key, value)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hc</span> <span class="TermText qDef lang-en">Element Assignment—Associates the value given by value with the<br>
key given by key. key should not have its value changed<br>
while it is in use as a key (a String passed as a key will be<br>
duplicated and frozen).<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h["a"] = 9<br>
h["c"] = 4<br>
h #=&gt; {"a"=&gt;9, "b"=&gt;200, "c"=&gt;4}</span></p></li><li id="iesucks-ok" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
link(old_name, new_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ok</span> <span class="TermText qDef lang-en">Creates a new name for an existing file using a hard link. Will not<br>
overwrite new_name if it already exists (raising a subclass of<br>
SystemCallError). Not available on all platforms.<br>
<br>
File.link("testfile", ".testfile") #=&gt; 0<br>
IO.readlines(".testfile")[0] #=&gt; "This is line one\n"</span></p></li><li id="iesucks-xa" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
fdiv(numeric)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">xa</span> <span class="TermText qDef lang-en">Returns the floating point result of dividing big by<br>
numeric.<br>
<br>
-1234567890987654321.fdiv(13731) #=&gt; -89910996357705.5<br>
-1234567890987654321.fdiv(13731.24) #=&gt; -89909424858035.7</span></p></li><li id="iesucks-rn" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
hash</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rn</span> <span class="TermText qDef lang-en">Compute a hash-code for this array.</span></p></li><li id="iesucks-cc" class="wrong-q"><b> <span class="TermText qWord lang-math">MATCHDATA<br>
to_a</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cc</span> <span class="TermText qDef lang-en">Returns the array of matches.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.to_a #=&gt; ["HX1138", "H", "X", "113", "8"]</span></p></li><li id="iesucks-jk" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
path(path)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jk</span> <span class="TermText qDef lang-en">Returns the string representation of the path<br>
<br>
File.path("/dev/null") #=&gt; "/dev/null"<br>
File.path(Pathname.new("/tmp")) #=&gt; "/tmp"</span></p></li><li id="iesucks-uq" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
readbyte</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">uq</span> <span class="TermText qDef lang-en">Reads the next 8-bit byte from ARGF and returns it<br>
as a Fixnum. Raises an EOFError after the last<br>
byte of the last file has been read.<br>
<br>
$ echo "foo" &gt; file<br>
$ ruby argf.rb file<br>
<br>
ARGF.readbyte #=&gt; 102<br>
ARGF.readbyte #=&gt; 111<br>
ARGF.readbyte #=&gt; 111<br>
ARGF.readbyte #=&gt; 10<br>
ARGF.readbyte #=&gt; end of file reached (EOFError)</span></p></li><li id="iesucks-ka" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
module_exec(arg...) {|var...| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ka</span> <span class="TermText qDef lang-en">Evaluates the given block in the context of the class/module. The method<br>
defined in the block will belong to the receiver.<br>
<br>
class Thing<br>
end<br>
Thing.class_exec{<br>
 def hello() "Hello there!" end<br>
}<br>
puts Thing.new.hello()</span></p></li><li id="iesucks-ek" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
each_cons(n) { ... }<br>
each_cons(n)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ek</span> <span class="TermText qDef lang-en">Iterates the given block for each array of consecutive &lt;n&gt; elements. <br>
If no block is given, returns an enumerator.<br>
<br>
(1..10).each_cons(3) { |a| p a }<br>
# outputs below<br>
[1, 2, 3]<br>
[2, 3, 4]<br>
[3, 4, 5]<br>
[4, 5, 6]<br>
[5, 6, 7]<br>
[6, 7, 8]<br>
[7, 8, 9]<br>
[8, 9, 10]</span></p></li><li id="iesucks-il" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
strip!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">il</span> <span class="TermText qDef lang-en">Removes leading and trailing whitespace from str. Returns<br>
nil if str was not altered.</span></p></li><li id="iesucks-cv" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
to_r</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">cv</span> <span class="TermText qDef lang-en">Returns the value of time as a rational number of seconds since<br>
the Epoch.<br>
<br>
t = Time.now<br>
p t.to_r #=&gt; (1270968792716287611/1000000000)</span></p></li><li id="iesucks-f" class="wrong-q"><b> <span class="TermText qWord lang-math">FILETEST<br>
blockdev?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">f</span> <span class="TermText qDef lang-en">Returns true if the named file is a block device.</span></p></li><li id="iesucks-gp" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
center(width, padstr=' ')</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gp</span> <span class="TermText qDef lang-en">Centers str in width. If width is<br>
greater than the length of str, returns a new String of length width with<br>
str centered and padded with padstr; otherwise,<br>
returns str.<br>
<br>
"hello".center(4) #=&gt; "hello"<br>
"hello".center(20) #=&gt; " hello "<br>
"hello".center(20, '123') #=&gt; "1231231hello12312312"</span></p></li><li id="iesucks-ez" class="wrong-q"><b> <span class="TermText qWord lang-math">BIGNUM<br>
big <br>
 <br>
 click to toggle source</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ez</span> <span class="TermText qDef lang-en">Returns true if the value of big is less than<br>
that of real.</span></p></li><li id="iesucks-dt" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
puts(obj, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">dt</span> <span class="TermText qDef lang-en">Writes the given objects to ios as with IO#print.<br>
Writes a record separator (typically a newline) after any that do not<br>
already end with a newline sequence. If called with an array argument,<br>
writes each element on a new line. If called without arguments, outputs a<br>
single record separator.<br>
<br>
$stdout.puts("this", "is", "a", "test")</span></p></li><li id="iesucks-kt" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fix ** numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">kt</span> <span class="TermText qDef lang-en">Raises fix to the numeric power, which may be<br>
negative or fractional.<br>
<br>
2 ** 3 #=&gt; 8<br>
2 ** -1 #=&gt; (1/2)<br>
2 ** 0.5 #=&gt; 1.4142135623731</span></p></li><li id="iesucks-e" class="wrong-q"><b> <span class="TermText qWord lang-math">FILETEST<br>
exist?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">e</span> <span class="TermText qDef lang-en">Return true if the named file exists.</span></p></li><li id="iesucks-sx" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
singleton_class</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sx</span> <span class="TermText qDef lang-en">Returns the singleton class of obj. This method creates a new<br>
singleton class if obj does not have it.<br>
<br>
Object.new.singleton_class #=&gt; #&lt;Class:#&lt;Object:0xb7ce1e24&gt;&gt;<br>
String.singleton_class #=&gt; #&lt;Class:String&gt;<br>
nil.singleton_class #=&gt; NilClass</span></p></li><li id="iesucks-tl" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
downcase</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tl</span> <span class="TermText qDef lang-en">Same as sym.to_s.downcase.intern.</span></p></li><li id="iesucks-ny" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
clear</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ny</span> <span class="TermText qDef lang-en">Removes all key-value pairs from hsh.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 } #=&gt; {"a"=&gt;100, "b"=&gt;200}<br>
h.clear #=&gt; {}</span></p></li><li id="iesucks-jn" class="wrong-q"><b> <span class="TermText qWord lang-math">MODULE<br>
class_variable_set(symbol, obj)<br>
class_variable_set(string, obj)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jn</span> <span class="TermText qDef lang-en">Sets the class variable names by symbol to object. If the<br>
class variable name is passed as a string, that string is converted to a<br>
symbol.<br>
<br>
class Fred<br>
 @@foo = 99<br>
 def foo<br>
 @@foo<br>
 end<br>
end<br>
Fred.class_variable_set(:@@foo, 101) #=&gt; 101<br>
Fred.new.foo #=&gt; 101</span></p></li><li id="iesucks-qr" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
delete_if { |item| block }<br>
delete_if</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qr</span> <span class="TermText qDef lang-en">Deletes every element of self for which block evaluates to<br>
true.<br>
<br>
scores = [ 97, 42, 75 ]<br>
scores.delete_if {|score| score &lt; 80 } #=&gt; [97]</span></p></li><li id="iesucks-vl" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE<br>
open(filename, mode="r" [, opt])<br>
open(filename [, mode [, perm]] [, opt])<br>
open(filename, mode="r" [, opt]) {|file| block }<br>
open(filename [, mode [, perm]] [, opt]) {|file| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">vl</span> <span class="TermText qDef lang-en">With no associated block, File.open is a synonym for ::new. If the optional code block is<br>
given, it will be passed the opened file as an argument and<br>
the File object will automatically be closed when<br>
the block terminates. The value of the block will be returned from<br>
File.open.</span></p></li><li id="iesucks-qk" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
exec([env,] command... [,options])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">qk</span> <span class="TermText qDef lang-en">Replaces the current process by running the given external<br>
command. command... is one of following forms.<br>
<br>
commandline : command line string which is passed to the standard shell<br>
cmdname, arg1, ... : command name and one or more arguments (no shell)<br>
[cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)</span></p></li><li id="iesucks-er" class="wrong-q"><b> <span class="TermText qWord lang-math">DIR<br>
exist?(file_name)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">er</span> <span class="TermText qDef lang-en">Returns true if the named file is a directory,<br>
false otherwise.</span></p></li><li id="iesucks-wb" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
denominator</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">wb</span> <span class="TermText qDef lang-en">Returns 1.</span></p></li><li id="iesucks-nz" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
min<br>
min { |a, b| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nz</span> <span class="TermText qDef lang-en">Returns the object in enum with the minimum value. The first form<br>
assumes all objects implement Comparable; the second uses the<br>
block to return a &lt;=&gt; b.<br>
<br>
a = %w(albatross dog horse)<br>
a.min #=&gt; "albatross"<br>
a.min { |a, b| a.length &lt;=&gt; b.length } #=&gt; "dog"</span></p></li><li id="iesucks-jp" class="wrong-q"><b> <span class="TermText qWord lang-math">REGEXP<br>
names</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">jp</span> <span class="TermText qDef lang-en">Returns a list of names of captures as an array of strings.<br>
<br>
/(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.names<br>
#=&gt; ["foo", "bar", "baz"]<br>
<br>
/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.names<br>
#=&gt; ["foo"]<br>
<br>
/(.)(.)/.names<br>
#=&gt; []</span></p></li><li id="iesucks-hq" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
is_a?(class)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hq</span> <span class="TermText qDef lang-en">Returns true if class is the class of obj,<br>
or if class is one of the superclasses of obj or modules<br>
included in obj.<br>
<br>
module M; end<br>
class A<br>
 include M<br>
end<br>
class B &lt; A; end<br>
class C &lt; B; end<br>
<br>
b = B.new<br>
b.is_a? A #=&gt; true<br>
b.is_a? B #=&gt; true<br>
b.is_a? C #=&gt; false<br>
b.is_a? M #=&gt; true<br>
<br>
b.kind_of? A #=&gt; true<br>
b.kind_of? B #=&gt; true<br>
b.kind_of? C #=&gt; false<br>
b.kind_of? M #=&gt; true</span></p></li><li id="iesucks-do" class="wrong-q"><b> <span class="TermText qWord lang-math">INTEGER<br>
odd?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">do</span> <span class="TermText qDef lang-en">Returns true if int is an odd number.</span></p></li><li id="iesucks-hu" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
lines</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hu</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_line.</span></p></li><li id="iesucks-lj" class="wrong-q"><b> <span class="TermText qWord lang-math">TIME<br>
yday</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lj</span> <span class="TermText qDef lang-en">Returns an integer representing the day of the year, 1..366.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:32:31 -0600<br>
t.yday #=&gt; 323</span></p></li><li id="iesucks-lz" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
getbyte</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lz</span> <span class="TermText qDef lang-en">Gets the next 8-bit byte (0..255) from ios. Returns<br>
nil if called at end of file.<br>
<br>
f = File.new("testfile")<br>
f.getbyte #=&gt; 84<br>
f.getbyte #=&gt; 104</span></p></li><li id="iesucks-fw" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
next</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fw</span> <span class="TermText qDef lang-en">Returns the successor to str. The successor is calculated by<br>
incrementing characters starting from the rightmost alphanumeric (or the<br>
rightmost character if there are no alphanumerics) in the string.<br>
Incrementing a digit always results in another digit, and incrementing a<br>
letter results in another letter of the same case. Incrementing<br>
nonalphanumerics uses the underlying character set's collating sequence.<br>
<br>
"abcd".succ #=&gt; "abce"<br>
"THX1138".succ #=&gt; "THX1139"<br>
"&lt;&lt;koala&gt;&gt;".succ #=&gt; "&lt;&lt;koalb&gt;&gt;"<br>
"1999zzz".succ #=&gt; "2000aaa"<br>
"ZZZ9999".succ #=&gt; "AAAA0000"<br>
"**<b>".succ #=&gt; "</b>*+"</span></p></li><li id="iesucks-tf" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
popen([env,] cmd, mode="r" [, opt])<br>
popen([env,] cmd, mode="r" [, opt]) {|io| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">tf</span> <span class="TermText qDef lang-en">Runs the specified command as a subprocess; the subprocess's standard input<br>
and output will be connected to the returned IO object.<br>
<br>
cmd:<br>
 "-" : fork<br>
 commandline : command line string which is passed to a shell<br>
 [env, cmdname, arg1, ..., opts] : command name and zero or more arguments (no shell)<br>
 [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)<br>
(env and opts are optional.)</span></p></li><li id="iesucks-od" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
binwrite(name, string, [offset] ) =&gt; fixnum<br>
binwrite(name, string, [offset], open_args ) =&gt; fixnum</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">od</span> <span class="TermText qDef lang-en">Same as IO.write except opening the file in binary mode and<br>
ASCII-8BIT encoding ("wb:ASCII-8BIT").</span></p></li><li id="iesucks-eh" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
sum(n=16)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">eh</span> <span class="TermText qDef lang-en">Returns a basic n-bit checksum of the characters in str,<br>
where n is the optional Fixnum parameter, defaulting<br>
to 16. The result is simply the sum of the binary value of each character<br>
in str modulo 2**n - 1. This is not a particularly<br>
good checksum.</span></p></li><li id="iesucks-ly" class="wrong-q"><b> <span class="TermText qWord lang-math">IO<br>
sysread(maxlen[, outbuf])</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ly</span> <span class="TermText qDef lang-en">Reads maxlen bytes from ios using a low-level read and<br>
returns them as a string. Do not mix with other methods that read from<br>
ios or you may get unpredictable results. If the optional<br>
outbuf argument is present, it must reference a String, which will receive the data. The<br>
outbuf will contain only the received data after the method call<br>
even if it is not empty at the beginning. Raises<br>
SystemCallError on error and EOFError at end of<br>
file.<br>
<br>
f = File.new("testfile")<br>
f.sysread(16) #=&gt; "This is line one"</span></p></li><li id="iesucks-go" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
__id__<br>
object_id</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">go</span> <span class="TermText qDef lang-en">Returns an integer identifier for obj.</span></p></li><li id="iesucks-el" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
upcase</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">el</span> <span class="TermText qDef lang-en">Returns a copy of str with all lowercase letters replaced with<br>
their uppercase counterparts. The operation is locale insensitive—only<br>
characters "a" to "z" are affected. Note: case replacement is effective<br>
only in ASCII region.<br>
<br>
"hEllO".upcase #=&gt; "HELLO"</span></p></li><li id="iesucks-az" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
__method__<br>
__callee__</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">az</span> <span class="TermText qDef lang-en">Returns the name of the current method as a Symbol. If called outside of a method, it returns<br>
nil.</span></p></li><li id="iesucks-ul" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
ctime</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ul</span> <span class="TermText qDef lang-en">Returns the change time for stat (that is, the time directory<br>
information about the file was changed, not the file itself).<br>
<br>
File.stat("testfile").ctime #=&gt; Wed Apr 09 08:53:14 CDT 2003</span></p></li><li id="iesucks-rz" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
select! {| key, value | block }<br>
select!</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">rz</span> <span class="TermText qDef lang-en">Equivalent to Hash#keep_if, but returns nil if no<br>
changes were made.</span></p></li><li id="iesucks-sl" class="wrong-q"><b> <span class="TermText qWord lang-math">ARGF<br>
eof?</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sl</span> <span class="TermText qDef lang-en">Returns true if the current file in ARGF is at end of file,<br>
i.e. it has no data to read. The stream must be opened for reading or an<br>
IOError will be raised.<br>
<br>
$ echo "eof" | ruby argf.rb<br>
<br>
ARGF.eof? #=&gt; false<br>
3.times { ARGF.readchar }<br>
ARGF.eof? #=&gt; false<br>
ARGF.readchar #=&gt; "\n"<br>
ARGF.eof? #=&gt; true</span></p></li><li id="iesucks-fc" class="wrong-q"><b> <span class="TermText qWord lang-math">FILE::STAT<br>
gid</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">fc</span> <span class="TermText qDef lang-en">Returns the numeric group id of the owner of stat.<br>
<br>
File.stat("testfile").gid #=&gt; 500</span></p></li><li id="iesucks-xc" class="wrong-q"><b> <span class="TermText qWord lang-math">SYMBOL<br>
length</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">xc</span> <span class="TermText qDef lang-en">Same as sym.to_s.length.</span></p></li><li id="iesucks-nv" class="wrong-q"><b> <span class="TermText qWord lang-math">STRING<br>
slice!(fixnum)<br>
slice!(fixnum, fixnum)<br>
slice!(range)<br>
slice!(regexp)<br>
slice!(other_str)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">nv</span> <span class="TermText qDef lang-en">Deletes the specified portion from str, and returns the portion<br>
deleted.<br>
<br>
string = "this is a string"<br>
string.slice!(2) #=&gt; "i"<br>
string.slice!(3..6) #=&gt; " is "<br>
string.slice!(/s.*t/) #=&gt; "sa st"<br>
string.slice!("r") #=&gt; "r"<br>
string #=&gt; "thing"</span></p></li><li id="iesucks-hl" class="wrong-q"><b> <span class="TermText qWord lang-math">FIXNUM<br>
fix - numeric</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">hl</span> <span class="TermText qDef lang-en">Performs subtraction: the class of the resulting object depends on the<br>
class of numeric and on the magnitude of the result.</span></p></li><li id="iesucks-iy" class="wrong-q"><b> <span class="TermText qWord lang-math">MATCHDATA<br>
captures</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">iy</span> <span class="TermText qDef lang-en">Returns the array of captures; equivalent to mtch.to_a[1..-1].<br>
<br>
f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures<br>
f1 #=&gt; "H"<br>
f2 #=&gt; "X"<br>
f3 #=&gt; "113"<br>
f4 #=&gt; "8"</span></p></li><li id="iesucks-ca" class="wrong-q"><b> <span class="TermText qWord lang-math">OBJECT<br>
extend(module, ...)</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">ca</span> <span class="TermText qDef lang-en">Adds to obj the instance methods from each module given as a<br>
parameter.<br>
<br>
module Mod<br>
 def hello<br>
 "Hello from Mod.\n"<br>
 end<br>
end<br>
<br>
class Klass<br>
 def hello<br>
 "Hello from Klass.\n"<br>
 end<br>
end<br>
<br>
k = Klass.new<br>
k.hello #=&gt; "Hello from Klass.\n"<br>
k.extend(Mod) #=&gt; #&lt;Klass:0x401b3bc8&gt;<br>
k.hello #=&gt; "Hello from Mod.\n"</span></p></li><li id="iesucks-pf" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
uniq!<br>
uniq! { |item| ... }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pf</span> <span class="TermText qDef lang-en">Removes duplicate elements from self.<br>
<br>
a = [ "a", "a", "b", "b", "c" ]<br>
a.uniq! # =&gt; ["a", "b", "c"]<br>
<br>
b = [ "a", "b", "c" ]<br>
b.uniq! # =&gt; nil<br>
<br>
c = [["student^!^sam"], ["student^!^george"], ["teacher^!^matz"]]<br>
c.uniq! { |s| s.first } # =&gt; [["student", "sam"], ["teacher", "matz"]]</span></p></li><li id="iesucks-pw" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
one? [{ |obj| block }]</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">pw</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block returns true exactly<br>
once. If the block is not given, one? will return<br>
true only if exactly one of the collection members is true.<br>
<br>
%w{ant bear cat}.one? { |word| word.length == 4 } #=&gt; true<br>
%w{ant bear cat}.one? { |word| word.length &gt; 4 } #=&gt; false<br>
%w{ant bear cat}.one? { |word| word.length &lt; 4 } #=&gt; false<br>
[ nil, true, 99 ].one? #=&gt; false<br>
[ nil, true, false ].one? #=&gt; true</span></p></li><li id="iesucks-lq" class="wrong-q"><b> <span class="TermText qWord lang-math">KERNEL<br>
catch([arg]) {|tag| block }</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">lq</span> <span class="TermText qDef lang-en">catch executes its block. If a throw is executed,<br>
Ruby searches up its stack for a catch block with a tag<br>
corresponding to the throw's tag. If found, that<br>
block is terminated, and catch returns the value given to<br>
throw. If throw is not called, the block<br>
terminates normally, and the value of catch is the value of<br>
the last expression evaluated. catch expressions may be<br>
nested, and the throw call need not be in lexical scope.<br>
<br>
def routine(n)<br>
 puts n<br>
 throw :done if n &lt;= 0<br>
 routine(n-1)<br>
end<br>
<br>
catch(:done) { routine(3) }</span></p></li><li id="iesucks-gy" class="wrong-q"><b> <span class="TermText qWord lang-math">ENUMERABLE<br>
entries</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">gy</span> <span class="TermText qDef lang-en">Returns an array containing the items in enum.<br>
<br>
(1..7).to_a #=&gt; [1, 2, 3, 4, 5, 6, 7]<br>
{ 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a #=&gt; [["a", 1], ["b", 2], ["c", 3]]</span></p></li><li id="iesucks-bq" class="wrong-q"><b> <span class="TermText qWord lang-math">ARRAY<br>
find_index(obj)<br>
find_index { |item| block }<br>
find_index</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">bq</span> <span class="TermText qDef lang-en">Returns the index of the first object in ary such<br>
that the object is == to obj.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.index("b") #=&gt; 1<br>
a.index("z") #=&gt; nil<br>
a.index { |x| x == "b" } #=&gt; 1</span></p></li><li id="iesucks-sb" class="wrong-q"><b> <span class="TermText qWord lang-math">HASH<br>
values</span></b><p><b class="incorrect">INCORRECT:</b> <em>No answer given</em></p><p><b class="correct">ANSWER:</b> <span class="matching-letter">sb</span> <span class="TermText qDef lang-en">Returns a new array populated with the values from hsh. See also<br>
Hash#keys.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }<br>
h.values #=&gt; [100, 200, 300]</span></p></li></ol><ol id="matching-side"><li data-letters="a" class=""><span class="matching-letter">a</span> <span class="TermText qDef lang-en">Returns the current execution stack—an array containing strings in the form<br>
file:line or file:line: in `method'.<br>
<br>
def a(skip)<br>
 caller(skip)<br>
end<br>
def b(skip)<br>
 a(skip)<br>
end<br>
def c(skip)<br>
 b(skip)<br>
end<br>
c(0) #=&gt; ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `&lt;main&gt;'"]<br>
c(1) #=&gt; ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `&lt;main&gt;'"]<br>
c(2) #=&gt; ["prog:8:in `c'", "prog:12:in `&lt;main&gt;'"]<br>
c(3) #=&gt; ["prog:13:in `&lt;main&gt;'"]<br>
c(4) #=&gt; []<br>
c(5) #=&gt; nil</span></li><li data-letters="b" class=""><span class="matching-letter">b</span> <span class="TermText qDef lang-en">Returns num truncated to an integer. Numeric<br>
implements this by converting its value to a float and invoking<br>
Float#truncate.</span></li><li data-letters="c" class=""><span class="matching-letter">c</span> <span class="TermText qDef lang-en">Returns the last component of the filename given in file_name,<br>
which can be formed using both File::SEPARATOR and<br>
File::ALT_SEPARETOR as the separator when<br>
File::ALT_SEPARATOR is not nil. If<br>
suffix is given and present at the end of file_name, it<br>
is removed.<br>
<br>
File.basename("/home/gumby/work/ruby.rb") #=&gt; "ruby.rb"<br>
File.basename("/home/gumby/work/ruby.rb", ".rb") #=&gt; "ruby"</span></li><li data-letters="d" class=""><span class="matching-letter">d</span> <span class="TermText qDef lang-en">DO NOT USE THIS DIRECTLY.</span></li><li data-letters="e" class=""><span class="matching-letter">e</span> <span class="TermText qDef lang-en">Return true if the named file exists.</span></li><li data-letters="f" class=""><span class="matching-letter">f</span> <span class="TermText qDef lang-en">Returns true if the named file is a block device.</span></li><li data-letters="g" class=""><span class="matching-letter">g</span> <span class="TermText qDef lang-en">Flushes any buffered data within ios to the underlying operating<br>
system (note that this is Ruby internal buffering only; the OS may buffer<br>
the data as well).<br>
<br>
$stdout.print "no newline"<br>
$stdout.flush</span></li><li data-letters="h" class=""><span class="matching-letter">h</span> <span class="TermText qDef lang-en">Same as #each, but traverses<br>
self in reverse order.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.reverse_each {|x| print x, " " }</span></li><li data-letters="i" class=""><span class="matching-letter">i</span> <span class="TermText qDef lang-en">Returns true if fix is an odd number.</span></li><li data-letters="j" class=""><span class="matching-letter">j</span> <span class="TermText qDef lang-en">Returns the Symbol corresponding to str, creating the<br>
symbol if it did not previously exist. See Symbol#id2name.<br>
<br>
"Koala".intern #=&gt; :Koala<br>
s = 'cat'.to_sym #=&gt; :cat<br>
s == :cat #=&gt; true<br>
s = '@cat'.to_sym #=&gt; :@cat<br>
s == :@cat #=&gt; true</span></li><li data-letters="k" class=""><span class="matching-letter">k</span> <span class="TermText qDef lang-en">Returns a string representing obj. The default to_s<br>
prints the object's class and an encoding of the object id. As a special<br>
case, the top-level object that is the initial execution context of Ruby<br>
programs returns "main."</span></li><li data-letters="l" class=""><span class="matching-letter">l</span> <span class="TermText qDef lang-en">Returns two arrays, the first containing the elements of enum for<br>
which the block evaluates to true, the second containing the rest.<br>
<br>
(1..6).partition { |v| v.even? } #=&gt; [[2, 4, 6], [1, 3, 5]]</span></li><li data-letters="m" class=""><span class="matching-letter">m</span> <span class="TermText qDef lang-en">Returns a list of the private instance methods defined in mod. If<br>
the optional parameter is not false, the methods of any<br>
ancestors are included.<br>
<br>
module Mod<br>
 def method1() end<br>
 private :method1<br>
 def method2() end<br>
end<br>
Mod.instance_methods #=&gt; [:method2]<br>
Mod.private_instance_methods #=&gt; [:method1]</span></li><li data-letters="n" class=""><span class="matching-letter">n</span> <span class="TermText qDef lang-en">Returns the name of the time zone used for time. As of Ruby 1.8,<br>
returns "UTC" rather than "GMT" for UTC times.<br>
<br>
t = Time.gm(2000, "jan", 1, 20, 15, 1)<br>
t.zone #=&gt; "UTC"<br>
t = Time.local(2000, "jan", 1, 20, 15, 1)<br>
t.zone #=&gt; "CST"</span></li><li data-letters="o" class=""><span class="matching-letter">o</span> <span class="TermText qDef lang-en">Returns the greatest common divisor (always positive). 0.gcd(x) and<br>
x.gcd(0) return abs(x).<br>
<br>
2.gcd(2) #=&gt; 2<br>
3.gcd(-7) #=&gt; 1<br>
((1&lt;&lt;31)-1).gcd((1&lt;&lt;61)-1) #=&gt; 1</span></li><li data-letters="p" class=""><span class="matching-letter">p</span> <span class="TermText qDef lang-en">Checks for a constant with the given name in mod If<br>
inherit is set, the lookup will also search the ancestors (and<br>
Object if mod is a Module.)<br>
<br>
Math.const_defined? "PI" #=&gt; true<br>
IO.const_defined? :SYNC #=&gt; true<br>
IO.const_defined? :SYNC, false #=&gt; false</span></li><li data-letters="q" class=""><span class="matching-letter">q</span> <span class="TermText qDef lang-en">Comparison—Returns -1, 0, +1 or nil depending on whether fix<br>
is less than, equal to, or greater than numeric. This is the<br>
basis for the tests in Comparable.</span></li><li data-letters="r" class=""><span class="matching-letter">r</span> <span class="TermText qDef lang-en">Exclusive Or—Returns true if obj is nil<br>
or false, false otherwise.</span></li><li data-letters="s" class=""><span class="matching-letter">s</span> <span class="TermText qDef lang-en">Extends the specified object by adding this module's constants and methods<br>
(which are added as singleton methods). This is the callback method used by<br>
Object#extend.<br>
<br>
module Picky<br>
 def Picky.extend_object(o)<br>
 if String === o<br>
 puts "Can't add Picky to a String"<br>
 else<br>
 puts "Picky added to #{o.class}"<br>
 super<br>
 end<br>
 end<br>
end<br>
(s = Array.new).extend Picky # Call Object.extend<br>
(s = "quick brown fox").extend Picky</span></li><li data-letters="t" class=""><span class="matching-letter">t</span> <span class="TermText qDef lang-en">Equality—Two regexps are equal if their patterns are identical, they have<br>
the same character set code, and their casefold? values are<br>
the same.<br>
<br>
/abc/ == /abc/ #=&gt; false<br>
/abc/ == /abc/ #=&gt; false<br>
/abc/ == /abc/ #=&gt; false<br>
/abc/ == /abc/ #=&gt; false</span></li><li data-letters="u" class=""><span class="matching-letter">u</span> <span class="TermText qDef lang-en">Performs a delete operation in place, returning str,<br>
or nil if str was not modified.</span></li><li data-letters="v" class=""><span class="matching-letter">v</span> <span class="TermText qDef lang-en">Returns true if obj is an element of the range,<br>
false otherwise. If begin and end are numeric, comparison is<br>
done according to the magnitude of the values.<br>
<br>
("a".."z").include?("g") #=&gt; true<br>
("a".."z").include?("A") #=&gt; false<br>
("a".."z").include?("cc") #=&gt; false</span></li><li data-letters="w" class=""><span class="matching-letter">w</span> <span class="TermText qDef lang-en">Returns true if hsh will compare its keys by their<br>
identity. Also see Hash#compare_by_identity.</span></li><li data-letters="x" class=""><span class="matching-letter">x</span> <span class="TermText qDef lang-en">Returns 0 if the value is positive, pi otherwise.</span></li><li data-letters="y" class=""><span class="matching-letter">y</span> <span class="TermText qDef lang-en">Upcases the contents of str, returning nil if no<br>
changes were made. Note: case replacement is effective only in ASCII<br>
region.</span></li><li data-letters="z" class=""><span class="matching-letter">z</span> <span class="TermText qDef lang-en">Returns x/y;<br>
<br>
Rational(1, 2) #=&gt; (1/2)<br>
Rational('1/2') #=&gt; (1/2)</span></li><li data-letters="aa" class=""><span class="matching-letter">aa</span> <span class="TermText qDef lang-en">Returns true if the underlying file descriptor of ios<br>
will be closed automatically at its finalization, otherwise<br>
false.</span></li><li data-letters="ab" class=""><span class="matching-letter">ab</span> <span class="TermText qDef lang-en">Returns a new array containing self's elements in reverse<br>
order.<br>
<br>
[ "a", "b", "c" ].reverse #=&gt; ["c", "b", "a"]<br>
[ 1 ].reverse #=&gt; [1]</span></li><li data-letters="ac" class=""><span class="matching-letter">ac</span> <span class="TermText qDef lang-en">Appends the elements of other_ary to self.<br>
<br>
[ "a", "b" ].concat( ["c", "d"] ) #=&gt; [ "a", "b", "c", "d" ]<br>
a = [ 1, 2, 3 ]<br>
a.concat( [ 4, 5 ] )<br>
a #=&gt; [ 1, 2, 3, 4, 5 ]</span></li><li data-letters="ad" class=""><span class="matching-letter">ad</span> <span class="TermText qDef lang-en">Creates a hash with a copy of the environment variables.</span></li><li data-letters="ae" class=""><span class="matching-letter">ae</span> <span class="TermText qDef lang-en">Invokes the method identified by symbol, passing it any arguments<br>
specified. You can use __send__ if the name send<br>
clashes with an existing method in obj. When the method is<br>
identified by a string, the string is converted to a symbol.<br>
<br>
class Klass<br>
 def hello(*args)<br>
 "Hello " + args.join(' ')<br>
 end<br>
end<br>
k = Klass.new<br>
k.send :hello, "gentle", "readers" #=&gt; "Hello gentle readers"</span></li><li data-letters="af" class=""><span class="matching-letter">af</span> <span class="TermText qDef lang-en">Iterates over the range, passing each nth element to the<br>
block. If begin and end are numeric, n is added for each<br>
iteration. Otherwise step invokes succ to iterate<br>
through range elements.<br>
<br>
range = Xs.new(1)..Xs.new(10)<br>
range.step(2) {|x| puts x}<br>
puts<br>
range.step(3) {|x| puts x}</span></li><li data-letters="ag" class=""><span class="matching-letter">ag</span> <span class="TermText qDef lang-en">Opens the file, optionally seeks to the given offset, writes<br>
string, then returns the length written. write<br>
ensures the file is closed before returning. If offset is not<br>
given, the file is truncated. Otherwise, it is not truncated.<br>
<br>
encoding: string or encoding<br>
<br>
 specifies encoding of the read string. encoding will be ignored<br>
 if length is specified.<br>
<br>
mode: string<br>
<br>
 specifies mode argument for open(). it should start with "w" or "a" or "r+"<br>
 otherwise it would cause error.<br>
<br>
perm: fixnum<br>
<br>
 specifies perm argument for open().<br>
<br>
open_args: array<br>
<br>
 specifies arguments for open() as an array.<br>
<br>
 IO.write("testfile", "0123456789", 20) # =&gt; 10<br>
 # File could contain: "This is line one\nThi0123456789two\nThis is line three\nAnd so on...\n"<br>
 IO.write("testfile", "0123456789") #=&gt; 10<br>
 # File would now read: "0123456789"</span></li><li data-letters="ah" class=""><span class="matching-letter">ah</span> <span class="TermText qDef lang-en">The string representation of true is "true".</span></li><li data-letters="ai" class=""><span class="matching-letter">ai</span> <span class="TermText qDef lang-en">Manually sets the current line number to the given value. $.<br>
is updated only on the next read.<br>
<br>
f = File.new("testfile")<br>
f.gets #=&gt; "This is line one\n"<br>
$. #=&gt; 1<br>
f.lineno = 1000<br>
f.lineno #=&gt; 1000<br>
$. #=&gt; 1 # lineno of last read<br>
f.gets #=&gt; "This is line two\n"<br>
$. #=&gt; 1001 # lineno of last read</span></li><li data-letters="aj" class=""><span class="matching-letter">aj</span> <span class="TermText qDef lang-en">Seeks to a particular location in dir. integer must be a<br>
value returned by Dir#tell.<br>
<br>
d = Dir.new("testdir") #=&gt; #&lt;Dir:0x401b3c40&gt;<br>
d.read #=&gt; "."<br>
i = d.tell #=&gt; 12<br>
d.read #=&gt; ".."<br>
d.seek(i) #=&gt; #&lt;Dir:0x401b3c40&gt;<br>
d.read #=&gt; ".."</span></li><li data-letters="ak" class=""><span class="matching-letter">ak</span> <span class="TermText qDef lang-en">Executes the block for every line in ios, where lines are<br>
separated by sep. ios must be opened for reading or an<br>
IOError will be raised.<br>
<br>
f = File.new("testfile")<br>
f.each {|line| puts "#{f.lineno}: #{line}" }</span></li><li data-letters="al" class=""><span class="matching-letter">al</span> <span class="TermText qDef lang-en">Returns a copy of str with leading and trailing whitespace<br>
removed.<br>
<br>
" hello ".strip #=&gt; "hello"<br>
"\tgoodbye\r\n".strip #=&gt; "goodbye"</span></li><li data-letters="am" class=""><span class="matching-letter">am</span> <span class="TermText qDef lang-en">Not documented</span></li><li data-letters="an" class=""><span class="matching-letter">an</span> <span class="TermText qDef lang-en">Alias for ::new. Returns a Time object initialized to the current system time.</span></li><li data-letters="ao" class=""><span class="matching-letter">ao</span> <span class="TermText qDef lang-en">Subtracts other from big, returning the result.</span></li><li data-letters="ap" class=""><span class="matching-letter">ap</span> <span class="TermText qDef lang-en">Returns sym.to_s[].</span></li><li data-letters="aq" class=""><span class="matching-letter">aq</span> <span class="TermText qDef lang-en">Returns the native file system's block size. Will return nil<br>
on platforms that don't support this information.<br>
<br>
File.stat("testfile").blksize #=&gt; 4096</span></li><li data-letters="ar" class=""><span class="matching-letter">ar</span> <span class="TermText qDef lang-en">call_seq:<br>
<br>
nil.nil? -&gt; true</span></li><li data-letters="as" class=""><span class="matching-letter">as</span> <span class="TermText qDef lang-en">Seeks to the given position (in bytes) in ios. It is not guranteed<br>
that seeking to the right position when ios is textmode.<br>
<br>
f = File.new("testfile")<br>
f.pos = 17<br>
f.gets #=&gt; "This is line two\n"</span></li><li data-letters="at" class=""><span class="matching-letter">at</span> <span class="TermText qDef lang-en">Returns true if time occurs during Daylight Saving Time in its time zone.<br>
<br>
# CST6CDT:<br>
 Time.local(2000, 1, 1).zone #=&gt; "CST"<br>
 Time.local(2000, 1, 1).isdst #=&gt; false<br>
 Time.local(2000, 1, 1).dst? #=&gt; false<br>
 Time.local(2000, 7, 1).zone #=&gt; "CDT"<br>
 Time.local(2000, 7, 1).isdst #=&gt; true<br>
 Time.local(2000, 7, 1).dst? #=&gt; true<br>
<br>
# Asia/Tokyo:<br>
 Time.local(2000, 1, 1).zone #=&gt; "JST"<br>
 Time.local(2000, 1, 1).isdst #=&gt; false<br>
 Time.local(2000, 1, 1).dst? #=&gt; false<br>
 Time.local(2000, 7, 1).zone #=&gt; "JST"<br>
 Time.local(2000, 7, 1).isdst #=&gt; false<br>
 Time.local(2000, 7, 1).dst? #=&gt; false</span></li><li data-letters="au" class=""><span class="matching-letter">au</span> <span class="TermText qDef lang-en">Generates a Fixnum hash value for this object. <br>
This function must have the property that a.eql?(b) implies<br>
a.hash == b.hash.</span></li><li data-letters="av" class=""><span class="matching-letter">av</span> <span class="TermText qDef lang-en">Returns true if the named file is a symbolic link.</span></li><li data-letters="aw" class=""><span class="matching-letter">aw</span> <span class="TermText qDef lang-en">Returns true if the named file is a socket.</span></li><li data-letters="ax" class=""><span class="matching-letter">ax</span> <span class="TermText qDef lang-en">Produce a nicely formatted string-version of rxp. Perhaps<br>
surprisingly, #inspect actually produces the more natural<br>
version of the string than #to_s.<br>
<br>
/ab+c/x.inspect #=&gt; "/ab+c/ix"</span></li><li data-letters="ay" class=""><span class="matching-letter">ay</span> <span class="TermText qDef lang-en">Choose a random element or n random elements from the array.<br>
<br>
a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]<br>
a.sample #=&gt; 7<br>
a.sample(4) #=&gt; [6, 4, 2, 5]</span></li><li data-letters="az" class=""><span class="matching-letter">az</span> <span class="TermText qDef lang-en">Returns the name of the current method as a Symbol. If called outside of a method, it returns<br>
nil.</span></li><li data-letters="ba" class=""><span class="matching-letter">ba</span> <span class="TermText qDef lang-en">Iterates through successive values, starting at str and ending at<br>
other_str inclusive, passing each value in turn to the block. The<br>
String#succ method is used to generate each value. If<br>
optional second argument exclusive is omitted or is false, the last value<br>
will be included; otherwise it will be excluded.<br>
<br>
"a8".upto("b6") {|s| print s, ' ' }<br>
for s in "a8".."b6"<br>
 print s, ' '<br>
end</span></li><li data-letters="bb" class=""><span class="matching-letter">bb</span> <span class="TermText qDef lang-en">Returns the number of bytes in the machine representation of a<br>
Fixnum.<br>
<br>
1.size #=&gt; 4<br>
-1.size #=&gt; 4<br>
2147483647.size #=&gt; 4</span></li><li data-letters="bc" class=""><span class="matching-letter">bc</span> <span class="TermText qDef lang-en">Returns the values for this instance as an array.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
joe.to_a[1] #=&gt; "123 Maple, Anytown NC"</span></li><li data-letters="bd" class=""><span class="matching-letter">bd</span> <span class="TermText qDef lang-en">Yields each environment variable value.</span></li><li data-letters="be" class=""><span class="matching-letter">be</span> <span class="TermText qDef lang-en">Returns the absolute value of flt.<br>
<br>
(-34.56).abs #=&gt; 34.56<br>
-34.56.abs #=&gt; 34.56</span></li><li data-letters="bf" class=""><span class="matching-letter">bf</span> <span class="TermText qDef lang-en">Returns true if obj is an element of the range,<br>
false otherwise. Conveniently, === is the<br>
comparison operator used by case statements.<br>
<br>
case 79<br>
when 1..50 then print "low\n"<br>
when 51..75 then print "medium\n"<br>
when 76..100 then print "high\n"<br>
end</span></li><li data-letters="bg" class=""><span class="matching-letter">bg</span> <span class="TermText qDef lang-en">Calls select(2) system call. It monitors given arrays of IO<br>
objects, waits one or more of IO objects ready for reading,<br>
are ready for writing, and have pending exceptions respectively, and<br>
returns an array that contains arrays of those IO<br>
objects. It will return nil if optional timeout<br>
value is given and no IO object is ready in timeout<br>
seconds.<br>
<br>
rp, wp = IO.pipe<br>
mesg = "ping "<br>
100.times {<br>
 rs, ws, = IO.select([rp], [wp])<br>
 if r = rs[0]<br>
 ret = r.read(5)<br>
 print ret<br>
 case ret<br>
 when /ping/<br>
 mesg = "pong\n"<br>
 when /pong/<br>
 mesg = "ping "<br>
 end<br>
 end<br>
 if w = ws[0]<br>
 w.write(mesg)<br>
 end<br>
}</span></li><li data-letters="bh" class=""><span class="matching-letter">bh</span> <span class="TermText qDef lang-en">Sets the backtrace information associated with exc. The<br>
backtrace must be an array of String<br>
objects or a single String in the format<br>
described in #backtrace.</span></li><li data-letters="bi" class=""><span class="matching-letter">bi</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_byte.</span></li><li data-letters="bj" class=""><span class="matching-letter">bj</span> <span class="TermText qDef lang-en">Byte Reference—If passed a single Fixnum, returns a substring<br>
of one byte at that position. If passed two Fixnum objects,<br>
returns a substring starting at the offset given by the first, and a length<br>
given by the second. If given a Range, a substring containing<br>
bytes at offsets given by the range is returned. In all three cases, if an<br>
offset is negative, it is counted from the end of str. Returns<br>
nil if the initial offset falls outside the string, the length<br>
is negative, or the beginning of the range is greater than the end. The<br>
encoding of the resulted string keeps original encoding.<br>
<br>
"hello".byteslice(1) #=&gt; "e"<br>
"hello".byteslice(-1) #=&gt; "o"<br>
"hello".byteslice(1, 2) #=&gt; "el"<br>
"\x80\u3042".byteslice(1, 3) #=&gt; "\u3042"<br>
"\x03\u3042\xff".byteslice(1..3) #=&gt; "\u3042"</span></li><li data-letters="bk" class=""><span class="matching-letter">bk</span> <span class="TermText qDef lang-en">Return this exception's class name and message</span></li><li data-letters="bl" class=""><span class="matching-letter">bl</span> <span class="TermText qDef lang-en">Reads ARGF's current file in its entirety, returning an<br>
Array of its lines, one line per element. Lines are assumed to<br>
be separated by sep.<br>
<br>
lines = ARGF.readlines<br>
lines[0] #=&gt; "This is line one\n"</span></li><li data-letters="bm" class=""><span class="matching-letter">bm</span> <span class="TermText qDef lang-en">Returns a string representing time. Equivalent to calling strftime with the appropriate format<br>
string.<br>
<br>
t = Time.now<br>
t.to_s =&gt; "2012-11-10 18:16:12 +0100"<br>
t.strftime "%Y-%m-%d %H:%M:%S %z" =&gt; "2012-11-10 18:16:12 +0100"<br>
<br>
t.utc.to_s =&gt; "2012-11-10 17:16:12 UTC"<br>
t.strftime "%Y-%m-%d %H:%M:%S UTC" =&gt; "2012-11-10 17:16:12 UTC"</span></li><li data-letters="bn" class=""><span class="matching-letter">bn</span> <span class="TermText qDef lang-en">Returns a Binding object, describing the variable and method<br>
bindings at the point of call. This object can be used when calling<br>
eval to execute the evaluated command in this environment. See<br>
also the description of class Binding.<br>
<br>
def get_binding(param)<br>
 return binding<br>
end<br>
b = get_binding("hello")<br>
eval("param", b) #=&gt; "hello"</span></li><li data-letters="bo" class=""><span class="matching-letter">bo</span> <span class="TermText qDef lang-en">Returns true if two objects do not match (using the =~ method),<br>
otherwise false.</span></li><li data-letters="bp" class=""><span class="matching-letter">bp</span> <span class="TermText qDef lang-en">Creates a new PRNG using seed to set the initial state. If<br>
seed is omitted, the generator is initialized with ::new_seed.</span></li><li data-letters="bq" class=""><span class="matching-letter">bq</span> <span class="TermText qDef lang-en">Returns the index of the first object in ary such<br>
that the object is == to obj.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.index("b") #=&gt; 1<br>
a.index("z") #=&gt; nil<br>
a.index { |x| x == "b" } #=&gt; 1</span></li><li data-letters="br" class=""><span class="matching-letter">br</span> <span class="TermText qDef lang-en">Converts hsh to a nested array of [ key,<br>
value ] arrays.<br>
<br>
h = { "c" =&gt; 300, "a" =&gt; 100, "d" =&gt; 400, "c" =&gt; 300 }<br>
h.to_a #=&gt; [["c", 300], ["a", 100], ["d", 400]]</span></li><li data-letters="bs" class=""><span class="matching-letter">bs</span> <span class="TermText qDef lang-en">Returns true if any member of enum equals<br>
obj. Equality is tested using ==.<br>
<br>
IO.constants.include? :SEEK_SET #=&gt; true<br>
IO.constants.include? :SEEK_NO_FURTHER #=&gt; false</span></li><li data-letters="bt" class=""><span class="matching-letter">bt</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block never returns true for<br>
all elements. If the block is not given, none? will return<br>
true only if none of the collection members is true.<br>
<br>
%w{ant bear cat}.none? { |word| word.length == 5 } #=&gt; true<br>
%w{ant bear cat}.none? { |word| word.length &gt;= 4 } #=&gt; false<br>
[].none? #=&gt; true<br>
[nil].none? #=&gt; true<br>
[nil, false].none? #=&gt; true</span></li><li data-letters="bu" class=""><span class="matching-letter">bu</span> <span class="TermText qDef lang-en">Reads the entire file specified by name as individual lines, and<br>
returns those lines in an array. Lines are separated by sep.<br>
<br>
a = IO.readlines("testfile")<br>
a[0] #=&gt; "This is line one\n"</span></li><li data-letters="bv" class=""><span class="matching-letter">bv</span> <span class="TermText qDef lang-en">Returns the number of key-value pairs in the hash.<br>
<br>
h = { "d" =&gt; 100, "a" =&gt; 200, "v" =&gt; 300, "e" =&gt; 400 }<br>
h.length #=&gt; 4<br>
h.delete("a") #=&gt; 200<br>
h.length #=&gt; 3</span></li><li data-letters="bw" class=""><span class="matching-letter">bw</span> <span class="TermText qDef lang-en">'nuf said...</span></li><li data-letters="bx" class=""><span class="matching-letter">bx</span> <span class="TermText qDef lang-en">Returns the offset of the start of the nth element of the match<br>
array in the string. n can be a string or symbol to reference a<br>
named capture.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.begin(0) #=&gt; 1<br>
m.begin(2) #=&gt; 2<br>
<br>
m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match("hoge")<br>
p m.begin(:foo) #=&gt; 0<br>
p m.begin(:bar) #=&gt; 2</span></li><li data-letters="by" class=""><span class="matching-letter">by</span> <span class="TermText qDef lang-en">Returns a new string object containing a copy of str.</span></li><li data-letters="bz" class=""><span class="matching-letter">bz</span> <span class="TermText qDef lang-en">Returns first n elements from the array.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.take(3) #=&gt; [1, 2, 3]</span></li><li data-letters="ca" class=""><span class="matching-letter">ca</span> <span class="TermText qDef lang-en">Adds to obj the instance methods from each module given as a<br>
parameter.<br>
<br>
module Mod<br>
 def hello<br>
 "Hello from Mod.\n"<br>
 end<br>
end<br>
<br>
class Klass<br>
 def hello<br>
 "Hello from Klass.\n"<br>
 end<br>
end<br>
<br>
k = Klass.new<br>
k.hello #=&gt; "Hello from Klass.\n"<br>
k.extend(Mod) #=&gt; #&lt;Klass:0x401b3bc8&gt;<br>
k.hello #=&gt; "Hello from Mod.\n"</span></li><li data-letters="cb" class=""><span class="matching-letter">cb</span> <span class="TermText qDef lang-en">Invokes Module.prepend_features on each parameter in reverse<br>
order.</span></li><li data-letters="cc" class=""><span class="matching-letter">cc</span> <span class="TermText qDef lang-en">Returns the array of matches.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.to_a #=&gt; ["HX1138", "H", "X", "113", "8"]</span></li><li data-letters="cd" class=""><span class="matching-letter">cd</span> <span class="TermText qDef lang-en">Returns "ARGF".</span></li><li data-letters="ce" class=""><span class="matching-letter">ce</span> <span class="TermText qDef lang-en">Returns fix modulo other. See<br>
numeric.divmod for more information.</span></li><li data-letters="cf" class=""><span class="matching-letter">cf</span> <span class="TermText qDef lang-en">Returns the name of the method.</span></li><li data-letters="cg" class=""><span class="matching-letter">cg</span> <span class="TermText qDef lang-en">If aNumeric is the same type as num, returns an array<br>
containing aNumeric and num. Otherwise, returns an array<br>
with both aNumeric and num represented as<br>
Float objects. This coercion mechanism is used by Ruby to<br>
handle mixed-type numeric operations: it is intended to find a compatible<br>
common type between the two operands of the operator.<br>
<br>
1.coerce(2.5) #=&gt; [2.5, 1.0]<br>
1.2.coerce(3) #=&gt; [3.0, 1.2]<br>
1.coerce(2) #=&gt; [2, 1]</span></li><li data-letters="ch" class=""><span class="matching-letter">ch</span> <span class="TermText qDef lang-en">Returns the int itself.<br>
<br>
a.ord #=&gt; 97</span></li><li data-letters="ci" class=""><span class="matching-letter">ci</span> <span class="TermText qDef lang-en">Returns the major part of File_Stat#dev or nil.<br>
<br>
File.stat("/dev/fd1").dev_major #=&gt; 2<br>
File.stat("/dev/tty").dev_major #=&gt; 5</span></li><li data-letters="cj" class=""><span class="matching-letter">cj</span> <span class="TermText qDef lang-en">Returns a new Time object representing<br>
time in UTC.<br>
<br>
t = Time.local(2000,1,1,20,15,1) #=&gt; 2000-01-01 20:15:01 -0600<br>
t.gmt? #=&gt; false<br>
y = t.getgm #=&gt; 2000-01-02 02:15:01 UTC<br>
y.gmt? #=&gt; true<br>
t == y #=&gt; true</span></li><li data-letters="ck" class=""><span class="matching-letter">ck</span> <span class="TermText qDef lang-en">For example:<br>
<br>
Sets the current file to the next file in ARGV. If there aren't any more<br>
files it has no effect.</span></li><li data-letters="cl" class=""><span class="matching-letter">cl</span> <span class="TermText qDef lang-en">Returns the result of invoking exception.to_s. Normally this<br>
returns the exception's message or name. By supplying a to_str method,<br>
exceptions are agreeing to be used where Strings are expected.</span></li><li data-letters="cm" class=""><span class="matching-letter">cm</span> <span class="TermText qDef lang-en">Returns the name of the file referenced by the given link. Not available on<br>
all platforms.<br>
<br>
File.symlink("testfile", "link2test") #=&gt; 0<br>
File.readlink("link2test") #=&gt; "testfile"</span></li><li data-letters="cn" class=""><span class="matching-letter">cn</span> <span class="TermText qDef lang-en">Returns the minimum value in the range. Returns nil if the<br>
begin value of the range is larger than the end value.<br>
<br>
(10..20).min #=&gt; 10</span></li><li data-letters="co" class=""><span class="matching-letter">co</span> <span class="TermText qDef lang-en">Returns true for a string which encoded correctly.<br>
<br>
"\xc2\xa1".force_encoding("UTF-8").valid_encoding? #=&gt; true<br>
"\xc2".force_encoding("UTF-8").valid_encoding? #=&gt; false<br>
"\x80".force_encoding("UTF-8").valid_encoding? #=&gt; false</span></li><li data-letters="cp" class=""><span class="matching-letter">cp</span> <span class="TermText qDef lang-en">Or—Returns false if obj is nil or<br>
false; true otherwise.</span></li><li data-letters="cq" class=""><span class="matching-letter">cq</span> <span class="TermText qDef lang-en">Rounds sub seconds to a given precision in decimal digits (0 digits by<br>
default). It returns a new Time object.<br>
ndigits should be zero or positive integer.<br>
<br>
require 'time'<br>
<br>
t = Time.utc(2010,3,30, 5,43,"25.123456789".to_r)<br>
p t.iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567890Z"<br>
p t.round.iso8601(10) #=&gt; "2010-03-30T05:43:25.0000000000Z"<br>
p t.round(0).iso8601(10) #=&gt; "2010-03-30T05:43:25.0000000000Z"<br>
p t.round(1).iso8601(10) #=&gt; "2010-03-30T05:43:25.1000000000Z"<br>
p t.round(2).iso8601(10) #=&gt; "2010-03-30T05:43:25.1200000000Z"<br>
p t.round(3).iso8601(10) #=&gt; "2010-03-30T05:43:25.1230000000Z"<br>
p t.round(4).iso8601(10) #=&gt; "2010-03-30T05:43:25.1235000000Z"<br>
p t.round(5).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234600000Z"<br>
p t.round(6).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234570000Z"<br>
p t.round(7).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234568000Z"<br>
p t.round(8).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567900Z"<br>
p t.round(9).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567890Z"<br>
p t.round(10).iso8601(10) #=&gt; "2010-03-30T05:43:25.1234567890Z"<br>
<br>
t = Time.utc(1999,12,31, 23,59,59)<br>
p((t + 0.4).round.iso8601(3)) #=&gt; "1999-12-31T23:59:59.000Z"<br>
p((t + 0.49).round.iso8601(3)) #=&gt; "1999-12-31T23:59:59.000Z"<br>
p((t + 0.5).round.iso8601(3)) #=&gt; "2000-01-01T00:00:00.000Z"<br>
p((t + 1.4).round.iso8601(3)) #=&gt; "2000-01-01T00:00:00.000Z"<br>
p((t + 1.49).round.iso8601(3)) #=&gt; "2000-01-01T00:00:00.000Z"<br>
p((t + 1.5).round.iso8601(3)) #=&gt; "2000-01-01T00:00:01.000Z"<br>
<br>
t = Time.utc(1999,12,31, 23,59,59)<br>
p (t + 0.123456789).round(4).iso8601(6) #=&gt; "1999-12-31T23:59:59.123500Z"</span></li><li data-letters="cr" class=""><span class="matching-letter">cr</span> <span class="TermText qDef lang-en">Repetition — With a String argument, equivalent<br>
to ary.join(str).<br>
<br>
[ 1, 2, 3 ] * 3 #=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]<br>
[ 1, 2, 3 ] * ^!^ #=&gt; "1,2,3"</span></li><li data-letters="cs" class=""><span class="matching-letter">cs</span> <span class="TermText qDef lang-en">Returns the regexp.<br>
<br>
m = /a.*b/.match("abc")<br>
m.regexp #=&gt; /a.*b/</span></li><li data-letters="ct" class=""><span class="matching-letter">ct</span> <span class="TermText qDef lang-en">Creates a new Enumerator which will enumerate<br>
by calling method on obj, passing<br>
args if any.<br>
<br>
str = "xyz"<br>
<br>
enum = str.enum_for(:each_byte)<br>
enum.each { |b| puts b }<br>
# =&gt; 120<br>
# =&gt; 121<br>
# =&gt; 122<br>
<br>
# protect an array from being modified by some_method<br>
a = [1, 2, 3]<br>
some_method(a.to_enum)</span></li><li data-letters="cu" class=""><span class="matching-letter">cu</span> <span class="TermText qDef lang-en">Returns an integer representing the numeric file descriptor for<br>
ios.<br>
<br>
$stdin.fileno #=&gt; 0<br>
$stdout.fileno #=&gt; 1</span></li><li data-letters="cv" class=""><span class="matching-letter">cv</span> <span class="TermText qDef lang-en">Returns the value of time as a rational number of seconds since<br>
the Epoch.<br>
<br>
t = Time.now<br>
p t.to_r #=&gt; (1270968792716287611/1000000000)</span></li><li data-letters="cw" class=""><span class="matching-letter">cw</span> <span class="TermText qDef lang-en">Returns every environment variable name in an Array</span></li><li data-letters="cx" class=""><span class="matching-letter">cx</span> <span class="TermText qDef lang-en">Search the encoding with specified name. name should be a<br>
string or symbol.<br>
<br>
Encoding.find("US-ASCII") #=&gt; #&lt;Encoding:US-ASCII&gt;<br>
Encoding.find(:Shift_JIS) #=&gt; #&lt;Encoding:Shift_JIS&gt;</span></li><li data-letters="cy" class=""><span class="matching-letter">cy</span> <span class="TermText qDef lang-en">Reads the next character from ARGF and returns it as a<br>
String. Returns nil at the end of the stream.<br>
<br>
$ echo "foo" &gt; file<br>
$ ruby argf.rb file<br>
<br>
ARGF.getc #=&gt; "f"<br>
ARGF.getc #=&gt; "o"<br>
ARGF.getc #=&gt; "o"<br>
ARGF.getc #=&gt; "\n"<br>
ARGF.getc #=&gt; nil<br>
ARGF.getc #=&gt; nil</span></li><li data-letters="cz" class=""><span class="matching-letter">cz</span> <span class="TermText qDef lang-en">Always returns true.</span></li><li data-letters="da" class=""><span class="matching-letter">da</span> <span class="TermText qDef lang-en">Changes permission bits on the named file(s) to the bit pattern represented<br>
by mode_int. Actual effects are operating system dependent (see<br>
the beginning of this section). On Unix systems, see chmod(2)<br>
for details. Returns the number of files processed.<br>
<br>
File.chmod(0644, "testfile", "out") #=&gt; 2</span></li><li data-letters="db" class=""><span class="matching-letter">db</span> <span class="TermText qDef lang-en">Removes the last element from self and returns it, or<br>
nil if the array is empty.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.pop #=&gt; "d"<br>
a.pop(2) #=&gt; ["b", "c"]<br>
a #=&gt; ["a"]</span></li><li data-letters="dc" class=""><span class="matching-letter">dc</span> <span class="TermText qDef lang-en">Divides str into substrings based on a delimiter, returning an<br>
array of these substrings.<br>
<br>
" now's the time".split #=&gt; ["now's", "the", "time"]<br>
" now's the time".split(' ') #=&gt; ["now's", "the", "time"]<br>
" now's the time".split(/ /) #=&gt; ["", "now's", "", "the", "time"]<br>
"1, 2.34,56, 7".split(%r{,\s*}) #=&gt; ["1", "2.34", "56", "7"]<br>
"hello".split(//) #=&gt; ["h", "e", "l", "l", "o"]<br>
"hello".split(//, 3) #=&gt; ["h", "e", "llo"]<br>
"hi mom".split(%r{\s*}) #=&gt; ["h", "i", "m", "o", "m"]<br>
<br>
"mellow yellow".split("ello") #=&gt; ["m", "w y", "w"]<br>
"1,2,,3,4,,".split(',') #=&gt; ["1", "2", "", "3", "4"]<br>
"1,2,,3,4,,".split(',', 4) #=&gt; ["1", "2", "", "3,4,,"]<br>
"1,2,,3,4,,".split(',', -4) #=&gt; ["1", "2", "", "3", "4", "", ""]<br>
<br>
"".split(',', -1) #=&gt; []</span></li><li data-letters="dd" class=""><span class="matching-letter">dd</span> <span class="TermText qDef lang-en">Returns the Ruby source filename and line number containing this method or<br>
nil if this method was not defined in Ruby (i.e. native)</span></li><li data-letters="de" class=""><span class="matching-letter">de</span> <span class="TermText qDef lang-en">Rotates self in place so that the element at<br>
count comes first, and returns self.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.rotate! #=&gt; ["b", "c", "d", "a"]<br>
a #=&gt; ["b", "c", "d", "a"]<br>
a.rotate!(2) #=&gt; ["d", "a", "b", "c"]<br>
a.rotate!(-3) #=&gt; ["a", "b", "c", "d"]</span></li><li data-letters="df" class=""><span class="matching-letter">df</span> <span class="TermText qDef lang-en">Returns true if there is an environment variable with the<br>
given value.</span></li><li data-letters="dg" class=""><span class="matching-letter">dg</span> <span class="TermText qDef lang-en">Returns a string containing the character represented by the receiver's<br>
value according to encoding.<br>
<br>
65.chr #=&gt; "A"<br>
230.chr #=&gt; "\346"<br>
255.chr(Encoding::UTF_8) #=&gt; "\303\277"</span></li><li data-letters="dh" class=""><span class="matching-letter">dh</span> <span class="TermText qDef lang-en">Formats time according to the directives in the given format<br>
string.<br>
<br>
%&lt;flags&gt;&lt;width&gt;&lt;modifier&gt;&lt;conversion&gt;</span></li><li data-letters="di" class=""><span class="matching-letter">di</span> <span class="TermText qDef lang-en">As int is already an Integer, all these methods<br>
simply return the receiver.</span></li><li data-letters="dj" class=""><span class="matching-letter">dj</span> <span class="TermText qDef lang-en">Constructs a range using the given begin and end.<br>
If the exclude_end parameter is omitted or is<br>
false, the rng will include the end object;<br>
otherwise, it will be excluded.</span></li><li data-letters="dk" class=""><span class="matching-letter">dk</span> <span class="TermText qDef lang-en">Returns self if num is not zero, nil<br>
otherwise. This behavior is useful when chaining comparisons:<br>
<br>
a = %w( z Bb bB bb BB a aA Aa AA A )<br>
b = a.sort {|a,b| (a.downcase &lt;=&gt; b.downcase).nonzero? || a &lt;=&gt; b }<br>
b #=&gt; ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]</span></li><li data-letters="dl" class=""><span class="matching-letter">dl</span> <span class="TermText qDef lang-en">Returns true if time represents a time in UTC (GMT).<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:15:23 -0600<br>
t.utc? #=&gt; false<br>
t = Time.gm(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.utc? #=&gt; true<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:16:03 -0600<br>
t.gmt? #=&gt; false<br>
t = Time.gm(2000,1,1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.gmt? #=&gt; true</span></li><li data-letters="dm" class=""><span class="matching-letter">dm</span> <span class="TermText qDef lang-en">Returns true if stat is writable by the effective<br>
user id of this process.<br>
<br>
File.stat("testfile").writable? #=&gt; true</span></li><li data-letters="dn" class=""><span class="matching-letter">dn</span> <span class="TermText qDef lang-en">Creates a new anonymous (unnamed) class with the given superclass (or<br>
Object if no parameter is given). You can give a class a name<br>
by assigning the class object to a constant.<br>
<br>
fred = Class.new do<br>
 def meth1<br>
 "hello"<br>
 end<br>
 def meth2<br>
 "bye"<br>
 end<br>
end<br>
<br>
a = fred.new #=&gt; #&lt;#&lt;Class:0x100381890&gt;:0x100376b98&gt;<br>
a.meth1 #=&gt; "hello"<br>
a.meth2 #=&gt; "bye"</span></li><li data-letters="do" class=""><span class="matching-letter">do</span> <span class="TermText qDef lang-en">Returns true if int is an odd number.</span></li><li data-letters="dp" class=""><span class="matching-letter">dp</span> <span class="TermText qDef lang-en">Modifies str in place as described for String#chomp,<br>
returning str, or nil if no modifications were made.</span></li><li data-letters="dq" class=""><span class="matching-letter">dq</span> <span class="TermText qDef lang-en">Returns the list of modules included in mod.<br>
<br>
module Mixin<br>
end<br>
<br>
module Outer<br>
 include Mixin<br>
end<br>
<br>
Mixin.included_modules #=&gt; []<br>
Outer.included_modules #=&gt; [Mixin]</span></li><li data-letters="dr" class=""><span class="matching-letter">dr</span> <span class="TermText qDef lang-en">Returns the size of stat in bytes.<br>
<br>
File.stat("testfile").size #=&gt; 66</span></li><li data-letters="ds" class=""><span class="matching-letter">ds</span> <span class="TermText qDef lang-en">Returns a new string formed by joining the strings using<br>
File::SEPARATOR.<br>
<br>
File.join("usr", "mail", "gumby") #=&gt; "usr/mail/gumby"</span></li><li data-letters="dt" class=""><span class="matching-letter">dt</span> <span class="TermText qDef lang-en">Writes the given objects to ios as with IO#print.<br>
Writes a record separator (typically a newline) after any that do not<br>
already end with a newline sequence. If called with an array argument,<br>
writes each element on a new line. If called without arguments, outputs a<br>
single record separator.<br>
<br>
$stdout.puts("this", "is", "a", "test")</span></li><li data-letters="du" class=""><span class="matching-letter">du</span> <span class="TermText qDef lang-en">Sets default internal encoding or removes default internal encoding when<br>
passed nil. You should not set ::default_internal in<br>
ruby code as strings created before changing the value may have a different<br>
encoding from strings created after the change. Instead you should use<br>
ruby -E to invoke ruby with the correct default_internal.</span></li><li data-letters="dv" class=""><span class="matching-letter">dv</span> <span class="TermText qDef lang-en">Returns a frozen copy of the string passed in to match.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.string #=&gt; "THX1138."</span></li><li data-letters="dw" class=""><span class="matching-letter">dw</span> <span class="TermText qDef lang-en">Returns a canonical string representation of time.<br>
<br>
Time.now.asctime #=&gt; "Wed Apr 9 08:56:03 2003"</span></li><li data-letters="dx" class=""><span class="matching-letter">dx</span> <span class="TermText qDef lang-en">Invoked as a callback whenever a singleton method is added to the receiver.<br>
<br>
module Chatty<br>
 def Chatty.singleton_method_added(id)<br>
 puts "Adding #{id.id2name}"<br>
 end<br>
 def self.one() end<br>
 def two() end<br>
 def Chatty.three() end<br>
end</span></li><li data-letters="dy" class=""><span class="matching-letter">dy</span> <span class="TermText qDef lang-en">Sets the instance variable names by symbol to object,<br>
thereby frustrating the efforts of the class's author to attempt to provide<br>
proper encapsulation. The variable did not have to exist prior to this<br>
call. If the instance variable name is passed as a string, that string is<br>
converted to a symbol.<br>
<br>
class Fred<br>
 def initialize(p1, p2)<br>
 @a, @b = p1, p2<br>
 end<br>
end<br>
fred = Fred.new('cat', 99)<br>
fred.instance_variable_set(:@a, 'dog') #=&gt; "dog"<br>
fred.instance_variable_set(:@c, 'cat') #=&gt; "cat"<br>
fred.inspect #=&gt; "#&lt;Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\"&gt;"</span></li><li data-letters="dz" class=""><span class="matching-letter">dz</span> <span class="TermText qDef lang-en">Returns an array of all combinations of elements from all arrays.<br>
<br>
[1,2,3].product([4,5]) #=&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]<br>
[1,2].product([1,2]) #=&gt; [[1,1],[1,2],[2,1],[2,2]]<br>
[1,2].product([3,4],[5,6]) #=&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],<br>
 # [2,3,5],[2,3,6],[2,4,5],[2,4,6]]<br>
[1,2].product() #=&gt; [[1],[2]]<br>
[1,2].product([]) #=&gt; []</span></li><li data-letters="ea" class=""><span class="matching-letter">ea</span> <span class="TermText qDef lang-en">Drops elements up to, but not including, the first element for which the<br>
block returns nil or false and returns an array<br>
containing the remaining elements.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.drop_while { |i| i &lt; 3 } #=&gt; [3, 4, 5, 0]</span></li><li data-letters="eb" class=""><span class="matching-letter">eb</span> <span class="TermText qDef lang-en">Returns true if the given instance variable is defined in<br>
obj. String arguments are converted to<br>
symbols.<br>
<br>
class Fred<br>
 def initialize(p1, p2)<br>
 @a, @b = p1, p2<br>
 end<br>
end<br>
fred = Fred.new('cat', 99)<br>
fred.instance_variable_defined?(:@a) #=&gt; true<br>
fred.instance_variable_defined?("@b") #=&gt; true<br>
fred.instance_variable_defined?("@c") #=&gt; false</span></li><li data-letters="ec" class=""><span class="matching-letter">ec</span> <span class="TermText qDef lang-en">Prepend—Prepend the given string to str.<br>
<br>
a = "world"<br>
a.prepend("hello ") #=&gt; "hello world"<br>
a #=&gt; "hello world"</span></li><li data-letters="ed" class=""><span class="matching-letter">ed</span> <span class="TermText qDef lang-en">Attribute Reference—Returns the value of the instance variable named by<br>
symbol, or indexed (0..length-1) by fixnum. Will raise<br>
NameError if the named variable does not exist, or<br>
IndexError if the index is out of range.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
<br>
joe["name"] #=&gt; "Joe Smith"<br>
joe[:name] #=&gt; "Joe Smith"<br>
joe[0] #=&gt; "Joe Smith"</span></li><li data-letters="ee" class=""><span class="matching-letter">ee</span> <span class="TermText qDef lang-en">If stat is writable by others, returns an integer representing the<br>
file permission bits of stat. Returns nil otherwise.<br>
The meaning of the bits is platform dependent; on Unix systems, see<br>
stat(2).<br>
<br>
m = File.stat("/tmp").world_writable? #=&gt; 511<br>
sprintf("%o", m) #=&gt; "777"</span></li><li data-letters="ef" class=""><span class="matching-letter">ef</span> <span class="TermText qDef lang-en">See Numeric#divmod.</span></li><li data-letters="eg" class=""><span class="matching-letter">eg</span> <span class="TermText qDef lang-en">Returns the Encoding object that represents the<br>
encoding of obj.</span></li><li data-letters="eh" class=""><span class="matching-letter">eh</span> <span class="TermText qDef lang-en">Returns a basic n-bit checksum of the characters in str,<br>
where n is the optional Fixnum parameter, defaulting<br>
to 16. The result is simply the sum of the binary value of each character<br>
in str modulo 2**n - 1. This is not a particularly<br>
good checksum.</span></li><li data-letters="ei" class=""><span class="matching-letter">ei</span> <span class="TermText qDef lang-en">Returns the numerator. The result is machine dependent.<br>
<br>
n = 0.3.numerator #=&gt; 5404319552844595<br>
d = 0.3.denominator #=&gt; 18014398509481984<br>
n.fdiv(d) #=&gt; 0.3</span></li><li data-letters="ej" class=""><span class="matching-letter">ej</span> <span class="TermText qDef lang-en">Returns true if the named file has the setuid bit set.</span></li><li data-letters="ek" class=""><span class="matching-letter">ek</span> <span class="TermText qDef lang-en">Iterates the given block for each array of consecutive &lt;n&gt; elements. <br>
If no block is given, returns an enumerator.<br>
<br>
(1..10).each_cons(3) { |a| p a }<br>
# outputs below<br>
[1, 2, 3]<br>
[2, 3, 4]<br>
[3, 4, 5]<br>
[4, 5, 6]<br>
[5, 6, 7]<br>
[6, 7, 8]<br>
[7, 8, 9]<br>
[8, 9, 10]</span></li><li data-letters="el" class=""><span class="matching-letter">el</span> <span class="TermText qDef lang-en">Returns a copy of str with all lowercase letters replaced with<br>
their uppercase counterparts. The operation is locale insensitive—only<br>
characters "a" to "z" are affected. Note: case replacement is effective<br>
only in ASCII region.<br>
<br>
"hEllO".upcase #=&gt; "HELLO"</span></li><li data-letters="em" class=""><span class="matching-letter">em</span> <span class="TermText qDef lang-en">Returns a Proc object which respond to the given method by<br>
sym.<br>
<br>
(1..3).collect(&amp;:to_s) #=&gt; ["1", "2", "3"]</span></li><li data-letters="en" class=""><span class="matching-letter">en</span> <span class="TermText qDef lang-en">Case Equality - For class Object, effectively the<br>
same as calling #==, but typically overridden by descendants<br>
to provide meaningful semantics in case statements.</span></li><li data-letters="eo" class=""><span class="matching-letter">eo</span> <span class="TermText qDef lang-en">Returns true if obj is an instance of the given<br>
class. See also Object#kind_of?.<br>
<br>
class A; end<br>
class B &lt; A; end<br>
class C &lt; B; end<br>
<br>
b = B.new<br>
b.instance_of? A #=&gt; false<br>
b.instance_of? B #=&gt; true<br>
b.instance_of? C #=&gt; false</span></li><li data-letters="ep" class=""><span class="matching-letter">ep</span> <span class="TermText qDef lang-en">Calls block once for each key in hsh, passing the value<br>
as a parameter.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.each_value {|value| puts value }</span></li><li data-letters="eq" class=""><span class="matching-letter">eq</span> <span class="TermText qDef lang-en">Writes the given string to ios. The stream must be opened for<br>
writing. If the argument is not a string, it will be converted to a string<br>
using to_s. Returns the number of bytes written.<br>
<br>
count = $stdout.write("This is a test\n")<br>
puts "That was #{count} bytes of data"</span></li><li data-letters="er" class=""><span class="matching-letter">er</span> <span class="TermText qDef lang-en">Returns true if the named file is a directory,<br>
false otherwise.</span></li><li data-letters="es" class=""><span class="matching-letter">es</span> <span class="TermText qDef lang-en">Sets the default proc to be executed on each failed key lookup.<br>
<br>
h.default_proc = proc do |hash, key|<br>
 hash[key] = key + key<br>
end<br>
h[2] #=&gt; 4<br>
h["cat"] #=&gt; "catcat"</span></li><li data-letters="et" class=""><span class="matching-letter">et</span> <span class="TermText qDef lang-en">Produce a hash based on the text and options of this regular expression.</span></li><li data-letters="eu" class=""><span class="matching-letter">eu</span> <span class="TermText qDef lang-en">Returns a new array that is a one-dimensional flattening of this hash. That<br>
is, for every key or value that is an array, extract its elements into the<br>
new array. Unlike Array#flatten,<br>
this method does not flatten recursively by default. The optional<br>
level argument determines the level of recursion to flatten.<br>
<br>
a = {1=&gt; "one", 2 =&gt; [2,"two"], 3 =&gt; "three"}<br>
a.flatten # =&gt; [1, "one", 2, [2, "two"], 3, "three"]<br>
a.flatten(2) # =&gt; [1, "one", 2, 2, "two", 3, "three"]</span></li><li data-letters="ev" class=""><span class="matching-letter">ev</span> <span class="TermText qDef lang-en">Multiplies big and other, returning the result.</span></li><li data-letters="ew" class=""><span class="matching-letter">ew</span> <span class="TermText qDef lang-en">Returns the absolute value of num.<br>
<br>
12.abs #=&gt; 12<br>
(-34.56).abs #=&gt; 34.56<br>
-34.56.abs #=&gt; 34.56</span></li><li data-letters="ex" class=""><span class="matching-letter">ex</span> <span class="TermText qDef lang-en">Equivalent to ENV#keep_if but returns nil if no changes were<br>
made.</span></li><li data-letters="ey" class=""><span class="matching-letter">ey</span> <span class="TermText qDef lang-en">Returns the object in enum that gives the maximum value from the<br>
given block.<br>
<br>
a = %w(albatross dog horse)<br>
a.max_by { |x| x.length } #=&gt; "albatross"</span></li><li data-letters="ez" class=""><span class="matching-letter">ez</span> <span class="TermText qDef lang-en">Returns true if the value of big is less than<br>
that of real.</span></li><li data-letters="fa" class=""><span class="matching-letter">fa</span> <span class="TermText qDef lang-en">Equivalent to<br>
<br>
$stdout.puts(obj, ...)</span></li><li data-letters="fb" class=""><span class="matching-letter">fb</span> <span class="TermText qDef lang-en">Returns false if obj &lt;=&gt;<br>
min is less than zero or if anObject<br>
&lt;=&gt; max is greater than zero, true<br>
otherwise.<br>
<br>
3.between?(1, 5) #=&gt; true<br>
6.between?(1, 5) #=&gt; false<br>
'cat'.between?('ant', 'dog') #=&gt; true<br>
'gnu'.between?('ant', 'dog') #=&gt; false</span></li><li data-letters="fc" class=""><span class="matching-letter">fc</span> <span class="TermText qDef lang-en">Returns the numeric group id of the owner of stat.<br>
<br>
File.stat("testfile").gid #=&gt; 500</span></li><li data-letters="fd" class=""><span class="matching-letter">fd</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_char.</span></li><li data-letters="fe" class=""><span class="matching-letter">fe</span> <span class="TermText qDef lang-en">Returns the number of nanoseconds for time.<br>
<br>
t = Time.now #=&gt; 2007-11-17 15:18:03 +0900<br>
"%10.9f" % t.to_f #=&gt; "1195280283.536151409"<br>
t.nsec #=&gt; 536151406</span></li><li data-letters="ff" class=""><span class="matching-letter">ff</span> <span class="TermText qDef lang-en">Removes an environment variable name-value pair from ENV and returns it as an Array. Returns nil if when the<br>
environment is empty.</span></li><li data-letters="fg" class=""><span class="matching-letter">fg</span> <span class="TermText qDef lang-en">Prepends objects to the front of self, moving other elements<br>
upwards. See also #shift for the<br>
opposite effect.<br>
<br>
a = [ "b", "c", "d" ]<br>
a.unshift("a") #=&gt; ["a", "b", "c", "d"]<br>
a.unshift(1, 2) #=&gt; [ 1, 2, "a", "b", "c", "d"]</span></li><li data-letters="fh" class=""><span class="matching-letter">fh</span> <span class="TermText qDef lang-en">Returns float / numeric.</span></li><li data-letters="fi" class=""><span class="matching-letter">fi</span> <span class="TermText qDef lang-en">Returns a new hash consisting of entries for which the block returns true.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }<br>
h.select {|k,v| k &gt; "a"} #=&gt; {"b" =&gt; 200, "c" =&gt; 300}<br>
h.select {|k,v| v &lt; 200} #=&gt; {"a" =&gt; 100}</span></li><li data-letters="fj" class=""><span class="matching-letter">fj</span> <span class="TermText qDef lang-en">Returns a new array with elements of self shuffled.<br>
<br>
a = [ 1, 2, 3 ] #=&gt; [1, 2, 3]<br>
a.shuffle #=&gt; [2, 3, 1]</span></li><li data-letters="fk" class=""><span class="matching-letter">fk</span> <span class="TermText qDef lang-en">Reads a one-character string from ios. Returns nil if<br>
called at end of file.<br>
<br>
f = File.new("testfile")<br>
f.getc #=&gt; "h"<br>
f.getc #=&gt; "e"</span></li><li data-letters="fl" class=""><span class="matching-letter">fl</span> <span class="TermText qDef lang-en">Returns a curried proc. If the optional arity argument is given,<br>
it determines the number of arguments. A curried proc receives some<br>
arguments. If a sufficient number of arguments are supplied, it passes the<br>
supplied arguments to the original proc and returns the result. Otherwise,<br>
returns another curried proc that takes the rest of arguments.<br>
<br>
b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; 6<br>
p b.curry(5)[1][2][3][4][5] #=&gt; 6<br>
p b.curry(5)[1, 2][3, 4][5] #=&gt; 6<br>
p b.curry(1)[1] #=&gt; 1<br>
<br>
b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; 10<br>
p b.curry(5)[1][2][3][4][5] #=&gt; 15<br>
p b.curry(5)[1, 2][3, 4][5] #=&gt; 15<br>
p b.curry(1)[1] #=&gt; 1<br>
<br>
b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; wrong number of arguments (4 for 3)<br>
p b.curry(5) #=&gt; wrong number of arguments (5 for 3)<br>
p b.curry(1) #=&gt; wrong number of arguments (1 for 3)<br>
<br>
b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }<br>
p b.curry[1][2][3] #=&gt; 6<br>
p b.curry[1, 2][3, 4] #=&gt; 10<br>
p b.curry(5)[1][2][3][4][5] #=&gt; 15<br>
p b.curry(5)[1, 2][3, 4][5] #=&gt; 15<br>
p b.curry(1) #=&gt; wrong number of arguments (1 for 3)<br>
<br>
b = proc { :foo }<br>
p b.curry[] #=&gt; :foo</span></li><li data-letters="fm" class=""><span class="matching-letter">fm</span> <span class="TermText qDef lang-en">Synonym for Dir#seek, but returns the position parameter.<br>
<br>
d = Dir.new("testdir") #=&gt; #&lt;Dir:0x401b3c40&gt;<br>
d.read #=&gt; "."<br>
i = d.pos #=&gt; 12<br>
d.read #=&gt; ".."<br>
d.pos = i #=&gt; 12<br>
d.read #=&gt; ".."</span></li><li data-letters="fn" class=""><span class="matching-letter">fn</span> <span class="TermText qDef lang-en">For example:<br>
<br>
Returns true if +ARGF+ is being read in binary mode; false otherwise. (To<br>
enable binary mode use +ARGF.binmode+.</span></li><li data-letters="fo" class=""><span class="matching-letter">fo</span> <span class="TermText qDef lang-en">Similar to method, searches public method only.</span></li><li data-letters="fp" class=""><span class="matching-letter">fp</span> <span class="TermText qDef lang-en">Returns the ARGV array, which contains the arguments passed to<br>
your script, one per element.<br>
<br>
$ ruby argf.rb -v glark.txt<br>
<br>
ARGF.argv #=&gt; ["-v", "glark.txt"]</span></li><li data-letters="fq" class=""><span class="matching-letter">fq</span> <span class="TermText qDef lang-en">Append—Pushes the given object on to the end of this array. This expression<br>
returns the array itself, so several appends may be chained together.<br>
<br>
[ 1, 2 ] &lt;&lt; "c" &lt;&lt; "d" &lt;&lt; [ 3, 4 ]<br>
 #=&gt; [ 1, 2, "c", "d", [ 3, 4 ] ]</span></li><li data-letters="fr" class=""><span class="matching-letter">fr</span> <span class="TermText qDef lang-en">Returns true if there is an environment variable with the<br>
given name.</span></li><li data-letters="fs" class=""><span class="matching-letter">fs</span> <span class="TermText qDef lang-en">Evaluates the string or block in the context of mod, except that<br>
when a block is given, constant/class variable lookup is not affected. This<br>
can be used to add methods to a class. module_eval returns the<br>
result of evaluating its argument. The optional filename and<br>
lineno parameters set the text for error messages.<br>
<br>
class Thing<br>
end<br>
a = %q{def hello() "Hello there!" end}<br>
Thing.module_eval(a)<br>
puts Thing.new.hello()<br>
Thing.module_eval("invalid code", "dummy", 123)</span></li><li data-letters="ft" class=""><span class="matching-letter">ft</span> <span class="TermText qDef lang-en">Returns the path parameter passed to dir's constructor.<br>
<br>
d = Dir.new("..")<br>
d.path #=&gt; ".."</span></li><li data-letters="fu" class=""><span class="matching-letter">fu</span> <span class="TermText qDef lang-en">Case-insensitive version of String#&lt;=&gt;.<br>
<br>
"abcdef".casecmp("abcde") #=&gt; 1<br>
"aBcDeF".casecmp("abcdef") #=&gt; 0<br>
"abcdef".casecmp("abcdefg") #=&gt; -1<br>
"abcdef".casecmp("ABCDEF") #=&gt; 0</span></li><li data-letters="fv" class=""><span class="matching-letter">fv</span> <span class="TermText qDef lang-en">Return the modulo after division of float by<br>
other.<br>
<br>
6543.21.modulo(137) #=&gt; 104.21<br>
6543.21.modulo(137.24) #=&gt; 92.9299999999996</span></li><li data-letters="fw" class=""><span class="matching-letter">fw</span> <span class="TermText qDef lang-en">Returns the successor to str. The successor is calculated by<br>
incrementing characters starting from the rightmost alphanumeric (or the<br>
rightmost character if there are no alphanumerics) in the string.<br>
Incrementing a digit always results in another digit, and incrementing a<br>
letter results in another letter of the same case. Incrementing<br>
nonalphanumerics uses the underlying character set's collating sequence.<br>
<br>
"abcd".succ #=&gt; "abce"<br>
"THX1138".succ #=&gt; "THX1139"<br>
"&lt;&lt;koala&gt;&gt;".succ #=&gt; "&lt;&lt;koalb&gt;&gt;"<br>
"1999zzz".succ #=&gt; "2000aaa"<br>
"ZZZ9999".succ #=&gt; "AAAA0000"<br>
"**<b>".succ #=&gt; "</b>*+"</span></li><li data-letters="fx" class=""><span class="matching-letter">fx</span> <span class="TermText qDef lang-en">Produces a shallow copy of obj—the instance variables of<br>
obj are copied, but not the objects they reference. Copies the<br>
frozen and tainted state of obj. See also the discussion under<br>
Object#dup.<br>
<br>
class Klass<br>
 attr_accessor :str<br>
end<br>
s1 = Klass.new #=&gt; #&lt;Klass:0x401b3a38&gt;<br>
s1.str = "Hello" #=&gt; "Hello"<br>
s2 = s1.clone #=&gt; #&lt;Klass:0x401b3998 @str="Hello"&gt;<br>
s2.str[1,4] = "i" #=&gt; "i"<br>
s1.inspect #=&gt; "#&lt;Klass:0x401b3a38 @str=\"Hi\"&gt;"<br>
s2.inspect #=&gt; "#&lt;Klass:0x401b3998 @str=\"Hi\"&gt;"</span></li><li data-letters="fy" class=""><span class="matching-letter">fy</span> <span class="TermText qDef lang-en">Returns true if the given key is present in hsh.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.has_key?("a") #=&gt; true<br>
h.has_key?("z") #=&gt; false</span></li><li data-letters="fz" class=""><span class="matching-letter">fz</span> <span class="TermText qDef lang-en">Reads a line as with IO#gets, but raises an<br>
EOFError on end of file.</span></li><li data-letters="ga" class=""><span class="matching-letter">ga</span> <span class="TermText qDef lang-en">Returns true if stat has its sticky bit set,<br>
false if it doesn't or if the operating system doesn't support<br>
this feature.<br>
<br>
File.stat("testfile").sticky? #=&gt; false</span></li><li data-letters="gb" class=""><span class="matching-letter">gb</span> <span class="TermText qDef lang-en">Returns a new array containing the items in self for which the<br>
given block is not true.</span></li><li data-letters="gc" class=""><span class="matching-letter">gc</span> <span class="TermText qDef lang-en">Returns all components of the filename given in file_name except<br>
the last one. The filename can be formed using both<br>
File::SEPARATOR and File::ALT_SEPARETOR as the<br>
separator when File::ALT_SEPARATOR is not nil.<br>
<br>
File.dirname("/home/gumby/work/ruby.rb") #=&gt; "/home/gumby/work"</span></li><li data-letters="gd" class=""><span class="matching-letter">gd</span> <span class="TermText qDef lang-en">Returns the representation of sym as a symbol literal.<br>
<br>
:fred.inspect #=&gt; ":fred"</span></li><li data-letters="ge" class=""><span class="matching-letter">ge</span> <span class="TermText qDef lang-en">With no arguments, raises the exception in $! or raises a<br>
RuntimeError if $! is nil. With a<br>
single String argument, raises a RuntimeError<br>
with the string as a message. Otherwise, the first parameter should be the<br>
name of an Exception class (or an object that returns an<br>
Exception object when sent an exception message).<br>
The optional second parameter sets the message associated with the<br>
exception, and the third parameter is an array of callback information.<br>
Exceptions are caught by the rescue clause of<br>
begin...end blocks.<br>
<br>
raise "Failed to create socket"<br>
raise ArgumentError, "No parameters", caller</span></li><li data-letters="gf" class=""><span class="matching-letter">gf</span> <span class="TermText qDef lang-en">Invokes the meth with the specified arguments, returning the<br>
method's return value.<br>
<br>
m = 12.method("+")<br>
m.call(3) #=&gt; 15<br>
m.call(20) #=&gt; 32</span></li><li data-letters="gg" class=""><span class="matching-letter">gg</span> <span class="TermText qDef lang-en">Returns first n elements from enum.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.take(3) #=&gt; [1, 2, 3]</span></li><li data-letters="gh" class=""><span class="matching-letter">gh</span> <span class="TermText qDef lang-en">Returns a new hash created by using environment variable names as values<br>
and values as names.</span></li><li data-letters="gi" class=""><span class="matching-letter">gi</span> <span class="TermText qDef lang-en">Changes the current working directory of the process to the given string.<br>
When called without an argument, changes the directory to the value of the<br>
environment variable HOME, or LOGDIR.<br>
SystemCallError (probably Errno::ENOENT) if the<br>
target directory does not exist.<br>
<br>
Dir.chdir("/var/spool/mail")<br>
puts Dir.pwd<br>
Dir.chdir("/tmp") do<br>
 puts Dir.pwd<br>
 Dir.chdir("/usr") do<br>
 puts Dir.pwd<br>
 end<br>
 puts Dir.pwd<br>
end<br>
puts Dir.pwd</span></li><li data-letters="gj" class=""><span class="matching-letter">gj</span> <span class="TermText qDef lang-en">Returns the value of the given instance variable, or nil if the instance<br>
variable is not set. The @ part of the variable name should be<br>
included for regular instance variables. Throws a NameError<br>
exception if the supplied symbol is not valid as an instance variable name.<br>
String arguments are converted to symbols.<br>
<br>
class Fred<br>
 def initialize(p1, p2)<br>
 @a, @b = p1, p2<br>
 end<br>
end<br>
fred = Fred.new('cat', 99)<br>
fred.instance_variable_get(:@a) #=&gt; "cat"<br>
fred.instance_variable_get("@b") #=&gt; 99</span></li><li data-letters="gk" class=""><span class="matching-letter">gk</span> <span class="TermText qDef lang-en">Calls the block once for each entry in the named directory, passing the<br>
filename of each entry as a parameter to the block.<br>
<br>
Dir.foreach("testdir") {|x| puts "Got #{x}" }</span></li><li data-letters="gl" class=""><span class="matching-letter">gl</span> <span class="TermText qDef lang-en">Returns true if mod is an ancestor of other. Returns<br>
nil if there's no relationship between the two. (Think of the<br>
relationship in terms of the class definition: "class A&lt;B" implies<br>
"B&gt;A").</span></li><li data-letters="gm" class=""><span class="matching-letter">gm</span> <span class="TermText qDef lang-en">Closes the write end of a duplex I/O stream (i.e., one that contains both a<br>
read and a write stream, such as a pipe). Will raise an<br>
IOError if the stream is not duplexed.<br>
<br>
f = IO.popen("/bin/sh^!^r+")<br>
f.close_write<br>
f.print "nowhere"</span></li><li data-letters="gn" class=""><span class="matching-letter">gn</span> <span class="TermText qDef lang-en">Returns the last access time for this file as an object of class<br>
Time.<br>
<br>
File.stat("testfile").atime #=&gt; Wed Dec 31 18:00:00 CST 1969</span></li><li data-letters="go" class=""><span class="matching-letter">go</span> <span class="TermText qDef lang-en">Returns an integer identifier for obj.</span></li><li data-letters="gp" class=""><span class="matching-letter">gp</span> <span class="TermText qDef lang-en">Centers str in width. If width is<br>
greater than the length of str, returns a new String of length width with<br>
str centered and padded with padstr; otherwise,<br>
returns str.<br>
<br>
"hello".center(4) #=&gt; "hello"<br>
"hello".center(20) #=&gt; " hello "<br>
"hello".center(20, '123') #=&gt; "1231231hello12312312"</span></li><li data-letters="gq" class=""><span class="matching-letter">gq</span> <span class="TermText qDef lang-en">Returns the Encoding object that represents the<br>
encoding of sym.</span></li><li data-letters="gr" class=""><span class="matching-letter">gr</span> <span class="TermText qDef lang-en">Returns two elements array which contains the minimum and the maximum value<br>
in the enumerable. The first form assumes all objects implement<br>
Comparable; the second uses the block to return a<br>
&lt;=&gt; b.<br>
<br>
a = %w(albatross dog horse)<br>
a.minmax #=&gt; ["albatross", "horse"]<br>
a.minmax { |a, b| a.length &lt;=&gt; b.length } #=&gt; ["dog", "albatross"]</span></li><li data-letters="gs" class=""><span class="matching-letter">gs</span> <span class="TermText qDef lang-en">Returns the current filename. "-" is returned when the current file is<br>
STDIN.<br>
<br>
$ echo "foo" &gt; foo<br>
$ echo "bar" &gt; bar<br>
$ echo "glark" &gt; glark<br>
<br>
$ ruby argf.rb foo bar glark<br>
<br>
ARGF.filename #=&gt; "foo"<br>
ARGF.read(5) #=&gt; "foo\nb"<br>
ARGF.filename #=&gt; "bar"<br>
ARGF.skip<br>
ARGF.filename #=&gt; "glark"</span></li><li data-letters="gt" class=""><span class="matching-letter">gt</span> <span class="TermText qDef lang-en">Treats leading characters of str as a string of octal digits (with<br>
an optional sign) and returns the corresponding number. Returns 0 if the<br>
conversion fails.<br>
<br>
"123".oct #=&gt; 83<br>
"-377".oct #=&gt; -255<br>
"bad".oct #=&gt; 0<br>
"0377bad".oct #=&gt; 255</span></li><li data-letters="gu" class=""><span class="matching-letter">gu</span> <span class="TermText qDef lang-en">Removes the definition of the given constant, returning that constant's<br>
previous value. If that constant referred to a module, this will not<br>
change that module's name and can lead to confusion.</span></li><li data-letters="gv" class=""><span class="matching-letter">gv</span> <span class="TermText qDef lang-en">By using binary search, finds a value from this array which meets the given<br>
condition in O(log n) where n is the size of the array.<br>
<br>
ary = [0, 4, 7, 10, 12]<br>
ary.bsearch {|x| x &gt;= 4 } #=&gt; 4<br>
ary.bsearch {|x| x &gt;= 6 } #=&gt; 7<br>
ary.bsearch {|x| x &gt;= -1 } #=&gt; 0<br>
ary.bsearch {|x| x &gt;= 100 } #=&gt; nil</span></li><li data-letters="gw" class=""><span class="matching-letter">gw</span> <span class="TermText qDef lang-en">Difference — Returns a new Time object that<br>
represents the difference between time and<br>
other_time, or subtracts the given number of seconds in<br>
numeric from time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:23:10 -0600<br>
t2 = t + 2592000 #=&gt; 2007-12-19 08:23:10 -0600<br>
t2 - t #=&gt; 2592000.0<br>
t2 - 2592000 #=&gt; 2007-11-19 08:23:10 -0600</span></li><li data-letters="gx" class=""><span class="matching-letter">gx</span> <span class="TermText qDef lang-en">Negates fix (which might return a Bignum).</span></li><li data-letters="gy" class=""><span class="matching-letter">gy</span> <span class="TermText qDef lang-en">Returns an array containing the items in enum.<br>
<br>
(1..7).to_a #=&gt; [1, 2, 3, 4, 5, 6, 7]<br>
{ 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a #=&gt; [["a", 1], ["b", 2], ["c", 3]]</span></li><li data-letters="gz" class=""><span class="matching-letter">gz</span> <span class="TermText qDef lang-en">Sets the line number of ARGF as a whole to the given<br>
Integer.<br>
<br>
ARGF.lineno #=&gt; 0<br>
ARGF.readline #=&gt; "This is line 1\n"<br>
ARGF.lineno #=&gt; 1<br>
ARGF.lineno = 0 #=&gt; 0<br>
ARGF.lineno #=&gt; 0</span></li><li data-letters="ha" class=""><span class="matching-letter">ha</span> <span class="TermText qDef lang-en">Returns a copy of str with all uppercase letters replaced with<br>
their lowercase counterparts. The operation is locale insensitive—only<br>
characters "A" to "Z" are affected. Note: case replacement is effective<br>
only in ASCII region.<br>
<br>
"hEllO".downcase #=&gt; "hello"</span></li><li data-letters="hb" class=""><span class="matching-letter">hb</span> <span class="TermText qDef lang-en">Returns a new array with the concatenated results of running block<br>
once for every element in enum.<br>
<br>
[1, 2, 3, 4].flat_map { |e| [e, -e] } #=&gt; [1, -1, 2, -2, 3, -3, 4, -4]<br>
[[1, 2], [3, 4]].flat_map { |e| e + [100] } #=&gt; [1, 2, 100, 3, 4, 100]</span></li><li data-letters="hc" class=""><span class="matching-letter">hc</span> <span class="TermText qDef lang-en">Element Assignment—Associates the value given by value with the<br>
key given by key. key should not have its value changed<br>
while it is in use as a key (a String passed as a key will be<br>
duplicated and frozen).<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h["a"] = 9<br>
h["c"] = 4<br>
h #=&gt; {"a"=&gt;9, "b"=&gt;200, "c"=&gt;4}</span></li><li data-letters="hd" class=""><span class="matching-letter">hd</span> <span class="TermText qDef lang-en">Returns the offset in seconds between the timezone of time and<br>
UTC.<br>
<br>
t = Time.gm(2000,1,1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.gmt_offset #=&gt; 0<br>
l = t.getlocal #=&gt; 2000-01-01 14:15:01 -0600<br>
l.gmt_offset #=&gt; -21600</span></li><li data-letters="he" class=""><span class="matching-letter">he</span> <span class="TermText qDef lang-en">Returns flt truncated to an Integer.</span></li><li data-letters="hf" class=""><span class="matching-letter">hf</span> <span class="TermText qDef lang-en">Returns true if ios is binmode.</span></li><li data-letters="hg" class=""><span class="matching-letter">hg</span> <span class="TermText qDef lang-en">Returns the next object as an array in the enumerator, and move the<br>
internal position forward. When the position reached at the end, StopIteration is raised.<br>
<br>
o = Object.new<br>
def o.each<br>
 yield<br>
 yield 1<br>
 yield 1, 2<br>
 yield nil<br>
 yield [1, 2]<br>
end<br>
e = o.to_enum<br>
p e.next_values<br>
p e.next_values<br>
p e.next_values<br>
p e.next_values<br>
p e.next_values<br>
e = o.to_enum<br>
p e.next<br>
p e.next<br>
p e.next<br>
p e.next<br>
p e.next<br>
<br>
## yield args next_values next<br>
# yield [] nil<br>
# yield 1 [1] 1<br>
# yield 1, 2 [1, 2] [1, 2]<br>
# yield nil [nil] nil<br>
# yield [1, 2] [[1, 2]] [1, 2]</span></li><li data-letters="hh" class=""><span class="matching-letter">hh</span> <span class="TermText qDef lang-en">Replaces the contents and taintedness of str with the<br>
corresponding values in other_str.<br>
<br>
s = "hello" #=&gt; "hello"<br>
s.replace "world" #=&gt; "world"</span></li><li data-letters="hi" class=""><span class="matching-letter">hi</span> <span class="TermText qDef lang-en">Produce a nicely formatted description of stat.<br>
<br>
File.stat("/etc/passwd").inspect<br>
 #=&gt; "#&lt;File::Stat dev=0xe000005, ino=1078078, mode=0100644,<br>
 # nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,<br>
 # blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,<br>
 # mtime=Fri Sep 12 15:41:41 CDT 2003,<br>
 # ctime=Mon Oct 27 11:20:27 CST 2003&gt;"</span></li><li data-letters="hj" class=""><span class="matching-letter">hj</span> <span class="TermText qDef lang-en">Returns the list of available encoding names.<br>
<br>
Encoding.name_list<br>
#=&gt; ["US-ASCII", "ASCII-8BIT", "UTF-8",<br>
 "ISO-8859-1", "Shift_JIS", "EUC-JP",<br>
 "Windows-31J",<br>
 "BINARY", "CP932", "eucJP"]</span></li><li data-letters="hk" class=""><span class="matching-letter">hk</span> <span class="TermText qDef lang-en">Returns the pathname used to create file as a string. Does not<br>
normalize the name.<br>
<br>
File.new("testfile").path #=&gt; "testfile"<br>
File.new("/tmp/../tmp/xxx", "w").path #=&gt; "/tmp/../tmp/xxx"</span></li><li data-letters="hl" class=""><span class="matching-letter">hl</span> <span class="TermText qDef lang-en">Performs subtraction: the class of the resulting object depends on the<br>
class of numeric and on the magnitude of the result.</span></li><li data-letters="hm" class=""><span class="matching-letter">hm</span> <span class="TermText qDef lang-en">modifies the indexth byte as integer.</span></li><li data-letters="hn" class=""><span class="matching-letter">hn</span> <span class="TermText qDef lang-en">Bitwise EXCLUSIVE OR.</span></li><li data-letters="ho" class=""><span class="matching-letter">ho</span> <span class="TermText qDef lang-en">Returns the largest integer less than or equal to num.<br>
Numeric implements this by converting anInteger to a<br>
Float and invoking Float#floor.<br>
<br>
1.floor #=&gt; 1<br>
(-1).floor #=&gt; -1</span></li><li data-letters="hp" class=""><span class="matching-letter">hp</span> <span class="TermText qDef lang-en">Case Equality—Returns true if anObject is an instance<br>
of mod or one of mod's descendants. Of limited use for<br>
modules, but can be used in case statements to classify<br>
objects by class.</span></li><li data-letters="hq" class=""><span class="matching-letter">hq</span> <span class="TermText qDef lang-en">Returns true if class is the class of obj,<br>
or if class is one of the superclasses of obj or modules<br>
included in obj.<br>
<br>
module M; end<br>
class A<br>
 include M<br>
end<br>
class B &lt; A; end<br>
class C &lt; B; end<br>
<br>
b = B.new<br>
b.is_a? A #=&gt; true<br>
b.is_a? B #=&gt; true<br>
b.is_a? C #=&gt; false<br>
b.is_a? M #=&gt; true<br>
<br>
b.kind_of? A #=&gt; true<br>
b.kind_of? B #=&gt; true<br>
b.kind_of? C #=&gt; false<br>
b.kind_of? M #=&gt; true</span></li><li data-letters="hr" class=""><span class="matching-letter">hr</span> <span class="TermText qDef lang-en">Returns the seed value used to initialize the generator. This may be used<br>
to initialize another generator with the same state at a later time,<br>
causing it to produce the same sequence of numbers.<br>
<br>
prng1 = Random.new(1234)<br>
prng1.seed #=&gt; 1234<br>
prng1.rand(100) #=&gt; 47<br>
<br>
prng2 = Random.new(prng1.seed)<br>
prng2.rand(100) #=&gt; 47</span></li><li data-letters="hs" class=""><span class="matching-letter">hs</span> <span class="TermText qDef lang-en">Case Equality—Used in case statements.<br>
<br>
a = "HELLO"<br>
case a<br>
when /^[a-z]*$/; print "Lower case\n"<br>
when /^[A-Z]*$/; print "Upper case\n"<br>
else; print "Mixed case\n"<br>
end<br>
#=&gt; "Upper case"</span></li><li data-letters="ht" class=""><span class="matching-letter">ht</span> <span class="TermText qDef lang-en">Returns the size of file_name.</span></li><li data-letters="hu" class=""><span class="matching-letter">hu</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_line.</span></li><li data-letters="hv" class=""><span class="matching-letter">hv</span> <span class="TermText qDef lang-en">String Output---Writes obj to<br>
ios. obj will be converted to a string using<br>
to_s.<br>
<br>
$stdout &lt;&lt; "Hello " &lt;&lt; "world!\n"</span></li><li data-letters="hw" class=""><span class="matching-letter">hw</span> <span class="TermText qDef lang-en">Equivalent to File::chown, but does not follow symbolic links<br>
(so it will change the owner associated with the link, not the file<br>
referenced by the link). Often not available. Returns number of files in<br>
the argument list.</span></li><li data-letters="hx" class=""><span class="matching-letter">hx</span> <span class="TermText qDef lang-en">Attribute Assignment—Assigns to the instance variable named by<br>
symbol or fixnum the value obj and returns it.<br>
Will raise a NameError if the named variable does not exist,<br>
or an IndexError if the index is out of range.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
<br>
joe["name"] = "Luke"<br>
joe[:zip] = "90210"<br>
<br>
joe.name #=&gt; "Luke"<br>
joe.zip #=&gt; "90210"</span></li><li data-letters="hy" class=""><span class="matching-letter">hy</span> <span class="TermText qDef lang-en">Returns true if stat is writable by the real user id<br>
of this process.<br>
<br>
File.stat("testfile").writable_real? #=&gt; true</span></li><li data-letters="hz" class=""><span class="matching-letter">hz</span> <span class="TermText qDef lang-en">Seeks to a given offset anInteger in the stream according to the<br>
value of whence:<br>
<br>
:CUR or IO::SEEK_CUR | Seeks to _amount_ plus current position<br>
----------------------+--------------------------------------------------<br>
:END or IO::SEEK_END | Seeks to _amount_ plus end of stream (you<br>
 | probably want a negative value for _amount_)<br>
----------------------+--------------------------------------------------<br>
:SET or IO::SEEK_SET | Seeks to the absolute location given by _amount_</span></li><li data-letters="ia" class=""><span class="matching-letter">ia</span> <span class="TermText qDef lang-en">Returns self.</span></li><li data-letters="ib" class=""><span class="matching-letter">ib</span> <span class="TermText qDef lang-en">Return a hash based on the string's length and content.</span></li><li data-letters="ic" class=""><span class="matching-letter">ic</span> <span class="TermText qDef lang-en">Combines all elements of enum by applying a binary operation,<br>
specified by a block or a symbol that names a method or operator.<br>
<br>
# Sum some numbers<br>
(5..10).reduce(:+) #=&gt; 45<br>
# Same using a block and inject<br>
(5..10).inject { |sum, n| sum + n } #=&gt; 45<br>
# Multiply some numbers<br>
(5..10).reduce(1, :*) #=&gt; 151200<br>
# Same using a block<br>
(5..10).inject(1) { |product, n| product * n } #=&gt; 151200<br>
# find the longest word<br>
longest = %w{ cat sheep bear }.inject do |memo, word|<br>
 memo.length &gt; word.length ? memo : word<br>
end<br>
longest #=&gt; "sheep"</span></li><li data-letters="id" class=""><span class="matching-letter">id</span> <span class="TermText qDef lang-en">Returns the change time for the named file (the time at which directory<br>
information about the file was changed, not the file itself).<br>
<br>
File.ctime("testfile") #=&gt; Wed Apr 09 08:53:13 CDT 2003</span></li><li data-letters="ie" class=""><span class="matching-letter">ie</span> <span class="TermText qDef lang-en">Returns the hour of the day (0..23) for time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:26:20 -0600<br>
t.hour #=&gt; 8</span></li><li data-letters="if" class=""><span class="matching-letter">if</span> <span class="TermText qDef lang-en">Searches sep or pattern (regexp) in the string and<br>
returns the part before it, the match, and the part after it. If it is not<br>
found, returns two empty strings and str.<br>
<br>
"hello".partition("l") #=&gt; ["he", "l", "lo"]<br>
"hello".partition("x") #=&gt; ["hello", "", ""]<br>
"hello".partition(/.l/) #=&gt; ["h", "el", "lo"]</span></li><li data-letters="ig" class=""><span class="matching-letter">ig</span> <span class="TermText qDef lang-en">true if flt is greater than real.<br>
The result of NaN &gt; NaN is undefined, so the<br>
implementation-dependent value is returned.</span></li><li data-letters="ih" class=""><span class="matching-letter">ih</span> <span class="TermText qDef lang-en">Yields each environment variable name and value.</span></li><li data-letters="ii" class=""><span class="matching-letter">ii</span> <span class="TermText qDef lang-en">Returns the last element(s) of self. If the array is empty,<br>
the first form returns nil.<br>
<br>
a = [ "w", "x", "y", "z" ]<br>
a.last #=&gt; "z"<br>
a.last(2) #=&gt; ["y", "z"]</span></li><li data-letters="ij" class=""><span class="matching-letter">ij</span> <span class="TermText qDef lang-en">Produces a version of str with all non-printing characters<br>
replaced by \nnn notation and all special characters escaped.<br>
<br>
"hello \n ''".dump #=&gt; "\"hello \\n ''\"</span></li><li data-letters="ik" class=""><span class="matching-letter">ik</span> <span class="TermText qDef lang-en">Returns the inode number for stat.<br>
<br>
File.stat("testfile").ino #=&gt; 1083669</span></li><li data-letters="il" class=""><span class="matching-letter">il</span> <span class="TermText qDef lang-en">Removes leading and trailing whitespace from str. Returns<br>
nil if str was not altered.</span></li><li data-letters="im" class=""><span class="matching-letter">im</span> <span class="TermText qDef lang-en">Returns true if the value of fix is greater than<br>
or equal to that of real.</span></li><li data-letters="in" class=""><span class="matching-letter">in</span> <span class="TermText qDef lang-en">Returns the smallest Integer greater than or equal to<br>
flt.<br>
<br>
1.2.ceil #=&gt; 2<br>
2.0.ceil #=&gt; 2<br>
(-1.2).ceil #=&gt; -1<br>
(-2.0).ceil #=&gt; -2</span></li><li data-letters="io" class=""><span class="matching-letter">io</span> <span class="TermText qDef lang-en">Returns the object that defines the beginning of the range.<br>
<br>
(1..10).begin #=&gt; 1</span></li><li data-letters="ip" class=""><span class="matching-letter">ip</span> <span class="TermText qDef lang-en">Returns true if fix is an even number.</span></li><li data-letters="iq" class=""><span class="matching-letter">iq</span> <span class="TermText qDef lang-en">Returns a ten-element array of values for time:<br>
<br>
[sec, min, hour, day, month, year, wday, yday, isdst, zone]</span></li><li data-letters="ir" class=""><span class="matching-letter">ir</span> <span class="TermText qDef lang-en">Pushes back one character (passed as a parameter) onto ios, such<br>
that a subsequent buffered character read will return it. Only one<br>
character may be pushed back before a subsequent read operation (that is,<br>
you will be able to read only the last of several characters that have been<br>
pushed back). Has no effect with unbuffered reads (such as<br>
IO#sysread).<br>
<br>
f = File.new("testfile") #=&gt; #&lt;File:testfile&gt;<br>
c = f.getc #=&gt; "8"<br>
f.ungetc(c) #=&gt; nil<br>
f.getc #=&gt; "8"</span></li><li data-letters="is" class=""><span class="matching-letter">is</span> <span class="TermText qDef lang-en">If integer is greater than the length of str, returns a<br>
new String of length integer with str left<br>
justified and padded with padstr; otherwise, returns str.<br>
<br>
"hello".ljust(4) #=&gt; "hello"<br>
"hello".ljust(20) #=&gt; "hello "<br>
"hello".ljust(20, '1234') #=&gt; "hello123412341234123"</span></li><li data-letters="it" class=""><span class="matching-letter">it</span> <span class="TermText qDef lang-en">Compares two objects based on the receiver's &lt;=&gt; method,<br>
returning true if it returns 0. Also returns true if obj and<br>
other are the same object.</span></li><li data-letters="iu" class=""><span class="matching-letter">iu</span> <span class="TermText qDef lang-en">Two method objects are equal if they are bound to the same object and refer<br>
to the same method definition and their owners are the same class or<br>
module.</span></li><li data-letters="iv" class=""><span class="matching-letter">iv</span> <span class="TermText qDef lang-en">Returns a new array populated with the given objects.<br>
<br>
Array.[]( 1, 'a', /^A/ ) # =&gt; [1, "a", /^A/]<br>
Array[ 1, 'a', /^A/ ] # =&gt; [1, "a", /^A/]<br>
[ 1, 'a', /^A/ ] # =&gt; [1, "a", /^A/]</span></li><li data-letters="iw" class=""><span class="matching-letter">iw</span> <span class="TermText qDef lang-en">Returns true if hsh contains no key-value pairs.<br>
<br>
{}.empty? #=&gt; true</span></li><li data-letters="ix" class=""><span class="matching-letter">ix</span> <span class="TermText qDef lang-en">Opens the file named by filename according to the given<br>
mode and returns a new File object.<br>
<br>
f = File.new("testfile", "r")<br>
f = File.new("newfile", "w+")<br>
f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)</span></li><li data-letters="iy" class=""><span class="matching-letter">iy</span> <span class="TermText qDef lang-en">Returns the array of captures; equivalent to mtch.to_a[1..-1].<br>
<br>
f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures<br>
f1 #=&gt; "H"<br>
f2 #=&gt; "X"<br>
f3 #=&gt; "113"<br>
f4 #=&gt; "8"</span></li><li data-letters="iz" class=""><span class="matching-letter">iz</span> <span class="TermText qDef lang-en">Returns a complex which denotes the string form. The parser ignores<br>
leading whitespaces and trailing garbage. Any digit sequences can be<br>
separated by an underscore. Returns zero for null or garbage string.<br>
<br>
'9'.to_c #=&gt; (9+0i)<br>
'2.5'.to_c #=&gt; (2.5+0i)<br>
'2.5/1'.to_c #=&gt; ((5/2)+0i)<br>
'-3/2'.to_c #=&gt; ((-3/2)+0i)<br>
'-i'.to_c #=&gt; (0-1i)<br>
'45i'.to_c #=&gt; (0+45i)<br>
'3-4i'.to_c #=&gt; (3-4i)<br>
'-4e2-4e-2i'.to_c #=&gt; (-400.0-0.04i)<br>
'-0.0-0.0i'.to_c #=&gt; (-0.0-0.0i)<br>
'1/2+3/4i'.to_c #=&gt; ((1/2)+(3/4)*i)<br>
'ruby'.to_c #=&gt; (0+0i)</span></li><li data-letters="ja" class=""><span class="matching-letter">ja</span> <span class="TermText qDef lang-en">Prevents further modifications to obj. A RuntimeError<br>
will be raised if modification is attempted. There is no way to unfreeze a<br>
frozen object. See also Object#frozen?.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.freeze<br>
a &lt;&lt; "z"</span></li><li data-letters="jb" class=""><span class="matching-letter">jb</span> <span class="TermText qDef lang-en">Returns the original string of the pattern.<br>
<br>
/ab+c/x.source #=&gt; "ab+c"</span></li><li data-letters="jc" class=""><span class="matching-letter">jc</span> <span class="TermText qDef lang-en">advice is one of the following symbols:<br>
<br>
Announce an intention to access data from the current file in a<br>
specific pattern. On platforms that do not support the<br>
&lt;em&gt;posix_fadvise(2)&lt;/em&gt; system call, this method is a no-op.</span></li><li data-letters="jd" class=""><span class="matching-letter">jd</span> <span class="TermText qDef lang-en">Returns a list of the protected instance methods defined in mod.<br>
If the optional parameter is not false, the methods of any<br>
ancestors are included.</span></li><li data-letters="je" class=""><span class="matching-letter">je</span> <span class="TermText qDef lang-en">Returns the result of interpreting leading characters in str as a<br>
floating point number. Extraneous characters past the end of a valid number<br>
are ignored. If there is not a valid number at the start of str,<br>
0.0 is returned. This method never raises an exception.<br>
<br>
"123.45e1".to_f #=&gt; 1234.5<br>
"45.67 degrees".to_f #=&gt; 45.67<br>
"thx1138".to_f #=&gt; 0.0</span></li><li data-letters="jf" class=""><span class="matching-letter">jf</span> <span class="TermText qDef lang-en">Removes the definition of the sym, returning that constant's<br>
value.<br>
<br>
class Dummy<br>
 @@var = 99<br>
 puts @@var<br>
 remove_class_variable(:@@var)<br>
 p(defined? @@var)<br>
end</span></li><li data-letters="jg" class=""><span class="matching-letter">jg</span> <span class="TermText qDef lang-en">Returns a new, empty hash. If this hash is subsequently accessed by a key<br>
that doesn't correspond to a hash entry, the value returned depends on the<br>
style of new used to create the hash. In the first form, the<br>
access returns nil. If obj is specified, this single<br>
object will be used for all default values. If a block is<br>
specified, it will be called with the hash object and the key, and should<br>
return the default value. It is the block's responsibility to store the<br>
value in the hash if required.<br>
<br>
h = Hash.new("Go Fish")<br>
h["a"] = 100<br>
h["b"] = 200<br>
h["a"] #=&gt; 100<br>
h["c"] #=&gt; "Go Fish"<br>
# The following alters the single default object<br>
h["c"].upcase! #=&gt; "GO FISH"<br>
h["d"] #=&gt; "GO FISH"<br>
h.keys #=&gt; ["a", "b"]<br>
<br>
# While this creates a new default object each time<br>
h = Hash.new { |hash, key| hash[key] = "Go Fish: #{key}" }<br>
h["c"] #=&gt; "Go Fish: c"<br>
h["c"].upcase! #=&gt; "GO FISH: C"<br>
h["d"] #=&gt; "Go Fish: d"<br>
h.keys #=&gt; ["c", "d"]</span></li><li data-letters="jh" class=""><span class="matching-letter">jh</span> <span class="TermText qDef lang-en">Returns the denominator (always positive). The result is machine<br>
dependent.</span></li><li data-letters="ji" class=""><span class="matching-letter">ji</span> <span class="TermText qDef lang-en">Raises big to the exponent power (which may be an<br>
integer, float, or anything that will coerce to a number). The result may<br>
be a Fixnum, Bignum, or<br>
Float<br>
<br>
123456789 ** 2 #=&gt; 15241578750190521<br>
123456789 ** 1.2 #=&gt; 5126464716.09932<br>
123456789 ** -2 #=&gt; 6.5610001194102e-17</span></li><li data-letters="jj" class=""><span class="matching-letter">jj</span> <span class="TermText qDef lang-en">Returns square of self.</span></li><li data-letters="jk" class=""><span class="matching-letter">jk</span> <span class="TermText qDef lang-en">Returns the string representation of the path<br>
<br>
File.path("/dev/null") #=&gt; "/dev/null"<br>
File.path(Pathname.new("/tmp")) #=&gt; "/tmp"</span></li><li data-letters="jl" class=""><span class="matching-letter">jl</span> <span class="TermText qDef lang-en">Converts time to local time (using the local time zone in effect<br>
for this process) modifying the receiver.<br>
<br>
t = Time.utc(2000, "jan", 1, 20, 15, 1) #=&gt; 2000-01-01 20:15:01 UTC<br>
t.utc? #=&gt; true<br>
<br>
t.localtime #=&gt; 2000-01-01 14:15:01 -0600<br>
t.utc? #=&gt; false<br>
<br>
t.localtime("+09:00") #=&gt; 2000-01-02 05:15:01 +0900<br>
t.utc? #=&gt; false</span></li><li data-letters="jm" class=""><span class="matching-letter">jm</span> <span class="TermText qDef lang-en">Returns a string containing the representation of big radix<br>
base (2 through 36).<br>
<br>
12345654321.to_s #=&gt; "12345654321"<br>
12345654321.to_s(2) #=&gt; "1011011111110110111011110000110001"<br>
12345654321.to_s(8) #=&gt; "133766736061"<br>
12345654321.to_s(16) #=&gt; "2dfdbbc31"<br>
78546939656932.to_s(36) #=&gt; "rubyrules"</span></li><li data-letters="jn" class=""><span class="matching-letter">jn</span> <span class="TermText qDef lang-en">Sets the class variable names by symbol to object. If the<br>
class variable name is passed as a string, that string is converted to a<br>
symbol.<br>
<br>
class Fred<br>
 @@foo = 99<br>
 def foo<br>
 @@foo<br>
 end<br>
end<br>
Fred.class_variable_set(:@@foo, 101) #=&gt; 101<br>
Fred.new.foo #=&gt; 101</span></li><li data-letters="jo" class=""><span class="matching-letter">jo</span> <span class="TermText qDef lang-en">Sets the environment variable name to value. If<br>
the value given is nil the environment variable is deleted.</span></li><li data-letters="jp" class=""><span class="matching-letter">jp</span> <span class="TermText qDef lang-en">Returns a list of names of captures as an array of strings.<br>
<br>
/(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.names<br>
#=&gt; ["foo", "bar", "baz"]<br>
<br>
/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.names<br>
#=&gt; ["foo"]<br>
<br>
/(.)(.)/.names<br>
#=&gt; []</span></li><li data-letters="jq" class=""><span class="matching-letter">jq</span> <span class="TermText qDef lang-en">Writes the given object(s) to ios. The stream must be opened for<br>
writing. If the output field separator ($,) is not<br>
nil, it will be inserted between each object. If the output<br>
record separator ($\&lt;/code&gt;) is not &lt;code&gt;nil, it<br>
will be appended to the output. If no arguments are given, prints<br>
$_. Objects that aren't strings will be converted by calling<br>
their to_s method. With no argument, prints the contents of<br>
the variable $_. Returns nil.<br>
<br>
$stdout.print("This is ", 100, " percent.\n")</span></li><li data-letters="jr" class=""><span class="matching-letter">jr</span> <span class="TermText qDef lang-en">Returns the number of elements in self. May be zero.<br>
<br>
[ 1, 2, 3, 4, 5 ].length #=&gt; 5<br>
[].length #=&gt; 0</span></li><li data-letters="js" class=""><span class="matching-letter">js</span> <span class="TermText qDef lang-en">Returns true if big is an even number.</span></li><li data-letters="jt" class=""><span class="matching-letter">jt</span> <span class="TermText qDef lang-en">Deletes the environment variable with name and returns the<br>
value of the variable. If a block is given it will be called when the<br>
named environment does not exist.</span></li><li data-letters="ju" class=""><span class="matching-letter">ju</span> <span class="TermText qDef lang-en">Returns (and assigns to $_) the next line from the list of<br>
files in ARGV (or $*), or from standard input if<br>
no files are present on the command line. Returns nil at end<br>
of file. The optional argument specifies the record separator. The<br>
separator is included with the contents of each record. A separator of<br>
nil reads the entire contents, and a zero-length separator<br>
reads the input one paragraph at a time, where paragraphs are divided by<br>
two consecutive newlines. If the first argument is an integer, or optional<br>
second argument is given, the returning string would not be longer than the<br>
given value in bytes. If multiple filenames are present in<br>
ARGV, +gets(nil)+ will read the contents one file at a time.<br>
<br>
ARGV &lt;&lt; "testfile"<br>
print while gets</span></li><li data-letters="jv" class=""><span class="matching-letter">jv</span> <span class="TermText qDef lang-en">Returns the absolute value of fix.<br>
<br>
-12345.abs #=&gt; 12345<br>
12345.abs #=&gt; 12345</span></li><li data-letters="jw" class=""><span class="matching-letter">jw</span> <span class="TermText qDef lang-en">Deletes all items from self that are equal to<br>
obj.<br>
<br>
a = [ "a", "b", "b", "b", "c" ]<br>
a.delete("b") #=&gt; "b"<br>
a #=&gt; ["a", "c"]<br>
a.delete("z") #=&gt; nil<br>
a.delete("z") { "not found" } #=&gt; "not found"</span></li><li data-letters="jx" class=""><span class="matching-letter">jx</span> <span class="TermText qDef lang-en">Returns the fraction for time.<br>
<br>
t = Time.now #=&gt; 2009-03-26 22:33:12 +0900<br>
"%10.9f" % t.to_f #=&gt; "1238074392.940563917"<br>
t.subsec #=&gt; (94056401/100000000)</span></li><li data-letters="jy" class=""><span class="matching-letter">jy</span> <span class="TermText qDef lang-en">Equivalent to ($_.dup).chop!, except nil is never<br>
returned. See String#chop!. Available only when -p/-n command<br>
line option specified.</span></li><li data-letters="jz" class=""><span class="matching-letter">jz</span> <span class="TermText qDef lang-en">Creates an enumerator for each chunked elements. The beginnings of chunks<br>
are defined by pattern and the block.<br>
<br>
enum.slice_before(pattern).each { |ary| ... }<br>
enum.slice_before { |elt| bool }.each { |ary| ... }<br>
enum.slice_before(initial_state) { |elt, state| bool }.each { |ary| ... }</span></li><li data-letters="ka" class=""><span class="matching-letter">ka</span> <span class="TermText qDef lang-en">Evaluates the given block in the context of the class/module. The method<br>
defined in the block will belong to the receiver.<br>
<br>
class Thing<br>
end<br>
Thing.class_exec{<br>
 def hello() "Hello there!" end<br>
}<br>
puts Thing.new.hello()</span></li><li data-letters="kb" class=""><span class="matching-letter">kb</span> <span class="TermText qDef lang-en">Deletes the element(s) given by an index (optionally up to<br>
length elements) or by a range.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.slice!(1) #=&gt; "b"<br>
a #=&gt; ["a", "c"]<br>
a.slice!(-1) #=&gt; "c"<br>
a #=&gt; ["a"]<br>
a.slice!(100) #=&gt; nil<br>
a #=&gt; ["a"]</span></li><li data-letters="kc" class=""><span class="matching-letter">kc</span> <span class="TermText qDef lang-en">Equivalent to $_ = $_.chomp(string). See<br>
String#chomp. Available only when -p/-n command line option<br>
specified.</span></li><li data-letters="kd" class=""><span class="matching-letter">kd</span> <span class="TermText qDef lang-en">Returns true if hash and other are both<br>
hashes with the same content.</span></li><li data-letters="ke" class=""><span class="matching-letter">ke</span> <span class="TermText qDef lang-en">Creates a new Enumerator object, which can be<br>
used as an Enumerable.<br>
<br>
fib = Enumerator.new do |y|<br>
 a = b = 1<br>
 loop do<br>
 y &lt;&lt; a<br>
 a, b = b, a + b<br>
 end<br>
end<br>
<br>
p fib.take(10) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></li><li data-letters="kf" class=""><span class="matching-letter">kf</span> <span class="TermText qDef lang-en">Checks for a constant with the given name in mod If<br>
inherit is set, the lookup will also search the ancestors (and<br>
Object if mod is a Module.)<br>
<br>
Math.const_get(:PI) #=&gt; 3.14159265358979</span></li><li data-letters="kg" class=""><span class="matching-letter">kg</span> <span class="TermText qDef lang-en">Writes the given string to ios using a low-level write. Returns<br>
the number of bytes written. Do not mix with other methods that write to<br>
ios or you may get unpredictable results. Raises<br>
SystemCallError on error.<br>
<br>
f = File.new("out", "w")<br>
f.syswrite("ABCDEF") #=&gt; 6</span></li><li data-letters="kh" class=""><span class="matching-letter">kh</span> <span class="TermText qDef lang-en">Unary Minus—Returns the receiver's value, negated.</span></li><li data-letters="ki" class=""><span class="matching-letter">ki</span> <span class="TermText qDef lang-en">Produces a shallow copy of obj—the instance variables of<br>
obj are copied, but not the objects they reference.<br>
dup copies the tainted state of obj. See also the<br>
discussion under Object#clone. In general, clone<br>
and dup may have different semantics in descendant classes.<br>
While clone is used to duplicate an object, including its<br>
internal state, dup typically uses the class of the descendant<br>
object to create the new instance.</span></li><li data-letters="kj" class=""><span class="matching-letter">kj</span> <span class="TermText qDef lang-en">Returns an array of symbols representing the names of the instance<br>
variables.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
joe.members #=&gt; [:name, :address, :zip]</span></li><li data-letters="kk" class=""><span class="matching-letter">kk</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block never returns false or<br>
nil. If the block is not given, Ruby adds an implicit block of<br>
{ |obj| obj } which will cause all? to return true<br>
when none of the collection members are false or<br>
nil.<br>
<br>
%w[ant bear cat].all? { |word| word.length &gt;= 3 } #=&gt; true<br>
%w[ant bear cat].all? { |word| word.length &gt;= 4 } #=&gt; false<br>
[nil, true, 99].all? #=&gt; false</span></li><li data-letters="kl" class=""><span class="matching-letter">kl</span> <span class="TermText qDef lang-en">Creates instance variables and corresponding methods that return the value<br>
of each instance variable. Equivalent to calling<br>
"attr:name" on each name in turn. String arguments are converted to symbols.</span></li><li data-letters="km" class=""><span class="matching-letter">km</span> <span class="TermText qDef lang-en">Equivalent to String#succ, but modifies the receiver in place.</span></li><li data-letters="kn" class=""><span class="matching-letter">kn</span> <span class="TermText qDef lang-en">Compares two objects based on the receiver's &lt;=&gt; method,<br>
returning true if it returns -1.</span></li><li data-letters="ko" class=""><span class="matching-letter">ko</span> <span class="TermText qDef lang-en">Returns the value as a rational.<br>
<br>
2.0.to_r #=&gt; (2/1)<br>
2.5.to_r #=&gt; (5/2)<br>
-0.75.to_r #=&gt; (-3/4)<br>
0.0.to_r #=&gt; (0/1)</span></li><li data-letters="kp" class=""><span class="matching-letter">kp</span> <span class="TermText qDef lang-en">Returns the absolute value of big.<br>
<br>
-1234567890987654321.abs #=&gt; 1234567890987654321</span></li><li data-letters="kq" class=""><span class="matching-letter">kq</span> <span class="TermText qDef lang-en">Returns true if the effective group id of the process is the same as the<br>
group id of stat. On Windows NT, returns false.<br>
<br>
File.stat("testfile").grpowned? #=&gt; true<br>
File.stat("/etc/passwd").grpowned? #=&gt; false</span></li><li data-letters="kr" class=""><span class="matching-letter">kr</span> <span class="TermText qDef lang-en">Returns a copy of str with the all occurrences of<br>
pattern substituted for the second argument. The pattern<br>
is typically a Regexp; if given as a String, any<br>
regular expression metacharacters it contains will be interpreted<br>
literally, e.g. '\\d' will match a backlash followed by 'd',<br>
instead of a digit.<br>
<br>
"hello".gsub(/[aeiou]/, '<b>') #=&gt; "h</b>ll*"<br>
"hello".gsub(/([aeiou])/, '&lt;\1&gt;') #=&gt; "h&lt;e&gt;ll&lt;o&gt;"<br>
"hello".gsub(/./) {|s| s.ord.to_s + ' '} #=&gt; "104 101 108 108 111 "<br>
"hello".gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}') #=&gt; "h{e}ll{o}"<br>
'hello'.gsub(/[eo]/, 'e' =&gt; 3, 'o' =&gt; '<b>') #=&gt; "h3ll</b>"</span></li><li data-letters="ks" class=""><span class="matching-letter">ks</span> <span class="TermText qDef lang-en">Immediately writes all buffered data in ios to disk.</span></li><li data-letters="kt" class=""><span class="matching-letter">kt</span> <span class="TermText qDef lang-en">Raises fix to the numeric power, which may be<br>
negative or fractional.<br>
<br>
2 ** 3 #=&gt; 8<br>
2 ** -1 #=&gt; (1/2)<br>
2 ** 0.5 #=&gt; 1.4142135623731</span></li><li data-letters="ku" class=""><span class="matching-letter">ku</span> <span class="TermText qDef lang-en">Returns the number of instance variables.<br>
<br>
Customer = Struct.new(:name, :address, :zip)<br>
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)<br>
joe.length #=&gt; 3</span></li><li data-letters="kv" class=""><span class="matching-letter">kv</span> <span class="TermText qDef lang-en">Packs the contents of arr into a binary sequence according to the<br>
directives in aTemplateString (see the table below) Directives<br>
"A," "a," and "Z" may be followed by a count, which gives the width of the<br>
resulting field. The remaining directives also may take a count, indicating<br>
the number of array elements to convert. If the count is an asterisk<br>
("*"), all remaining array elements will be converted. Any of<br>
the directives "sSiIlL" may be followed by an underscore<br>
("_") or exclamation mark ("!") to use the<br>
underlying platform's native size for the specified type; otherwise, they<br>
use a platform-independent size. Spaces are ignored in the template string.<br>
See also String#unpack.<br>
<br>
a = [ "a", "b", "c" ]<br>
n = [ 65, 66, 67 ]<br>
a.pack("A3A3A3") #=&gt; "a b c "<br>
a.pack("a3a3a3") #=&gt; "a\000\000b\000\000c\000\000"<br>
n.pack("ccc") #=&gt; "ABC"</span></li><li data-letters="kw" class=""><span class="matching-letter">kw</span> <span class="TermText qDef lang-en">Returns the Encoding object that represents the<br>
encoding of the file. If io is write mode and no encoding is specified,<br>
returns nil.</span></li><li data-letters="kx" class=""><span class="matching-letter">kx</span> <span class="TermText qDef lang-en">Returns default internal encoding. Strings will be transcoded to the<br>
default internal encoding in the following places if the default internal<br>
encoding is not nil:</span></li><li data-letters="ky" class=""><span class="matching-letter">ky</span> <span class="TermText qDef lang-en">Performs String#tr_s processing on str in place,<br>
returning str, or nil if no changes were made.</span></li><li data-letters="kz" class=""><span class="matching-letter">kz</span> <span class="TermText qDef lang-en">Returns an integer representing the permission bits of stat. The<br>
meaning of the bits is platform dependent; on Unix systems, see<br>
stat(2).<br>
<br>
File.chmod(0644, "testfile") #=&gt; 1<br>
s = File.stat("testfile")<br>
sprintf("%o", s.mode) #=&gt; "100644"</span></li><li data-letters="la" class=""><span class="matching-letter">la</span> <span class="TermText qDef lang-en">Creates a pair of pipe endpoints (connected to each other) and returns them<br>
as a two-element array of IO objects: [<br>
read_io, write_io ].<br>
<br>
rd, wr = IO.pipe<br>
<br>
if fork<br>
 wr.close<br>
 puts "Parent got: &lt;#{rd.read}&gt;"<br>
 rd.close<br>
 Process.wait<br>
else<br>
 rd.close<br>
 puts "Sending message to parent"<br>
 wr.write "Hi Dad"<br>
 wr.close<br>
end</span></li><li data-letters="lb" class=""><span class="matching-letter">lb</span> <span class="TermText qDef lang-en">Returns the last object in the range, or an array of the last<br>
n elements.<br>
<br>
(10..20).last #=&gt; 20<br>
(10...20).last #=&gt; 20<br>
(10..20).last(3) #=&gt; [18, 19, 20]<br>
(10...20).last(3) #=&gt; [17, 18, 19]</span></li><li data-letters="lc" class=""><span class="matching-letter">lc</span> <span class="TermText qDef lang-en">Returns the current offset (in bytes) of the current file in<br>
ARGF.<br>
<br>
ARGF.pos #=&gt; 0<br>
ARGF.gets #=&gt; "This is line one\n"<br>
ARGF.pos #=&gt; 17</span></li><li data-letters="ld" class=""><span class="matching-letter">ld</span> <span class="TermText qDef lang-en">Passes the Integer ordinal of each character in ios,<br>
passing the codepoint as an argument. The stream must be opened for reading<br>
or an IOError will be raised.</span></li><li data-letters="le" class=""><span class="matching-letter">le</span> <span class="TermText qDef lang-en">Returns the path to the current working directory of this process as a<br>
string.<br>
<br>
Dir.chdir("/tmp") #=&gt; 0<br>
Dir.getwd #=&gt; "/tmp"</span></li><li data-letters="lf" class=""><span class="matching-letter">lf</span> <span class="TermText qDef lang-en">Calls block once for each element in self, passing<br>
that element as a parameter, converting multiple values from yield to an<br>
array.<br>
<br>
class Foo<br>
 include Enumerable<br>
 def each<br>
 yield 1<br>
 yield 1, 2<br>
 yield<br>
 end<br>
end<br>
Foo.new.each_entry{ |o| p o }</span></li><li data-letters="lg" class=""><span class="matching-letter">lg</span> <span class="TermText qDef lang-en">Returns the first element, or the first n elements, of the<br>
enumerable. If the enumerable is empty, the first form returns<br>
nil, and the second form returns an empty array.<br>
<br>
%w[foo bar baz].first #=&gt; "foo"<br>
%w[foo bar baz].first(2) #=&gt; ["foo", "bar"]<br>
%w[foo bar baz].first(10) #=&gt; ["foo", "bar", "baz"]<br>
[].first #=&gt; nil</span></li><li data-letters="lh" class=""><span class="matching-letter">lh</span> <span class="TermText qDef lang-en">Returns true if the named file is executable by the effective<br>
user id of this process.</span></li><li data-letters="li" class=""><span class="matching-letter">li</span> <span class="TermText qDef lang-en">Returns the Integer equal to int + 1.<br>
<br>
1.next #=&gt; 2<br>
(-1).next #=&gt; 0</span></li><li data-letters="lj" class=""><span class="matching-letter">lj</span> <span class="TermText qDef lang-en">Returns an integer representing the day of the year, 1..366.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:32:31 -0600<br>
t.yday #=&gt; 323</span></li><li data-letters="lk" class=""><span class="matching-letter">lk</span> <span class="TermText qDef lang-en">This is a deprecated alias for each_codepoint.</span></li><li data-letters="ll" class=""><span class="matching-letter">ll</span> <span class="TermText qDef lang-en">Returns true only if obj is a Range, has equivalent begin and end items (by<br>
comparing them with ==), and has the same exclude_end? setting as the<br>
range.<br>
<br>
(0..2) == (0..2) #=&gt; true<br>
(0..2) == Range.new(0,2) #=&gt; true<br>
(0..2) == (0...2) #=&gt; false</span></li><li data-letters="lm" class=""><span class="matching-letter">lm</span> <span class="TermText qDef lang-en">If integer is greater than the length of str, returns a<br>
new String of length integer with str right<br>
justified and padded with padstr; otherwise, returns str.<br>
<br>
"hello".rjust(4) #=&gt; "hello"<br>
"hello".rjust(20) #=&gt; " hello"<br>
"hello".rjust(20, '1234') #=&gt; "123412341234123hello"</span></li><li data-letters="ln" class=""><span class="matching-letter">ln</span> <span class="TermText qDef lang-en">Returns a list of the public instance methods defined in mod. If<br>
the optional parameter is not false, the methods of any<br>
ancestors are included.</span></li><li data-letters="lo" class=""><span class="matching-letter">lo</span> <span class="TermText qDef lang-en">Searches through the array whose elements are also arrays.<br>
<br>
a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]<br>
a.rassoc("two") #=&gt; [2, "two"]<br>
a.rassoc("four") #=&gt; nil</span></li><li data-letters="lp" class=""><span class="matching-letter">lp</span> <span class="TermText qDef lang-en">Performs integer division: returns integer value.</span></li><li data-letters="lq" class=""><span class="matching-letter">lq</span> <span class="TermText qDef lang-en">catch executes its block. If a throw is executed,<br>
Ruby searches up its stack for a catch block with a tag<br>
corresponding to the throw's tag. If found, that<br>
block is terminated, and catch returns the value given to<br>
throw. If throw is not called, the block<br>
terminates normally, and the value of catch is the value of<br>
the last expression evaluated. catch expressions may be<br>
nested, and the throw call need not be in lexical scope.<br>
<br>
def routine(n)<br>
 puts n<br>
 throw :done if n &lt;= 0<br>
 routine(n-1)<br>
end<br>
<br>
catch(:done) { routine(3) }</span></li><li data-letters="lr" class=""><span class="matching-letter">lr</span> <span class="TermText qDef lang-en">Returns the key of an occurrence of a given value. If the value is not<br>
found, returns nil.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300, "d" =&gt; 300 }<br>
h.key(200) #=&gt; "b"<br>
h.key(300) #=&gt; "c"<br>
h.key(999) #=&gt; nil</span></li><li data-letters="ls" class=""><span class="matching-letter">ls</span> <span class="TermText qDef lang-en">Returns a new float which is the difference of float and<br>
other.</span></li><li data-letters="lt" class=""><span class="matching-letter">lt</span> <span class="TermText qDef lang-en">Returns the current offset (in bytes) of ios.<br>
<br>
f = File.new("testfile")<br>
f.pos #=&gt; 0<br>
f.gets #=&gt; "This is line one\n"<br>
f.pos #=&gt; 17</span></li><li data-letters="lu" class=""><span class="matching-letter">lu</span> <span class="TermText qDef lang-en">Reads length bytes from the I/O stream.<br>
<br>
f = File.new("testfile")<br>
f.read(16) #=&gt; "This is line one"<br>
<br>
# reads whole file<br>
open("file") {|f|<br>
 data = f.read # This returns a string even if the file is empty.<br>
 ...<br>
}<br>
<br>
# iterate over fixed length records.<br>
open("fixed-record-file") {|f|<br>
 while record = f.read(256)<br>
 ...<br>
 end<br>
}<br>
<br>
# iterate over variable length records.<br>
# record is prefixed by 32-bit length.<br>
open("variable-record-file") {|f|<br>
 while len = f.read(4)<br>
 len = len.unpack("N")[0] # 32-bit length<br>
 record = f.read(len) # This returns a string even if len is 0.<br>
 end<br>
}</span></li><li data-letters="lv" class=""><span class="matching-letter">lv</span> <span class="TermText qDef lang-en">Returns the filenames found by expanding pattern which is an<br>
Array of the patterns or the pattern String,<br>
either as an array or as parameters to the block. Note that this<br>
pattern is not a regexp (it's closer to a shell glob). See<br>
File::fnmatch for the meaning of the flags parameter.<br>
Note that case sensitivity depends on your system (so<br>
File::FNM_CASEFOLD is ignored), as does the order in which the<br>
results are returned.<br>
<br>
Dir["config.?"] #=&gt; ["config.h"]<br>
Dir.glob("config.?") #=&gt; ["config.h"]<br>
Dir.glob("*.[a-z][a-z]") #=&gt; ["main.rb"]<br>
Dir.glob("<b>.[^r]</b>") #=&gt; ["config.h"]<br>
Dir.glob("*.{rb,h}") #=&gt; ["main.rb", "config.h"]<br>
Dir.glob("*") #=&gt; ["config.h", "main.rb"]<br>
Dir.glob("*", File::FNM_DOTMATCH) #=&gt; [".", "..", "config.h", "main.rb"]<br>
<br>
rbfiles = File.join("*<b>", "</b>.rb")<br>
Dir.glob(rbfiles) #=&gt; ["main.rb",<br>
 # "lib/song.rb",<br>
 # "lib/song/karaoke.rb"]<br>
libdirs = File.join("**", "lib")<br>
Dir.glob(libdirs) #=&gt; ["lib"]<br>
<br>
librbfiles = File.join("*<b>", "lib", "</b><b>", "</b>.rb")<br>
Dir.glob(librbfiles) #=&gt; ["lib/song.rb",<br>
 # "lib/song/karaoke.rb"]<br>
<br>
librbfiles = File.join("*<b>", "lib", "</b>.rb")<br>
Dir.glob(librbfiles) #=&gt; ["lib/song.rb"]</span></li><li data-letters="lw" class=""><span class="matching-letter">lw</span> <span class="TermText qDef lang-en">Returns true if self and other are<br>
the same object, or are both arrays with the same content (according to Object#eql?).</span></li><li data-letters="lx" class=""><span class="matching-letter">lx</span> <span class="TermText qDef lang-en">Adds the contents of other_hash to hsh. If no block is<br>
specified, entries with duplicate keys are overwritten with the values from<br>
other_hash, otherwise the value of each duplicate key is<br>
determined by calling the block with the key, its value in hsh and<br>
its value in other_hash.<br>
<br>
h1 = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h2 = { "b" =&gt; 254, "c" =&gt; 300 }<br>
h1.merge!(h2) #=&gt; {"a"=&gt;100, "b"=&gt;254, "c"=&gt;300}<br>
<br>
h1 = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h2 = { "b" =&gt; 254, "c" =&gt; 300 }<br>
h1.merge!(h2) { |key, v1, v2| v1 }<br>
 #=&gt; {"a"=&gt;100, "b"=&gt;200, "c"=&gt;300}</span></li><li data-letters="ly" class=""><span class="matching-letter">ly</span> <span class="TermText qDef lang-en">Reads maxlen bytes from ios using a low-level read and<br>
returns them as a string. Do not mix with other methods that read from<br>
ios or you may get unpredictable results. If the optional<br>
outbuf argument is present, it must reference a String, which will receive the data. The<br>
outbuf will contain only the received data after the method call<br>
even if it is not empty at the beginning. Raises<br>
SystemCallError on error and EOFError at end of<br>
file.<br>
<br>
f = File.new("testfile")<br>
f.sysread(16) #=&gt; "This is line one"</span></li><li data-letters="lz" class=""><span class="matching-letter">lz</span> <span class="TermText qDef lang-en">Gets the next 8-bit byte (0..255) from ios. Returns<br>
nil if called at end of file.<br>
<br>
f = File.new("testfile")<br>
f.getbyte #=&gt; 84<br>
f.getbyte #=&gt; 104</span></li><li data-letters="ma" class=""><span class="matching-letter">ma</span> <span class="TermText qDef lang-en">true if flt is less than real. The<br>
result of NaN &lt; NaN is undefined, so the<br>
implementation-dependent value is returned.</span></li><li data-letters="mb" class=""><span class="matching-letter">mb</span> <span class="TermText qDef lang-en">Passes each byte in str to the given block, or returns an<br>
enumerator if no block is given.<br>
<br>
"hello".each_byte {|c| print c, ' ' }</span></li><li data-letters="mc" class=""><span class="matching-letter">mc</span> <span class="TermText qDef lang-en">Returns an enumerator which iterates over each line (separated by<br>
sep, which defaults to your platform's newline character) of each<br>
file in ARGV. If a block is supplied, each line in turn will<br>
be yielded to the block, otherwise an enumerator is returned. The optional<br>
limit argument is a Fixnum specifying the maximum<br>
length of each line; longer lines will be split according to this limit.<br>
<br>
ARGF.lines do |line|<br>
 puts ARGF.filename if ARGF.lineno == 1<br>
 puts "#{ARGF.lineno}: #{line}"<br>
end</span></li><li data-letters="md" class=""><span class="matching-letter">md</span> <span class="TermText qDef lang-en">Executes the block for every line in the named I/O port, where lines are<br>
separated by sep.<br>
<br>
IO.foreach("testfile") {|x| print "GOT ", x }</span></li><li data-letters="me" class=""><span class="matching-letter">me</span> <span class="TermText qDef lang-en">Comparison—Returns -1, 0, or +1 depending on whether big is<br>
less than, equal to, or greater than numeric. This is the<br>
basis for the tests in Comparable.</span></li><li data-letters="mf" class=""><span class="matching-letter">mf</span> <span class="TermText qDef lang-en">If file_name is writable by others, returns an integer<br>
representing the file permission bits of file_name. Returns<br>
nil otherwise. The meaning of the bits is platform dependent;<br>
on Unix systems, see stat(2).<br>
<br>
File.world_writable?("/tmp") #=&gt; 511<br>
m = File.world_writable?("/tmp")<br>
sprintf("%o", m) #=&gt; "777"</span></li><li data-letters="mg" class=""><span class="matching-letter">mg</span> <span class="TermText qDef lang-en">Prints each object in turn to $stdout. If the output field<br>
separator ($,) is not nil, its contents will<br>
appear between each field. If the output record separator<br>
($\&lt;/code&gt;) is not nil, it will be appended to the output. If<br>
no arguments are given, prints &lt;code&gt;$_. Objects that aren't<br>
strings will be converted by calling their to_s method.<br>
<br>
print "cat", [1,2,3], 99, "\n"<br>
$, = ", "<br>
$\ = "\n"<br>
print "cat", [1,2,3], 99</span></li><li data-letters="mh" class=""><span class="matching-letter">mh</span> <span class="TermText qDef lang-en">Registers filename to be loaded (using<br>
Kernel::require) the first time that module (which<br>
may be a String or a symbol) is accessed.<br>
<br>
autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")</span></li><li data-letters="mi" class=""><span class="matching-letter">mi</span> <span class="TermText qDef lang-en">Returns the character length of str.</span></li><li data-letters="mj" class=""><span class="matching-letter">mj</span> <span class="TermText qDef lang-en">Deletes the named files, returning the number of names passed as arguments.<br>
Raises an exception on any error. See also Dir::rmdir.</span></li><li data-letters="mk" class=""><span class="matching-letter">mk</span> <span class="TermText qDef lang-en">Equivalent to File::chmod, but does not follow symbolic links<br>
(so it will change the permissions associated with the link, not the file<br>
referenced by the link). Often not available.</span></li><li data-letters="ml" class=""><span class="matching-letter">ml</span> <span class="TermText qDef lang-en">Returns the value of the given class variable (or throws a<br>
NameError exception). The @@ part of the variable<br>
name should be included for regular class variables String arguments are converted to symbols.<br>
<br>
class Fred<br>
 @@foo = 99<br>
end<br>
Fred.class_variable_get(:@@foo) #=&gt; 99</span></li><li data-letters="mm" class=""><span class="matching-letter">mm</span> <span class="TermText qDef lang-en">Same as sym.to_s.succ.intern.</span></li><li data-letters="mn" class=""><span class="matching-letter">mn</span> <span class="TermText qDef lang-en">Deletes every element of self for which the given block<br>
evaluates to false.<br>
<br>
a = %w{ a b c d e f }<br>
a.keep_if { |v| v =~ /[aeiou]/ } #=&gt; ["a", "e"]</span></li><li data-letters="mo" class=""><span class="matching-letter">mo</span> <span class="TermText qDef lang-en">Returns an array of the Integer ordinals of the characters in<br>
str. This is a shorthand for<br>
str.each_codepoint.to_a.</span></li><li data-letters="mp" class=""><span class="matching-letter">mp</span> <span class="TermText qDef lang-en">Rounds flt to a given precision in decimal digits (default 0<br>
digits). Precision may be negative. Returns a floating point number when<br>
ndigits is more than zero.<br>
<br>
1.4.round #=&gt; 1<br>
1.5.round #=&gt; 2<br>
1.6.round #=&gt; 2<br>
(-1.5).round #=&gt; -2<br>
<br>
1.234567.round(2) #=&gt; 1.23<br>
1.234567.round(3) #=&gt; 1.235<br>
1.234567.round(4) #=&gt; 1.2346<br>
1.234567.round(5) #=&gt; 1.23457<br>
<br>
34567.89.round(-5) #=&gt; 0<br>
34567.89.round(-4) #=&gt; 30000<br>
34567.89.round(-3) #=&gt; 35000<br>
34567.89.round(-2) #=&gt; 34600<br>
34567.89.round(-1) #=&gt; 34570<br>
34567.89.round(0) #=&gt; 34568<br>
34567.89.round(1) #=&gt; 34567.9<br>
34567.89.round(2) #=&gt; 34567.89<br>
34567.89.round(3) #=&gt; 34567.89</span></li><li data-letters="mq" class=""><span class="matching-letter">mq</span> <span class="TermText qDef lang-en">Returns zero if number equals other, otherwise<br>
nil is returned if the two values are incomparable.</span></li><li data-letters="mr" class=""><span class="matching-letter">mr</span> <span class="TermText qDef lang-en">Returns the last access time for the named file as a Time object).<br>
<br>
File.atime("testfile") #=&gt; Wed Apr 09 08:51:48 CDT 2003</span></li><li data-letters="ms" class=""><span class="matching-letter">ms</span> <span class="TermText qDef lang-en">Returns an array of bytes in str. This is a shorthand for<br>
str.each_byte.to_a.</span></li><li data-letters="mt" class=""><span class="matching-letter">mt</span> <span class="TermText qDef lang-en">Returns true if time represents Sunday.<br>
<br>
t = Time.local(1990, 4, 1) #=&gt; 1990-04-01 00:00:00 -0600<br>
t.sunday? #=&gt; true</span></li><li data-letters="mu" class=""><span class="matching-letter">mu</span> <span class="TermText qDef lang-en">Returns the year for time (including the century).<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:27:51 -0600<br>
t.year #=&gt; 2007</span></li><li data-letters="mv" class=""><span class="matching-letter">mv</span> <span class="TermText qDef lang-en">Describe the contents of this struct in a string.</span></li><li data-letters="mw" class=""><span class="matching-letter">mw</span> <span class="TermText qDef lang-en">Returns true if ios is associated with a terminal<br>
device (tty), false otherwise.<br>
<br>
File.new("testfile").isatty #=&gt; false<br>
File.new("/dev/tty").isatty #=&gt; true</span></li><li data-letters="mx" class=""><span class="matching-letter">mx</span> <span class="TermText qDef lang-en">Both forms iterate through str, matching the pattern (which may be<br>
a Regexp or a String). For each match, a result<br>
is generated and either added to the result array or passed to the block.<br>
If the pattern contains no groups, each individual result consists of the<br>
matched string, $&amp;. If the pattern contains groups, each<br>
individual result is itself an array containing one entry per group.<br>
<br>
a = "cruel world"<br>
a.scan(/\w+/) #=&gt; ["cruel", "world"]<br>
a.scan(/.../) #=&gt; ["cru", "el ", "wor"]<br>
a.scan(/(...)/) #=&gt; [["cru"], ["el "], ["wor"]]<br>
a.scan(/(..)(..)/) #=&gt; [["cr", "ue"], ["l ", "wo"]]</span></li><li data-letters="my" class=""><span class="matching-letter">my</span> <span class="TermText qDef lang-en">Translates str in place, using the same rules as<br>
String#tr. Returns str, or nil if no<br>
changes were made.</span></li><li data-letters="mz" class=""><span class="matching-letter">mz</span> <span class="TermText qDef lang-en">Trap attempts to add methods to Numeric objects. Always raises<br>
a TypeError</span></li><li data-letters="na" class=""><span class="matching-letter">na</span> <span class="TermText qDef lang-en">Returns the superclass of class, or nil.<br>
<br>
File.superclass #=&gt; IO<br>
IO.superclass #=&gt; Object<br>
Object.superclass #=&gt; BasicObject<br>
class Foo; end<br>
class Bar &lt; Foo; end<br>
Bar.superclass #=&gt; Foo</span></li><li data-letters="nb" class=""><span class="matching-letter">nb</span> <span class="TermText qDef lang-en">Returns true if the named file exists and has a zero size.</span></li><li data-letters="nc" class=""><span class="matching-letter">nc</span> <span class="TermText qDef lang-en">::copy_stream copies<br>
src to dst. src and dst is either a<br>
filename or an IO.</span></li><li data-letters="nd" class=""><span class="matching-letter">nd</span> <span class="TermText qDef lang-en">Converts the environment variables into an array of names and value arrays.<br>
<br>
ENV.to_a # =&gt; [["TERM", "xterm-color"], ["SHELL", "/bin/bash"], ...]</span></li><li data-letters="ne" class=""><span class="matching-letter">ne</span> <span class="TermText qDef lang-en">Builds a set of characters from the other_str parameter(s) using<br>
the procedure described for String#count. Returns a new string<br>
where runs of the same character that occur in this set are replaced by a<br>
single character. If no arguments are given, all runs of identical<br>
characters are replaced by a single character.<br>
<br>
"yellow moon".squeeze #=&gt; "yelow mon"<br>
" now is the".squeeze(" ") #=&gt; " now is the"<br>
"putters shoot balls".squeeze("m-z") #=&gt; "puters shot balls"</span></li><li data-letters="nf" class=""><span class="matching-letter">nf</span> <span class="TermText qDef lang-en">Format—Uses str as a format specification, and returns the result<br>
of applying it to arg. If the format specification contains more<br>
than one substitution, then arg must be an Array or<br>
Hash containing the values to be substituted. See<br>
Kernel::sprintf for details of the format string.<br>
<br>
"%05d" % 123 #=&gt; "00123"<br>
"%-5s: %08x" % [ "ID", self.object_id ] #=&gt; "ID : 200e14d6"<br>
"foo = %{foo}" % { :foo =&gt; 'bar' } #=&gt; "foo = bar"</span></li><li data-letters="ng" class=""><span class="matching-letter">ng</span> <span class="TermText qDef lang-en">Reads a one-character string from ios. Raises an<br>
EOFError on end of file.<br>
<br>
f = File.new("testfile")<br>
f.readchar #=&gt; "h"<br>
f.readchar #=&gt; "e"</span></li><li data-letters="nh" class=""><span class="matching-letter">nh</span> <span class="TermText qDef lang-en">Returns true if obj responds to the given method. <br>
Private and protected methods are included in the search only if the<br>
optional second parameter evaluates to true.</span></li><li data-letters="ni" class=""><span class="matching-letter">ni</span> <span class="TermText qDef lang-en">Compares two objects based on the receiver's &lt;=&gt; method,<br>
returning true if it returns 0 or 1.</span></li><li data-letters="nj" class=""><span class="matching-letter">nj</span> <span class="TermText qDef lang-en">Alias of Random::DEFAULT.rand.</span></li><li data-letters="nk" class=""><span class="matching-letter">nk</span> <span class="TermText qDef lang-en">Returns true for a string which has only ASCII characters.<br>
<br>
"abc".force_encoding("UTF-8").ascii_only? #=&gt; true<br>
"abc\u{6666}".force_encoding("UTF-8").ascii_only? #=&gt; false</span></li><li data-letters="nl" class=""><span class="matching-letter">nl</span> <span class="TermText qDef lang-en">If obj is Numeric, write the character whose code is<br>
the least-significant byte of obj, otherwise write the first byte<br>
of the string representation of obj to ios. Note: This<br>
method is not safe for use with multi-byte characters as it will truncate<br>
them.<br>
<br>
$stdout.putc "A"<br>
$stdout.putc 65</span></li><li data-letters="nm" class=""><span class="matching-letter">nm</span> <span class="TermText qDef lang-en">Returns the denominator (always positive).</span></li><li data-letters="nn" class=""><span class="matching-letter">nn</span> <span class="TermText qDef lang-en">Same as sym.to_s.swapcase.intern.</span></li><li data-letters="no" class=""><span class="matching-letter">no</span> <span class="TermText qDef lang-en">Returns the current position in dir. See also<br>
Dir#seek.<br>
<br>
d = Dir.new("testdir")<br>
d.tell #=&gt; 0<br>
d.read #=&gt; "."<br>
d.tell #=&gt; 12</span></li><li data-letters="np" class=""><span class="matching-letter">np</span> <span class="TermText qDef lang-en">Invoked when a reference is made to an undefined constant in mod.<br>
It is passed a symbol for the undefined constant, and returns a value to be<br>
used for that constant. The following code is an example of the same:<br>
<br>
def Foo.const_missing(name)<br>
 name # return the constant name as Symbol<br>
end<br>
<br>
Foo::UNDEFINED_CONST #=&gt; :UNDEFINED_CONST: symbol returned</span></li><li data-letters="nq" class=""><span class="matching-letter">nq</span> <span class="TermText qDef lang-en">Iterates block, passing decreasing values from int down<br>
to and including limit.<br>
<br>
5.downto(1) { |n| print n, ".. " }<br>
print " Liftoff!\n"</span></li><li data-letters="nr" class=""><span class="matching-letter">nr</span> <span class="TermText qDef lang-en">Creates a Time object based on given values,<br>
interpreted as UTC (GMT). The year must be specified. Other values default<br>
to the minimum value for that field (and may be nil or<br>
omitted). Months may be specified by numbers from 1 to 12, or by the<br>
three-letter English month names. Hours are specified on a 24-hour clock<br>
(0..23). Raises an ArgumentError if any<br>
values are out of range. Will also accept ten arguments in the order output<br>
by #to_a.<br>
<br>
Time.utc(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC<br>
Time.gm(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 UTC</span></li><li data-letters="ns" class=""><span class="matching-letter">ns</span> <span class="TermText qDef lang-en">Returns true if yield would execute a block in<br>
the current context. The iterator? form is mildly deprecated.<br>
<br>
def try<br>
 if block_given?<br>
 yield<br>
 else<br>
 "no block"<br>
 end<br>
end<br>
try #=&gt; "no block"<br>
try { "hello" } #=&gt; "hello"<br>
try do "hello" end #=&gt; "hello"</span></li><li data-letters="nt" class=""><span class="matching-letter">nt</span> <span class="TermText qDef lang-en">Iterates the given block for each slice of &lt;n&gt; elements. If no block<br>
is given, returns an enumerator.<br>
<br>
(1..10).each_slice(3) { |a| p a }<br>
# outputs below<br>
[1, 2, 3]<br>
[4, 5, 6]<br>
[7, 8, 9]<br>
[10]</span></li><li data-letters="nu" class=""><span class="matching-letter">nu</span> <span class="TermText qDef lang-en">And—Returns false. obj is always evaluated as it is<br>
the argument to a method call—there is no short-circuit evaluation in this<br>
case.</span></li><li data-letters="nv" class=""><span class="matching-letter">nv</span> <span class="TermText qDef lang-en">Deletes the specified portion from str, and returns the portion<br>
deleted.<br>
<br>
string = "this is a string"<br>
string.slice!(2) #=&gt; "i"<br>
string.slice!(3..6) #=&gt; " is "<br>
string.slice!(/s.*t/) #=&gt; "sa st"<br>
string.slice!("r") #=&gt; "r"<br>
string #=&gt; "thing"</span></li><li data-letters="nw" class=""><span class="matching-letter">nw</span> <span class="TermText qDef lang-en">By using binary search, finds a value in range which meets the given<br>
condition in O(log n) where n is the size of the array.<br>
<br>
ary = [0, 4, 7, 10, 12]<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 4 } #=&gt; 1<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 6 } #=&gt; 2<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 8 } #=&gt; 3<br>
(0...ary.size).bsearch {|i| ary[i] &gt;= 100 } #=&gt; nil<br>
<br>
(0.0...Float::INFINITY).bsearch {|x| Math.log(x) &gt;= 0 } #=&gt; 1.0</span></li><li data-letters="nx" class=""><span class="matching-letter">nx</span> <span class="TermText qDef lang-en">Returns the portion of the original string after the current match.<br>
Equivalent to the special variable $'.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")<br>
m.post_match #=&gt; ": The Movie"</span></li><li data-letters="ny" class=""><span class="matching-letter">ny</span> <span class="TermText qDef lang-en">Removes all key-value pairs from hsh.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 } #=&gt; {"a"=&gt;100, "b"=&gt;200}<br>
h.clear #=&gt; {}</span></li><li data-letters="nz" class=""><span class="matching-letter">nz</span> <span class="TermText qDef lang-en">Returns the object in enum with the minimum value. The first form<br>
assumes all objects implement Comparable; the second uses the<br>
block to return a &lt;=&gt; b.<br>
<br>
a = %w(albatross dog horse)<br>
a.min #=&gt; "albatross"<br>
a.min { |a, b| a.length &lt;=&gt; b.length } #=&gt; "dog"</span></li><li data-letters="oa" class=""><span class="matching-letter">oa</span> <span class="TermText qDef lang-en">Processes a copy of str as described under String#tr,<br>
then removes duplicate characters in regions that were affected by the<br>
translation.<br>
<br>
"hello".tr_s('l', 'r') #=&gt; "hero"<br>
"hello".tr_s('el', '<b>') #=&gt; "h</b>o"<br>
"hello".tr_s('el', 'hx') #=&gt; "hhxo"</span></li><li data-letters="ob" class=""><span class="matching-letter">ob</span> <span class="TermText qDef lang-en">Loads and executes the Ruby program in the file filename. If the<br>
filename does not resolve to an absolute path, the file is searched for in<br>
the library directories listed in $:. If the optional<br>
wrap parameter is true, the loaded script will be<br>
executed under an anonymous module, protecting the calling program's global<br>
namespace. In no circumstance will any local variables in the loaded file<br>
be propagated to the loading environment.</span></li><li data-letters="oc" class=""><span class="matching-letter">oc</span> <span class="TermText qDef lang-en">Converts a pathname to an absolute pathname. Relative paths are referenced<br>
from the current working directory of the process unless<br>
dir_string is given, in which case it will be used as the starting<br>
point. If the given pathname starts with a "~" it is NOT<br>
expanded, it is treated as a normal directory name.<br>
<br>
File.absolute_path("~oracle/bin") #=&gt; "&lt;relative_path&gt;/~oracle/bin"</span></li><li data-letters="od" class=""><span class="matching-letter">od</span> <span class="TermText qDef lang-en">Same as IO.write except opening the file in binary mode and<br>
ASCII-8BIT encoding ("wb:ASCII-8BIT").</span></li><li data-letters="oe" class=""><span class="matching-letter">oe</span> <span class="TermText qDef lang-en">Repeatedly executes the block.<br>
<br>
loop do<br>
 print "Input: "<br>
 line = gets<br>
 break if !line or line =~ /^qQ/<br>
 # ...<br>
end</span></li><li data-letters="of" class=""><span class="matching-letter">of</span> <span class="TermText qDef lang-en">Invokes Module.append_features on each parameter in reverse<br>
order.</span></li><li data-letters="og" class=""><span class="matching-letter">og</span> <span class="TermText qDef lang-en">Returns "ENV"</span></li><li data-letters="oh" class=""><span class="matching-letter">oh</span> <span class="TermText qDef lang-en">Returns the number of hard links to stat.<br>
<br>
File.stat("testfile").nlink #=&gt; 1<br>
File.link("testfile", "testfile.bak") #=&gt; 0<br>
File.stat("testfile").nlink #=&gt; 2</span></li><li data-letters="oi" class=""><span class="matching-letter">oi</span> <span class="TermText qDef lang-en">Returns a list of modules included in mod (including mod<br>
itself).<br>
<br>
module Mod<br>
 include Math<br>
 include Comparable<br>
end<br>
<br>
Mod.ancestors #=&gt; [Mod, Comparable, Math]<br>
Math.ancestors #=&gt; [Math]</span></li><li data-letters="oj" class=""><span class="matching-letter">oj</span> <span class="TermText qDef lang-en">Convert this range object to a printable form (using inspect<br>
to convert the begin and end objects).</span></li><li data-letters="ok" class=""><span class="matching-letter">ok</span> <span class="TermText qDef lang-en">Creates a new name for an existing file using a hard link. Will not<br>
overwrite new_name if it already exists (raising a subclass of<br>
SystemCallError). Not available on all platforms.<br>
<br>
File.link("testfile", ".testfile") #=&gt; 0<br>
IO.readlines(".testfile")[0] #=&gt; "This is line one\n"</span></li><li data-letters="ol" class=""><span class="matching-letter">ol</span> <span class="TermText qDef lang-en">Returns true if stat is a symbolic link,<br>
false if it isn't or if the operating system doesn't support<br>
this feature. As File::stat automatically follows symbolic<br>
links, symlink? will always be false for an<br>
object returned by File::stat.<br>
<br>
File.symlink("testfile", "alink") #=&gt; 0<br>
File.stat("alink").symlink? #=&gt; false<br>
File.lstat("alink").symlink? #=&gt; true</span></li><li data-letters="om" class=""><span class="matching-letter">om</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block ever returns a value other than<br>
false or nil. If the block is not given, Ruby<br>
adds an implicit block of { |obj| obj } that will cause any? to return true<br>
if at least one of the collection members is not false or<br>
nil.<br>
<br>
%w[ant bear cat].any? { |word| word.length &gt;= 3 } #=&gt; true<br>
%w[ant bear cat].any? { |word| word.length &gt;= 4 } #=&gt; true<br>
[nil, true, 99].any? #=&gt; true</span></li><li data-letters="on" class=""><span class="matching-letter">on</span> <span class="TermText qDef lang-en">Creates a string representation of self.<br>
<br>
[ "a", "b", "c" ].to_s #=&gt; "[\"a\", \"b\", \"c\"]"</span></li><li data-letters="oo" class=""><span class="matching-letter">oo</span> <span class="TermText qDef lang-en">Pattern Match—Overridden by descendants (notably Regexp and<br>
String) to provide meaningful pattern-match semantics.</span></li><li data-letters="op" class=""><span class="matching-letter">op</span> <span class="TermText qDef lang-en">Unary Plus—Returns the receiver's value.</span></li><li data-letters="oq" class=""><span class="matching-letter">oq</span> <span class="TermText qDef lang-en">Same as Hash#delete_if, but works on (and returns) a copy of<br>
the hsh. Equivalent to hsh.dup.delete_if.</span></li><li data-letters="or" class=""><span class="matching-letter">or</span> <span class="TermText qDef lang-en">Calls block with two arguments, the item and its index, for each<br>
item in enum. Given arguments are passed through to each().<br>
<br>
hash = Hash.new<br>
%w(cat dog wombat).each_with_index { |item, index|<br>
 hash[item] = index<br>
}<br>
hash #=&gt; {"cat"=&gt;0, "dog"=&gt;1, "wombat"=&gt;2}</span></li><li data-letters="os" class=""><span class="matching-letter">os</span> <span class="TermText qDef lang-en">Converts arg to a Hash by calling<br>
arg.to_hash. Returns an empty Hash when<br>
arg is nil or [].<br>
<br>
Hash([]) #=&gt; {}<br>
Hash(nil) #=&gt; nil<br>
Hash(key: :value) #=&gt; {:key =&gt; :value}<br>
Hash([1, 2, 3]) #=&gt; TypeError</span></li><li data-letters="ot" class=""><span class="matching-letter">ot</span> <span class="TermText qDef lang-en">Returns an array of lines in str split using the supplied record<br>
separator ($/ by default). This is a shorthand for<br>
str.each_line(separator).to_a.</span></li><li data-letters="ou" class=""><span class="matching-letter">ou</span> <span class="TermText qDef lang-en">Positions ios to the beginning of input, resetting<br>
lineno to zero.<br>
<br>
f = File.new("testfile")<br>
f.readline #=&gt; "This is line one\n"<br>
f.rewind #=&gt; 0<br>
f.lineno #=&gt; 0<br>
f.readline #=&gt; "This is line one\n"</span></li><li data-letters="ov" class=""><span class="matching-letter">ov</span> <span class="TermText qDef lang-en">Returns true if stat is a regular file (not a device<br>
file, pipe, socket, etc.).<br>
<br>
File.stat("testfile").file? #=&gt; true</span></li><li data-letters="ow" class=""><span class="matching-letter">ow</span> <span class="TermText qDef lang-en">Exclusive Or—If obj is nil or false,<br>
returns false; otherwise, returns true.</span></li><li data-letters="ox" class=""><span class="matching-letter">ox</span> <span class="TermText qDef lang-en">Iterates block, passing in integer values from int up to<br>
and including limit.<br>
<br>
5.upto(10) { |i| print i, " " }</span></li><li data-letters="oy" class=""><span class="matching-letter">oy</span> <span class="TermText qDef lang-en">Returns the next object in the enumerator, and move the internal position<br>
forward. When the position reached at the end, StopIteration is raised.<br>
<br>
a = [1,2,3]<br>
e = a.to_enum<br>
p e.next #=&gt; 1<br>
p e.next #=&gt; 2<br>
p e.next #=&gt; 3<br>
p e.next #raises StopIteration</span></li><li data-letters="oz" class=""><span class="matching-letter">oz</span> <span class="TermText qDef lang-en">Returns the contents of the environment as a String.</span></li><li data-letters="pa" class=""><span class="matching-letter">pa</span> <span class="TermText qDef lang-en">Same as IO#stat, but does not follow the last symbolic link.<br>
Instead, reports on the link itself.<br>
<br>
File.symlink("testfile", "link2test") #=&gt; 0<br>
File.stat("testfile").size #=&gt; 66<br>
f = File.new("link2test")<br>
f.lstat.size #=&gt; 8<br>
f.stat.size #=&gt; 66</span></li><li data-letters="pb" class=""><span class="matching-letter">pb</span> <span class="TermText qDef lang-en">Returns the largest integer less than or equal to flt.<br>
<br>
1.2.floor #=&gt; 1<br>
2.0.floor #=&gt; 2<br>
(-1.2).floor #=&gt; -2<br>
(-2.0).floor #=&gt; -2</span></li><li data-letters="pc" class=""><span class="matching-letter">pc</span> <span class="TermText qDef lang-en">Returns float division.</span></li><li data-letters="pd" class=""><span class="matching-letter">pd</span> <span class="TermText qDef lang-en">Yields x to the block, and then returns x. The<br>
primary purpose of this method is to "tap into" a method chain, in order to<br>
perform operations on intermediate results within the chain.<br>
<br>
(1..10) .tap {|x| puts "original: #{x.inspect}"}<br>
 .to_a .tap {|x| puts "array: #{x.inspect}"}<br>
 .select {|x| x%2==0} .tap {|x| puts "evens: #{x.inspect}"}<br>
 .map { |x| x*x } .tap {|x| puts "squares: #{x.inspect}"}</span></li><li data-letters="pe" class=""><span class="matching-letter">pe</span> <span class="TermText qDef lang-en">Returns the names of the current local variables.<br>
<br>
fred = 1<br>
for i in 1..10<br>
 # ...<br>
end<br>
local_variables #=&gt; [:fred, :i]</span></li><li data-letters="pf" class=""><span class="matching-letter">pf</span> <span class="TermText qDef lang-en">Removes duplicate elements from self.<br>
<br>
a = [ "a", "a", "b", "b", "c" ]<br>
a.uniq! # =&gt; ["a", "b", "c"]<br>
<br>
b = [ "a", "b", "c" ]<br>
b.uniq! # =&gt; nil<br>
<br>
c = [["student^!^sam"], ["student^!^george"], ["teacher^!^matz"]]<br>
c.uniq! { |s| s.first } # =&gt; [["student", "sam"], ["teacher", "matz"]]</span></li><li data-letters="pg" class=""><span class="matching-letter">pg</span> <span class="TermText qDef lang-en">Iterates block int times, passing in values from zero to<br>
int - 1.<br>
<br>
5.times do |i|<br>
 print i, " "<br>
end</span></li><li data-letters="ph" class=""><span class="matching-letter">ph</span> <span class="TermText qDef lang-en">Concatenation—Returns a new String containing<br>
other_str concatenated to str.<br>
<br>
"Hello from " + self.to_s #=&gt; "Hello from main"</span></li><li data-letters="pi" class=""><span class="matching-letter">pi</span> <span class="TermText qDef lang-en">Invokes the given block once for each element of self.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.map { |x| x + "!" } #=&gt; ["a!", "b!", "c!", "d!"]<br>
a #=&gt; ["a", "b", "c", "d"]</span></li><li data-letters="pj" class=""><span class="matching-letter">pj</span> <span class="TermText qDef lang-en">Returns an array of instance variable names for the receiver. Note that<br>
simply defining an accessor does not create the corresponding instance<br>
variable.<br>
<br>
class Fred<br>
 attr_accessor :a1<br>
 def initialize<br>
 @iv = 3<br>
 end<br>
end<br>
Fred.new.instance_variables #=&gt; [:@iv]</span></li><li data-letters="pk" class=""><span class="matching-letter">pk</span> <span class="TermText qDef lang-en">Returns true only if obj has the same value as<br>
big. Contrast this with Bignum#eql?, which requires<br>
obj to be a Bignum.<br>
<br>
68719476736 == 68719476736.0 #=&gt; true</span></li><li data-letters="pl" class=""><span class="matching-letter">pl</span> <span class="TermText qDef lang-en">Synonym for IO.new.</span></li><li data-letters="pm" class=""><span class="matching-letter">pm</span> <span class="TermText qDef lang-en">Returns true if path matches against pattern The pattern<br>
is not a regular expression; instead it follows rules similar to shell<br>
filename globbing. It may contain the following metacharacters:<br>
<br>
File.fnmatch('cat', 'cat') #=&gt; true # match entire string<br>
File.fnmatch('cat', 'category') #=&gt; false # only match partial string<br>
<br>
File.fnmatch('c{at,ub}s', 'cats') #=&gt; false # { } isn't supported by default<br>
File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=&gt; true # { } is supported on FNM_EXTGLOB<br>
<br>
File.fnmatch('c?t', 'cat') #=&gt; true # '?' match only 1 character<br>
File.fnmatch('c??t', 'cat') #=&gt; false # ditto<br>
File.fnmatch('c<b>', 'cats') #=&gt; true # '</b>' match 0 or more characters<br>
File.fnmatch('c*t', 'c/a/b/t') #=&gt; true # ditto<br>
File.fnmatch('ca[a-z]', 'cat') #=&gt; true # inclusive bracket expression<br>
File.fnmatch('ca[^t]', 'cat') #=&gt; false # exclusive bracket expression ('^' or '!')<br>
<br>
File.fnmatch('cat', 'CAT') #=&gt; false # case sensitive<br>
File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=&gt; true # case insensitive<br>
<br>
File.fnmatch('?', '/', File::FNM_PATHNAME) #=&gt; false # wildcard doesn't match '/' on FNM_PATHNAME<br>
File.fnmatch('*', '/', File::FNM_PATHNAME) #=&gt; false # ditto<br>
File.fnmatch('[/]', '/', File::FNM_PATHNAME) #=&gt; false # ditto<br>
<br>
File.fnmatch('\?', '?') #=&gt; true # escaped wildcard becomes ordinary<br>
File.fnmatch('\a', 'a') #=&gt; true # escaped ordinary remains ordinary<br>
File.fnmatch('\a', '\a', File::FNM_NOESCAPE) #=&gt; true # FNM_NOESCAPE makes '\' ordinary<br>
File.fnmatch('[\?]', '?') #=&gt; true # can escape inside bracket expression<br>
<br>
File.fnmatch('*', '.profile') #=&gt; false # wildcard doesn't match leading<br>
File.fnmatch('*', '.profile', File::FNM_DOTMATCH) #=&gt; true # period by default.<br>
File.fnmatch('.*', '.profile') #=&gt; true<br>
<br>
rbfiles = '*<b>' '/' '</b>.rb' # you don't have to do like this. just write in single string.<br>
File.fnmatch(rbfiles, 'main.rb') #=&gt; false<br>
File.fnmatch(rbfiles, './main.rb') #=&gt; false<br>
File.fnmatch(rbfiles, 'lib/song.rb') #=&gt; true<br>
File.fnmatch('**.rb', 'main.rb') #=&gt; true<br>
File.fnmatch('**.rb', './main.rb') #=&gt; false<br>
File.fnmatch('**.rb', 'lib/song.rb') #=&gt; true<br>
File.fnmatch('*', 'dave/.profile') #=&gt; true<br>
<br>
pattern = '<b>' '/' '</b>'<br>
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME) #=&gt; false<br>
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=&gt; true<br>
<br>
pattern = '**' '/' 'foo'<br>
File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME) #=&gt; true<br>
File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME) #=&gt; true<br>
File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME) #=&gt; true<br>
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME) #=&gt; false<br>
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=&gt; true</span></li><li data-letters="pn" class=""><span class="matching-letter">pn</span> <span class="TermText qDef lang-en">Equality — At the Object level, == returns<br>
true only if obj and other are the<br>
same object. Typically, this method is overridden in descendant classes to<br>
provide class-specific meaning.<br>
<br>
obj = "a"<br>
other = obj.dup<br>
<br>
a == other #=&gt; true<br>
a.equal? other #=&gt; false<br>
a.equal? a #=&gt; true</span></li><li data-letters="po" class=""><span class="matching-letter">po</span> <span class="TermText qDef lang-en">Invokes the method identified by symbol, passing it any arguments<br>
specified. Unlike send, #public_send calls public<br>
methods only. When the method is identified by a string, the string is<br>
converted to a symbol.<br>
<br>
1.public_send(:puts, "hello") # causes NoMethodError</span></li><li data-letters="pp" class=""><span class="matching-letter">pp</span> <span class="TermText qDef lang-en">Returns true if the named file is a directory, or a symlink<br>
that points at a directory, and false otherwise.<br>
<br>
File.directory?(".")</span></li><li data-letters="pq" class=""><span class="matching-letter">pq</span> <span class="TermText qDef lang-en">Calls block once for each key in hsh, passing the key as<br>
a parameter.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.each_key {|key| puts key }</span></li><li data-letters="pr" class=""><span class="matching-letter">pr</span> <span class="TermText qDef lang-en">Calls block once for each key in hsh, passing the<br>
key-value pair as parameters.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.each {|key, value| puts "#{key} is #{value}" }</span></li><li data-letters="ps" class=""><span class="matching-letter">ps</span> <span class="TermText qDef lang-en">Looks up the named method as a receiver in obj, returning a<br>
Method object (or raising NameError). The<br>
Method object acts as a closure in obj's object<br>
instance, so instance variables and the value of self remain<br>
available.<br>
<br>
class Demo<br>
 def initialize(n)<br>
 @iv = n<br>
 end<br>
 def hello()<br>
 "Hello, @iv = #{@iv}"<br>
 end<br>
end<br>
<br>
k = Demo.new(99)<br>
m = k.method(:hello)<br>
m.call #=&gt; "Hello, @iv = 99"<br>
<br>
l = Demo.new('Fred')<br>
m = l.method("hello")<br>
m.call #=&gt; "Hello, @iv = Fred"</span></li><li data-letters="pt" class=""><span class="matching-letter">pt</span> <span class="TermText qDef lang-en">Returns the number of environment variables.</span></li><li data-letters="pu" class=""><span class="matching-letter">pu</span> <span class="TermText qDef lang-en">Bit Reference—Returns the nth bit in the (assumed) binary<br>
representation of big, where big<br>
is the least significant bit.<br>
<br>
a = 9**15<br>
50.downto(0) do |n|<br>
 print a[n]<br>
end</span></li><li data-letters="pv" class=""><span class="matching-letter">pv</span> <span class="TermText qDef lang-en">Iterates over the block according to how this Enumerable was constructed. If no block is<br>
given, returns self.</span></li><li data-letters="pw" class=""><span class="matching-letter">pw</span> <span class="TermText qDef lang-en">Passes each element of the collection to the given block. The method<br>
returns true if the block returns true exactly<br>
once. If the block is not given, one? will return<br>
true only if exactly one of the collection members is true.<br>
<br>
%w{ant bear cat}.one? { |word| word.length == 4 } #=&gt; true<br>
%w{ant bear cat}.one? { |word| word.length &gt; 4 } #=&gt; false<br>
%w{ant bear cat}.one? { |word| word.length &lt; 4 } #=&gt; false<br>
[ nil, true, 99 ].one? #=&gt; false<br>
[ nil, true, false ].one? #=&gt; true</span></li><li data-letters="px" class=""><span class="matching-letter">px</span> <span class="TermText qDef lang-en">Returns a clone of this method.<br>
<br>
class A<br>
 def foo<br>
 return "bar"<br>
 end<br>
end<br>
<br>
m = A.new.method(:foo)<br>
m.call # =&gt; "bar"<br>
n = m.clone.call # =&gt; "bar"</span></li><li data-letters="py" class=""><span class="matching-letter">py</span> <span class="TermText qDef lang-en">Returns true if the named file is executable by the real user<br>
id of this process.</span></li><li data-letters="pz" class=""><span class="matching-letter">pz</span> <span class="TermText qDef lang-en">Reverses str in place.</span></li><li data-letters="qa" class=""><span class="matching-letter">qa</span> <span class="TermText qDef lang-en">Changes this process's idea of the file system root. Only a privileged<br>
process may make this call. Not available on all platforms. On Unix<br>
systems, see chroot(2) for more information.</span></li><li data-letters="qb" class=""><span class="matching-letter">qb</span> <span class="TermText qDef lang-en">Returns the string resulting from applying format_string to any<br>
additional arguments. Within the format string, any characters other than<br>
format sequences are copied to the result.<br>
<br>
%[flags][width][.precision]type</span></li><li data-letters="qc" class=""><span class="matching-letter">qc</span> <span class="TermText qDef lang-en">Returns a copied string whose encoding is ASCII-8BIT.</span></li><li data-letters="qd" class=""><span class="matching-letter">qd</span> <span class="TermText qDef lang-en">Returns the standard output of running cmd in a subshell. The<br>
built-in syntax %x{...} uses this method. Sets $?<br>
to the process status.<br>
<br>
%xdate` #=&gt; "Wed Apr 9 08:56:30 CDT 2003\n"<br>
%xls testdir`.split[1] #=&gt; "main.rb"<br>
%xecho oops ^!^ exit 99` #=&gt; "oops\n"<br>
$?.exitstatus #=&gt; 99</span></li><li data-letters="qe" class=""><span class="matching-letter">qe</span> <span class="TermText qDef lang-en">Returns an array containing the quotient and modulus obtained by dividing<br>
num by numeric. If q, r = x.divmod(y), then<br>
<br>
q = floor(x/y)<br>
x = q*y+r</span></li><li data-letters="qf" class=""><span class="matching-letter">qf</span> <span class="TermText qDef lang-en">Takes one element from enum and merges corresponding elements from<br>
each args. This generates a sequence of n-element<br>
arrays, where n is one more than the count of arguments. The<br>
length of the resulting sequence will be enum#size. If the<br>
size of any argument is less than enum#size, nil<br>
values are supplied. If a block is given, it is invoked for each output<br>
array, otherwise an array of arrays is returned.<br>
<br>
a = [ 4, 5, 6 ]<br>
b = [ 7, 8, 9 ]<br>
<br>
[1, 2, 3].zip(a, b) #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]<br>
[1, 2].zip(a, b) #=&gt; [[1, 4, 7], [2, 5, 8]]<br>
a.zip([1, 2], [8]) #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</span></li><li data-letters="qg" class=""><span class="matching-letter">qg</span> <span class="TermText qDef lang-en">Returns a string which represents the encoding for programmers.<br>
<br>
Encoding::UTF_8.inspect #=&gt; "#&lt;Encoding:UTF-8&gt;"<br>
Encoding::ISO_2022_JP.inspect #=&gt; "#&lt;Encoding:ISO-2022-JP (dummy)&gt;"</span></li><li data-letters="qh" class=""><span class="matching-letter">qh</span> <span class="TermText qDef lang-en">Returns true if flt is an invalid IEEE floating point<br>
number.<br>
<br>
a = -1.0 #=&gt; -1.0<br>
a.nan? #=&gt; false<br>
a = 0.0/0.0 #=&gt; NaN<br>
a.nan? #=&gt; true</span></li><li data-letters="qi" class=""><span class="matching-letter">qi</span> <span class="TermText qDef lang-en">Truncates the file file_name to be at most integer bytes<br>
long. Not available on all platforms.<br>
<br>
f = File.new("out", "w")<br>
f.write("1234567890") #=&gt; 10<br>
f.close #=&gt; nil<br>
File.truncate("out", 5) #=&gt; 0<br>
File.size("out") #=&gt; 5</span></li><li data-letters="qj" class=""><span class="matching-letter">qj</span> <span class="TermText qDef lang-en">Returns an arbitrary seed value. This is used by ::new when no seed value is specified<br>
as an argument.<br>
<br>
Random.new_seed #=&gt; 115032730400174366788466674494640623225</span></li><li data-letters="qk" class=""><span class="matching-letter">qk</span> <span class="TermText qDef lang-en">Replaces the current process by running the given external<br>
command. command... is one of following forms.<br>
<br>
commandline : command line string which is passed to the standard shell<br>
cmdname, arg1, ... : command name and one or more arguments (no shell)<br>
[cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)</span></li><li data-letters="ql" class=""><span class="matching-letter">ql</span> <span class="TermText qDef lang-en">If called without an argument, or if max.to_i.abs == 0, rand<br>
returns a pseudo-random floating point number between 0.0 and 1.0,<br>
including 0.0 and excluding 1.0.<br>
<br>
rand #=&gt; 0.2725926052826416</span></li><li data-letters="qm" class=""><span class="matching-letter">qm</span> <span class="TermText qDef lang-en">Equivalent to $_.sub(args), except that<br>
$_ will be updated if substitution occurs. Available only when<br>
-p/-n command line option specified.</span></li><li data-letters="qn" class=""><span class="matching-letter">qn</span> <span class="TermText qDef lang-en">Sorts self in place using a set of keys generated by mapping<br>
the values in self through the given block.</span></li><li data-letters="qo" class=""><span class="matching-letter">qo</span> <span class="TermText qDef lang-en">Returns a new hash created by using hsh's values as keys, and the<br>
keys as values.<br>
<br>
h = { "n" =&gt; 100, "m" =&gt; 100, "y" =&gt; 300, "d" =&gt; 200, "a" =&gt; 0 }<br>
h.invert #=&gt; {0=&gt;"a", 100=&gt;"m", 200=&gt;"d", 300=&gt;"y"}</span></li><li data-letters="qp" class=""><span class="matching-letter">qp</span> <span class="TermText qDef lang-en">Return a string representing this module or class. For basic classes and<br>
modules, this is the name. For singletons, we show information on the thing<br>
we're attached to as well.</span></li><li data-letters="qq" class=""><span class="matching-letter">qq</span> <span class="TermText qDef lang-en">Set Intersection — Returns a new array containing elements common to the<br>
two arrays, excluding any duplicates. The order is preserved from the<br>
original array.<br>
<br>
[ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ] #=&gt; [ 1, 3 ]<br>
[ 'a', 'b', 'b', 'z' ] &amp; [ 'a', 'b', 'c' ] #=&gt; [ 'a', 'b' ]</span></li><li data-letters="qr" class=""><span class="matching-letter">qr</span> <span class="TermText qDef lang-en">Deletes every element of self for which block evaluates to<br>
true.<br>
<br>
scores = [ 97, 42, 75 ]<br>
scores.delete_if {|score| score &lt; 80 } #=&gt; [97]</span></li><li data-letters="qs" class=""><span class="matching-letter">qs</span> <span class="TermText qDef lang-en">Raises float the other power.<br>
<br>
2.0**3 #=&gt; 8.0</span></li><li data-letters="qt" class=""><span class="matching-letter">qt</span> <span class="TermText qDef lang-en">Passes each character in str to the given block, or returns an<br>
enumerator if no block is given.<br>
<br>
"hello".each_char {|c| print c, ' ' }</span></li><li data-letters="qu" class=""><span class="matching-letter">qu</span> <span class="TermText qDef lang-en">Flattens self in place.<br>
<br>
a = [ 1, 2, [3, [4, 5] ] ]<br>
a.flatten! #=&gt; [1, 2, 3, 4, 5]<br>
a.flatten! #=&gt; nil<br>
a #=&gt; [1, 2, 3, 4, 5]<br>
a = [ 1, 2, [3, [4, 5] ] ]<br>
a.flatten!(1) #=&gt; [1, 2, 3, [4, 5]]</span></li><li data-letters="qv" class=""><span class="matching-letter">qv</span> <span class="TermText qDef lang-en">Reassociates ios with the I/O stream given in other_IO or<br>
to a new stream opened on path. This may dynamically change the<br>
actual class of this stream.<br>
<br>
f1 = File.new("testfile")<br>
f2 = File.new("testfile")<br>
f2.readlines[0] #=&gt; "This is line one\n"<br>
f2.reopen(f1) #=&gt; #&lt;File:testfile&gt;<br>
f2.readlines[0] #=&gt; "This is line one\n"</span></li><li data-letters="qw" class=""><span class="matching-letter">qw</span> <span class="TermText qDef lang-en">Converts big to a Float. If big doesn't fit<br>
in a Float, the result is infinity.</span></li><li data-letters="qx" class=""><span class="matching-letter">qx</span> <span class="TermText qDef lang-en">Returns true if stat is readable by the effective<br>
user id of this process.<br>
<br>
File.stat("testfile").readable? #=&gt; true</span></li><li data-letters="qy" class=""><span class="matching-letter">qy</span> <span class="TermText qDef lang-en">Performs bitwise +exclusive or+ between big and numeric.</span></li><li data-letters="qz" class=""><span class="matching-letter">qz</span> <span class="TermText qDef lang-en">Returns an integer representing the day of the week, 0..6, with Sunday ==<br>
0.<br>
<br>
t = Time.now #=&gt; 2007-11-20 02:35:35 -0600<br>
t.wday #=&gt; 2<br>
t.sunday? #=&gt; false<br>
t.monday? #=&gt; false<br>
t.tuesday? #=&gt; true<br>
t.wednesday? #=&gt; false<br>
t.thursday? #=&gt; false<br>
t.friday? #=&gt; false<br>
t.saturday? #=&gt; false</span></li><li data-letters="ra" class=""><span class="matching-letter">ra</span> <span class="TermText qDef lang-en">The first form returns the MatchData object<br>
generated by the last successful pattern match. Equivalent to reading the<br>
special global variable $~ (see Special global variables in Regexp for details).<br>
<br>
/c(.)t/ =~ 'cat' #=&gt; 0<br>
Regexp.last_match #=&gt; #&lt;MatchData "cat" 1:"a"&gt;<br>
Regexp.last_match(0) #=&gt; "cat"<br>
Regexp.last_match(1) #=&gt; "a"<br>
Regexp.last_match(2) #=&gt; nil<br>
<br>
/(?&lt;lhs&gt;\w+)\s<b>=\s</b>(?&lt;rhs&gt;\w+)/ =~ "var = val"<br>
Regexp.last_match #=&gt; #&lt;MatchData "var = val" lhs:"var" rhs:"val"&gt;<br>
Regexp.last_match(:lhs) #=&gt; "var"<br>
Regexp.last_match(:rhs) #=&gt; "val"</span></li><li data-letters="rb" class=""><span class="matching-letter">rb</span> <span class="TermText qDef lang-en">Returns a two element array containing the objects in enum that<br>
correspond to the minimum and maximum values respectively from the given<br>
block.<br>
<br>
a = %w(albatross dog horse)<br>
a.minmax_by { |x| x.length } #=&gt; ["dog", "albatross"]</span></li><li data-letters="rc" class=""><span class="matching-letter">rc</span> <span class="TermText qDef lang-en">Returns the current file as an IO or File object.<br>
#&lt;IO:&lt;STDIN&gt;&gt; is returned when the current file is STDIN.<br>
<br>
$ echo "foo" &gt; foo<br>
$ echo "bar" &gt; bar<br>
<br>
$ ruby argf.rb foo bar<br>
<br>
ARGF.file #=&gt; #&lt;File:foo&gt;<br>
ARGF.read(5) #=&gt; "foo\nb"<br>
ARGF.file #=&gt; #&lt;File:bar&gt;</span></li><li data-letters="rd" class=""><span class="matching-letter">rd</span> <span class="TermText qDef lang-en">Returns -1, 0, +1 or nil depending on whether float is less<br>
than, equal to, or greater than real. This is the basis for<br>
the tests in Comparable.</span></li><li data-letters="re" class=""><span class="matching-letter">re</span> <span class="TermText qDef lang-en">Inserts the given values before the element with the given<br>
index.<br>
<br>
a = %w{ a b c d }<br>
a.insert(2, 99) #=&gt; ["a", "b", 99, "c", "d"]<br>
a.insert(-2, 1, 2, 3) #=&gt; ["a", "b", 99, "c", 1, 2, 3, "d"]</span></li><li data-letters="rf" class=""><span class="matching-letter">rf</span> <span class="TermText qDef lang-en">Deletes every key-value pair from hsh for which block<br>
evaluates to true.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }<br>
h.delete_if {|key, value| key &gt;= "b" } #=&gt; {"a"=&gt;100}</span></li><li data-letters="rg" class=""><span class="matching-letter">rg</span> <span class="TermText qDef lang-en">Seeds the system pseudo-random number generator, Random::DEFAULT, with<br>
number. The previous seed value is returned.<br>
<br>
srand 1234 # =&gt; 268519324636777531569100071560086917274<br>
[ rand, rand ] # =&gt; [0.1915194503788923, 0.6221087710398319]<br>
[ rand(10), rand(1000) ] # =&gt; [4, 664]<br>
srand 1234 # =&gt; 1234<br>
[ rand, rand ] # =&gt; [0.1915194503788923, 0.6221087710398319]</span></li><li data-letters="rh" class=""><span class="matching-letter">rh</span> <span class="TermText qDef lang-en">Makes existing class methods private. Often used to hide the default<br>
constructor new.<br>
<br>
class SimpleSingleton # Not thread safe<br>
 private_class_method :new<br>
 def SimpleSingleton.create(*args, &amp;block)<br>
 @me = new(*args, &amp;block) if ! @me<br>
 @me<br>
 end<br>
end</span></li><li data-letters="ri" class=""><span class="matching-letter">ri</span> <span class="TermText qDef lang-en">Append — Pushes the given object(s) on to the end of this array. This<br>
expression returns the array itself, so several appends may be chained<br>
together. See also #pop for the<br>
opposite effect.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.push("d", "e", "f")<br>
 #=&gt; ["a", "b", "c", "d", "e", "f"]<br>
[1, 2, 3,].push(4).push(5)<br>
 #=&gt; [1, 2, 3, 4, 5]</span></li><li data-letters="rj" class=""><span class="matching-letter">rj</span> <span class="TermText qDef lang-en">Returns the current line number in ios. The stream must be opened<br>
for reading. lineno counts the number of times gets is called rather than the number of<br>
newlines encountered. The two values will differ if gets is called with a separator other than<br>
newline.<br>
<br>
f = File.new("testfile")<br>
f.lineno #=&gt; 0<br>
f.gets #=&gt; "This is line one\n"<br>
f.lineno #=&gt; 1<br>
f.gets #=&gt; "This is line two\n"<br>
f.lineno #=&gt; 2</span></li><li data-letters="rk" class=""><span class="matching-letter">rk</span> <span class="TermText qDef lang-en">Returns the next line from the current file in ARGF.</span></li><li data-letters="rl" class=""><span class="matching-letter">rl</span> <span class="TermText qDef lang-en">Returns the current line number of ARGF as a whole.<br>
This value can be set manually with ARGF.lineno=.<br>
<br>
ARGF.lineno #=&gt; 0<br>
ARGF.readline #=&gt; "This is line 1\n"<br>
ARGF.lineno #=&gt; 1</span></li><li data-letters="rm" class=""><span class="matching-letter">rm</span> <span class="TermText qDef lang-en">Returns true if the two generators have the same internal state, otherwise<br>
false. Equivalent generators will return the same sequence of<br>
pseudo-random numbers. Two generators will generally have the same state<br>
only if they were initialized with the same seed<br>
<br>
Random.new == Random.new # =&gt; false<br>
Random.new(1234) == Random.new(1234) # =&gt; true</span></li><li data-letters="rn" class=""><span class="matching-letter">rn</span> <span class="TermText qDef lang-en">Compute a hash-code for this array.</span></li><li data-letters="ro" class=""><span class="matching-letter">ro</span> <span class="TermText qDef lang-en">With no arguments, sets the default visibility for subsequently defined<br>
methods to public. With arguments, sets the named methods to have public<br>
visibility. String arguments are converted to<br>
symbols.</span></li><li data-letters="rp" class=""><span class="matching-letter">rp</span> <span class="TermText qDef lang-en">Returns true if the given value is present for some key in<br>
hsh.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.has_value?(100) #=&gt; true<br>
h.has_value?(999) #=&gt; false</span></li><li data-letters="rq" class=""><span class="matching-letter">rq</span> <span class="TermText qDef lang-en">Returns the original name of the method.</span></li><li data-letters="rr" class=""><span class="matching-letter">rr</span> <span class="TermText qDef lang-en">spawn executes specified command and return its pid.<br>
<br>
env: hash<br>
 name =&gt; val : set the environment variable<br>
 name =&gt; nil : unset the environment variable<br>
command...:<br>
 commandline : command line string which is passed to the standard shell<br>
 cmdname, arg1, ... : command name and one or more arguments (no shell)<br>
 [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)<br>
options: hash<br>
 clearing environment variables:<br>
 :unsetenv_others =&gt; true : clear environment variables except specified by env<br>
 :unsetenv_others =&gt; false : don't clear (default)<br>
 process group:<br>
 :pgroup =&gt; true or 0 : make a new process group<br>
 :pgroup =&gt; pgid : join to specified process group<br>
 :pgroup =&gt; nil : don't change the process group (default)<br>
 create new process group: Windows only<br>
 :new_pgroup =&gt; true : the new process is the root process of a new process group<br>
 :new_pgroup =&gt; false : don't create a new process group (default)<br>
 resource limit: resourcename is core, cpu, data, etc. See Process.setrlimit.<br>
 :rlimit_resourcename =&gt; limit<br>
 :rlimit_resourcename =&gt; [cur_limit, max_limit]<br>
 umask:<br>
 :umask =&gt; int<br>
 redirection:<br>
 key:<br>
 FD : single file descriptor in child process<br>
 [FD, FD, ...] : multiple file descriptor in child process<br>
 value:<br>
 FD : redirect to the file descriptor in parent process<br>
 string : redirect to file with open(string, "r" or "w")<br>
 [string] : redirect to file with open(string, File::RDONLY)<br>
 [string, open_mode] : redirect to file with open(string, open_mode, 0644)<br>
 [string, open_mode, perm] : redirect to file with open(string, open_mode, perm)<br>
 [:child, FD] : redirect to the redirected file descriptor<br>
 :close : close the file descriptor in child process<br>
 FD is one of follows<br>
 :in : the file descriptor 0 which is the standard input<br>
 :out : the file descriptor 1 which is the standard output<br>
 :err : the file descriptor 2 which is the standard error<br>
 integer : the file descriptor of specified the integer<br>
 io : the file descriptor specified as io.fileno<br>
 file descriptor inheritance: close non-redirected non-standard fds (3, 4, 5, ...) or not<br>
 :close_others =&gt; true : don't inherit<br>
 current directory:<br>
 :chdir =&gt; str</span></li><li data-letters="rs" class=""><span class="matching-letter">rs</span> <span class="TermText qDef lang-en">Compute a hash-code for this hash. Two hashes with the same content will<br>
have the same hash code (and will compare using eql?).</span></li><li data-letters="rt" class=""><span class="matching-letter">rt</span> <span class="TermText qDef lang-en">Groups the collection by result of the block. Returns a hash where the<br>
keys are the evaluated result from the block and the values are arrays of<br>
elements in the collection that correspond to the key.<br>
<br>
(1..6).group_by { |i| i%3 } #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</span></li><li data-letters="ru" class=""><span class="matching-letter">ru</span> <span class="TermText qDef lang-en">Returns the number of arguments that would not be ignored. If the block is<br>
declared to take no arguments, returns 0. If the block is known to take<br>
exactly n arguments, returns n. If the block has optional arguments, return<br>
-n-1, where n is the number of mandatory arguments. A proc<br>
with no argument declarations is the same a block declaring ||<br>
as its arguments.<br>
<br>
proc {}.arity #=&gt; 0<br>
proc {||}.arity #=&gt; 0<br>
proc {|a|}.arity #=&gt; 1<br>
proc {|a,b|}.arity #=&gt; 2<br>
proc {|a,b,c|}.arity #=&gt; 3<br>
proc {|*a|}.arity #=&gt; -1<br>
proc {|a,*b|}.arity #=&gt; -2<br>
proc {|a,*b, c|}.arity #=&gt; -3<br>
<br>
proc { |x = 0| }.arity #=&gt; 0<br>
lambda { |a = 0| }.arity #=&gt; -1<br>
proc { |x=0, y| }.arity #=&gt; 1<br>
lambda { |x=0, y| }.arity #=&gt; -2<br>
proc { |x=0, y=0| }.arity #=&gt; 0<br>
lambda { |x=0, y=0| }.arity #=&gt; -1<br>
proc { |x, y=0| }.arity #=&gt; 1<br>
lambda { |x, y=0| }.arity #=&gt; -2<br>
proc { |(x, y), z=0| }.arity #=&gt; 1<br>
lambda { |(x, y), z=0| }.arity #=&gt; -2</span></li><li data-letters="rv" class=""><span class="matching-letter">rv</span> <span class="TermText qDef lang-en">Returns a copy of self with all nil elements<br>
removed.<br>
<br>
[ "a", nil, "b", nil, "c", nil ].compact<br>
 #=&gt; [ "a", "b", "c" ]</span></li><li data-letters="rw" class=""><span class="matching-letter">rw</span> <span class="TermText qDef lang-en">Reads the next entry from dir and returns it as a string. Returns<br>
nil at the end of the stream.<br>
<br>
d = Dir.new("testdir")<br>
d.read #=&gt; "."<br>
d.read #=&gt; ".."<br>
d.read #=&gt; "config.h"</span></li><li data-letters="rx" class=""><span class="matching-letter">rx</span> <span class="TermText qDef lang-en">As flt is already a float, returns self.</span></li><li data-letters="ry" class=""><span class="matching-letter">ry</span> <span class="TermText qDef lang-en">Invokes the child class's to_i method to convert<br>
num to an integer.<br>
<br>
1.0.class =&gt; Float<br>
1.0.to_int.class =&gt; Fixnum<br>
1.0.to_i.class =&gt; Fixnum</span></li><li data-letters="rz" class=""><span class="matching-letter">rz</span> <span class="TermText qDef lang-en">Equivalent to Hash#keep_if, but returns nil if no<br>
changes were made.</span></li><li data-letters="sa" class=""><span class="matching-letter">sa</span> <span class="TermText qDef lang-en">Returns the smallest Integer greater than or equal to<br>
num. Class Numeric achieves<br>
this by converting itself to a Float then invoking<br>
Float#ceil.<br>
<br>
1.ceil #=&gt; 1<br>
1.2.ceil #=&gt; 2<br>
(-1.2).ceil #=&gt; -1<br>
(-1.0).ceil #=&gt; -1</span></li><li data-letters="sb" class=""><span class="matching-letter">sb</span> <span class="TermText qDef lang-en">Returns a new array populated with the values from hsh. See also<br>
Hash#keys.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }<br>
h.values #=&gt; [100, 200, 300]</span></li><li data-letters="sc" class=""><span class="matching-letter">sc</span> <span class="TermText qDef lang-en">Returns the hash of available encoding alias and original encoding name.<br>
<br>
Encoding.aliases<br>
#=&gt; {"BINARY"=&gt;"ASCII-8BIT", "ASCII"=&gt;"US-ASCII", "ANSI_X3.4-1986"=&gt;"US-ASCII",<br>
 "SJIS"=&gt;"Shift_JIS", "eucJP"=&gt;"EUC-JP", "CP932"=&gt;"Windows-31J"}</span></li><li data-letters="sd" class=""><span class="matching-letter">sd</span> <span class="TermText qDef lang-en">Returns an IO object representing the current file. This will<br>
be a File object unless the current file is a stream such as<br>
STDIN.<br>
<br>
ARGF.to_io #=&gt; #&lt;File:glark.txt&gt;<br>
ARGF.to_io #=&gt; #&lt;IO:&lt;STDIN&gt;&gt;</span></li><li data-letters="se" class=""><span class="matching-letter">se</span> <span class="TermText qDef lang-en">Allocates space for a new object of class's class and does not<br>
call initialize on the new instance. The returned object must be an<br>
instance of class.<br>
<br>
klass = Class.new do<br>
 def initialize(*args)<br>
 @initialized = true<br>
 end<br>
<br>
 def initialized?<br>
 @initialized || false<br>
 end<br>
end<br>
<br>
klass.allocate.initialized? #=&gt; false</span></li><li data-letters="sf" class=""><span class="matching-letter">sf</span> <span class="TermText qDef lang-en">Return the contents of this hash as a string.<br>
<br>
h = { "c" =&gt; 300, "a" =&gt; 100, "d" =&gt; 400, "c" =&gt; 300 }<br>
h.to_s #=&gt; "{\"c\"=&gt;300, \"a\"=&gt;100, \"d\"=&gt;400}"</span></li><li data-letters="sg" class=""><span class="matching-letter">sg</span> <span class="TermText qDef lang-en">Addition — Adds some number of seconds (possibly fractional) to<br>
time and returns that value as a new Time<br>
object.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:22:21 -0600<br>
t + (60 <b> 60 </b> 24) #=&gt; 2007-11-20 08:22:21 -0600</span></li><li data-letters="sh" class=""><span class="matching-letter">sh</span> <span class="TermText qDef lang-en">Provides a mechanism for issuing low-level commands to control or query<br>
file-oriented I/O streams. Arguments and results are platform dependent. If<br>
arg is a number, its value is passed directly. If it is a string,<br>
it is interpreted as a binary sequence of bytes (Array#pack<br>
might be a useful way to build this string). On Unix platforms, see<br>
fcntl(2) for details. Not implemented on all platforms.</span></li><li data-letters="si" class=""><span class="matching-letter">si</span> <span class="TermText qDef lang-en">Returns true if the value of fix is less than or<br>
equal to that of real.</span></li><li data-letters="sj" class=""><span class="matching-letter">sj</span> <span class="TermText qDef lang-en">If the string is invalid byte sequence then replace invalid bytes with<br>
given replacement character, else returns self. If block is given, replace<br>
invalid bytes with returned value of the block.<br>
<br>
"abc\u3042\x81".scrub! #=&gt; "abc\u3042\uFFFD"<br>
"abc\u3042\x81".scrub!("<b>") #=&gt; "abc\u3042</b>"<br>
"abc\u3042\xE3\x80".scrub!{|bytes| '&lt;'+bytes.unpack('H*')[0]+'&gt;' } #=&gt; "abc\u3042&lt;e380&gt;"</span></li><li data-letters="sk" class=""><span class="matching-letter">sk</span> <span class="TermText qDef lang-en">Returns true if the named method is defined by mod<br>
(or its included modules and, if mod is a class, its ancestors).<br>
Public and protected methods are matched. String<br>
arguments are converted to symbols.<br>
<br>
module A<br>
 def method1() end<br>
end<br>
class B<br>
 def method2() end<br>
end<br>
class C &lt; B<br>
 include A<br>
 def method3() end<br>
end<br>
<br>
A.method_defined? :method1 #=&gt; true<br>
C.method_defined? "method1" #=&gt; true<br>
C.method_defined? "method2" #=&gt; true<br>
C.method_defined? "method3" #=&gt; true<br>
C.method_defined? "method4" #=&gt; false</span></li><li data-letters="sl" class=""><span class="matching-letter">sl</span> <span class="TermText qDef lang-en">Returns true if the current file in ARGF is at end of file,<br>
i.e. it has no data to read. The stream must be opened for reading or an<br>
IOError will be raised.<br>
<br>
$ echo "eof" | ruby argf.rb<br>
<br>
ARGF.eof? #=&gt; false<br>
3.times { ARGF.readchar }<br>
ARGF.eof? #=&gt; false<br>
ARGF.readchar #=&gt; "\n"<br>
ARGF.eof? #=&gt; true</span></li><li data-letters="sm" class=""><span class="matching-letter">sm</span> <span class="TermText qDef lang-en">Equivalent to Proc.new.</span></li><li data-letters="sn" class=""><span class="matching-letter">sn</span> <span class="TermText qDef lang-en">Returns true if the given object is present in<br>
self (that is, if any element ==<br>
object), otherwise returns false.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.include?("b") #=&gt; true<br>
a.include?("z") #=&gt; false</span></li><li data-letters="so" class=""><span class="matching-letter">so</span> <span class="TermText qDef lang-en">Returns a new float which is the result of dividing float by<br>
other.</span></li><li data-letters="sp" class=""><span class="matching-letter">sp</span> <span class="TermText qDef lang-en">One's complement: returns a number where each bit is flipped.</span></li><li data-letters="sq" class=""><span class="matching-letter">sq</span> <span class="TermText qDef lang-en">Returns the entire matched string.<br>
<br>
m = /(.)(.)(\d+)(\d)/.match("THX1138.")<br>
m.to_s #=&gt; "HX1138"</span></li><li data-letters="sr" class=""><span class="matching-letter">sr</span> <span class="TermText qDef lang-en">Returns true if stat is executable or if the<br>
operating system doesn't distinguish executable files from nonexecutable<br>
files. The tests are made using the effective owner of the process.<br>
<br>
File.stat("testfile").executable? #=&gt; false</span></li><li data-letters="ss" class=""><span class="matching-letter">ss</span> <span class="TermText qDef lang-en">Same as File::stat, but does not follow the last symbolic<br>
link. Instead, reports on the link itself.<br>
<br>
File.symlink("testfile", "link2test") #=&gt; 0<br>
File.stat("testfile").size #=&gt; 66<br>
File.lstat("link2test").size #=&gt; 8<br>
File.stat("link2test").size #=&gt; 66</span></li><li data-letters="st" class=""><span class="matching-letter">st</span> <span class="TermText qDef lang-en">Returns a string created by converting each element of the array to a<br>
string, separated by the given separator. If the<br>
separator is nil, it uses current $,. If both the<br>
separator and $, are nil, it uses empty string.<br>
<br>
[ "a", "b", "c" ].join #=&gt; "abc"<br>
[ "a", "b", "c" ].join("-") #=&gt; "a-b-c"</span></li><li data-letters="su" class=""><span class="matching-letter">su</span> <span class="TermText qDef lang-en">Equivalent to calling Dir.glob(array,0)<br>
and Dir.glob([string,...],0).</span></li><li data-letters="sv" class=""><span class="matching-letter">sv</span> <span class="TermText qDef lang-en">Compute a hash based on the value of big.</span></li><li data-letters="sw" class=""><span class="matching-letter">sw</span> <span class="TermText qDef lang-en">Returns a new array.<br>
<br>
first_array = ["Matz", "Guido"]<br>
<br>
second_array = Array.new(first_array) #=&gt; ["Matz", "Guido"]<br>
<br>
first_array.equal? second_array #=&gt; false</span></li><li data-letters="sx" class=""><span class="matching-letter">sx</span> <span class="TermText qDef lang-en">Returns the singleton class of obj. This method creates a new<br>
singleton class if obj does not have it.<br>
<br>
Object.new.singleton_class #=&gt; #&lt;Class:#&lt;Object:0xb7ce1e24&gt;&gt;<br>
String.singleton_class #=&gt; #&lt;Class:String&gt;<br>
nil.singleton_class #=&gt; NilClass</span></li><li data-letters="sy" class=""><span class="matching-letter">sy</span> <span class="TermText qDef lang-en">Drops elements up to, but not including, the first element for which the<br>
block returns nil or false and returns an array<br>
containing the remaining elements.<br>
<br>
a = [1, 2, 3, 4, 5, 0]<br>
a.drop_while {|i| i &lt; 3 } #=&gt; [3, 4, 5, 0]</span></li><li data-letters="sz" class=""><span class="matching-letter">sz</span> <span class="TermText qDef lang-en">Returns an array of characters in str. This is a shorthand for<br>
str.each_char.to_a.</span></li><li data-letters="ta" class=""><span class="matching-letter">ta</span> <span class="TermText qDef lang-en">Passes each entry in enum to block. Returns the first for<br>
which block is not false. If no object matches, calls<br>
ifnone and returns its result when it is specified, or returns<br>
nil otherwise.<br>
<br>
(1..10).detect { |i| i % 5 == 0 and i % 7 == 0 } #=&gt; nil<br>
(1..100).detect { |i| i % 5 == 0 and i % 7 == 0 } #=&gt; 35</span></li><li data-letters="tb" class=""><span class="matching-letter">tb</span> <span class="TermText qDef lang-en">Returns the day of the month (1..n) for time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:27:03 -0600<br>
t.day #=&gt; 19<br>
t.mday #=&gt; 19</span></li><li data-letters="tc" class=""><span class="matching-letter">tc</span> <span class="TermText qDef lang-en">Returns true if two objects are not-equal, otherwise false.</span></li><li data-letters="td" class=""><span class="matching-letter">td</span> <span class="TermText qDef lang-en">Returns the real (absolute) pathname of pathname in the actual<br>
filesystem. The real pathname doesn't contain symlinks or useless dots.</span></li><li data-letters="te" class=""><span class="matching-letter">te</span> <span class="TermText qDef lang-en">Returns a string containing the representation of fix radix<br>
base (between 2 and 36).<br>
<br>
12345.to_s #=&gt; "12345"<br>
12345.to_s(2) #=&gt; "11000000111001"<br>
12345.to_s(8) #=&gt; "30071"<br>
12345.to_s(10) #=&gt; "12345"<br>
12345.to_s(16) #=&gt; "3039"<br>
12345.to_s(36) #=&gt; "9ix"</span></li><li data-letters="tf" class=""><span class="matching-letter">tf</span> <span class="TermText qDef lang-en">Runs the specified command as a subprocess; the subprocess's standard input<br>
and output will be connected to the returned IO object.<br>
<br>
cmd:<br>
 "-" : fork<br>
 commandline : command line string which is passed to a shell<br>
 [env, cmdname, arg1, ..., opts] : command name and zero or more arguments (no shell)<br>
 [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)<br>
(env and opts are optional.)</span></li><li data-letters="tg" class=""><span class="matching-letter">tg</span> <span class="TermText qDef lang-en">Always returns an empty array.<br>
<br>
nil.to_a #=&gt; []</span></li><li data-letters="th" class=""><span class="matching-letter">th</span> <span class="TermText qDef lang-en">Returns exception's message (or the name of the exception if no message is<br>
set).</span></li><li data-letters="ti" class=""><span class="matching-letter">ti</span> <span class="TermText qDef lang-en">Always returns the string "nil".</span></li><li data-letters="tj" class=""><span class="matching-letter">tj</span> <span class="TermText qDef lang-en">Returns the minute of the hour (0..59) for time.<br>
<br>
t = Time.now #=&gt; 2007-11-19 08:25:51 -0600<br>
t.min #=&gt; 25</span></li><li data-letters="tk" class=""><span class="matching-letter">tk</span> <span class="TermText qDef lang-en">Returns an array; [int.gcd(int2), int.lcm(int2)].<br>
<br>
2.gcdlcm(2) #=&gt; [2, 2]<br>
3.gcdlcm(-7) #=&gt; [1, 21]<br>
((1&lt;&lt;31)-1).gcdlcm((1&lt;&lt;61)-1) #=&gt; [1, 4951760154835678088235319297]</span></li><li data-letters="tl" class=""><span class="matching-letter">tl</span> <span class="TermText qDef lang-en">Same as sym.to_s.downcase.intern.</span></li><li data-letters="tm" class=""><span class="matching-letter">tm</span> <span class="TermText qDef lang-en">Removes trailing whitespace from str, returning nil<br>
if no change was made. See also String#lstrip! and<br>
String#strip!.<br>
<br>
" hello ".rstrip #=&gt; " hello"<br>
"hello".rstrip! #=&gt; nil</span></li><li data-letters="tn" class=""><span class="matching-letter">tn</span> <span class="TermText qDef lang-en">Pushes back bytes (passed as a parameter) onto ios, such that a<br>
subsequent buffered read will return it. Only one byte may be pushed back<br>
before a subsequent read operation (that is, you will be able to read only<br>
the last of several bytes that have been pushed back). Has no effect with<br>
unbuffered reads (such as IO#sysread).<br>
<br>
f = File.new("testfile") #=&gt; #&lt;File:testfile&gt;<br>
b = f.getbyte #=&gt; 0x38<br>
f.ungetbyte(b) #=&gt; nil<br>
f.getbyte #=&gt; 0x38</span></li><li data-letters="to" class=""><span class="matching-letter">to</span> <span class="TermText qDef lang-en">Invoked as a callback whenever an instance method is removed from the<br>
receiver.<br>
<br>
module Chatty<br>
 def self.method_removed(method_name)<br>
 puts "Removing #{method_name.inspect}"<br>
 end<br>
 def self.some_class_method() end<br>
 def some_instance_method() end<br>
 class &lt;&lt; self<br>
 remove_method :some_class_method<br>
 end<br>
 remove_method :some_instance_method<br>
end</span></li><li data-letters="tp" class=""><span class="matching-letter">tp</span> <span class="TermText qDef lang-en">Returns an array containing all elements of enum for which the<br>
given block returns a true value.<br>
<br>
(1..10).find_all { |i| i % 3 == 0 } #=&gt; [3, 6, 9]<br>
<br>
[1,2,3,4,5].select { |num| num.even? } #=&gt; [2, 4]</span></li><li data-letters="tq" class=""><span class="matching-letter">tq</span> <span class="TermText qDef lang-en">Returns true if the named file is a pipe.</span></li><li data-letters="tr" class=""><span class="matching-letter">tr</span> <span class="TermText qDef lang-en">Returns the receiver.</span></li><li data-letters="ts" class=""><span class="matching-letter">ts</span> <span class="TermText qDef lang-en">Boolean negate.</span></li><li data-letters="tt" class=""><span class="matching-letter">tt</span> <span class="TermText qDef lang-en">Returns a copy of str with the first occurrence of<br>
pattern replaced by the second argument. The<br>
pattern is typically a Regexp; if<br>
given as a String, any regular expression<br>
metacharacters it contains will be interpreted literally, e.g.<br>
'\\d' will match a backlash followed by 'd', instead of a<br>
digit.<br>
<br>
"hello".sub(/[aeiou]/, '<b>') #=&gt; "h</b>llo"<br>
"hello".sub(/([aeiou])/, '&lt;\1&gt;') #=&gt; "h&lt;e&gt;llo"<br>
"hello".sub(/./) {|s| s.ord.to_s + ' ' } #=&gt; "104 ello"<br>
"hello".sub(/(?&lt;foo&gt;[aeiou])/, '<b>\k&lt;foo&gt;</b>') #=&gt; "h<b>e</b>llo"<br>
'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)<br>
 #=&gt; "Is /bin/bash your preferred shell?"</span></li><li data-letters="tu" class=""><span class="matching-letter">tu</span> <span class="TermText qDef lang-en">Invokes the block, setting the block's parameters to the values in<br>
params using something close to method calling semantics.<br>
Generates a warning if multiple values are passed to a proc that expects<br>
just one (previously this silently converted the parameters to an array). <br>
Note that prc.() invokes prc.call() with the parameters given. It's a<br>
syntax sugar to hide "call".<br>
<br>
a_proc = Proc.new {|a, <b>b| b.collect {|i| i</b>a }}<br>
a_proc.call(9, 1, 2, 3) #=&gt; [9, 18, 27]<br>
a_proc[9, 1, 2, 3] #=&gt; [9, 18, 27]<br>
a_proc = lambda {|a,b| a}<br>
a_proc.call(1,2,3)</span></li><li data-letters="tv" class=""><span class="matching-letter">tv</span> <span class="TermText qDef lang-en">Returns the current execution stack—an array containing backtrace location<br>
objects.</span></li><li data-letters="tw" class=""><span class="matching-letter">tw</span> <span class="TermText qDef lang-en">Locks or unlocks a file according to locking_constant (a logical<br>
or of the values in the table below). Returns false<br>
if File::LOCK_NB is specified and the operation would<br>
otherwise have blocked. Not available on all platforms.<br>
<br>
LOCK_EX | Exclusive lock. Only one process may hold an<br>
 | exclusive lock for a given file at a time.<br>
----------+------------------------------------------------<br>
LOCK_NB | Don't block when locking. May be combined<br>
 | with other lock options using logical or.<br>
----------+------------------------------------------------<br>
LOCK_SH | Shared lock. Multiple processes may each hold a<br>
 | shared lock for a given file at the same time.<br>
----------+------------------------------------------------<br>
LOCK_UN | Unlock.</span></li><li data-letters="tx" class=""><span class="matching-letter">tx</span> <span class="TermText qDef lang-en">Similar to instance_method, searches public method only.</span></li><li data-letters="ty" class=""><span class="matching-letter">ty</span> <span class="TermText qDef lang-en">Returns the number of elements in the range.<br>
<br>
(10..20).size #=&gt; 11</span></li><li data-letters="tz" class=""><span class="matching-letter">tz</span> <span class="TermText qDef lang-en">Specifies the handling of signals. The first parameter is a signal name (a<br>
string such as "SIGALRM", "SIGUSR1", and so on) or a signal number. The<br>
characters "SIG" may be omitted from the signal name. The command or block<br>
specifies code to be run when the signal is raised. If the command is the<br>
string "IGNORE" or "SIG_IGN", the signal will be ignored. If the command is<br>
"DEFAULT" or "SIG_DFL", the Ruby's default handler will be invoked. If the<br>
command is "EXIT", the script will be terminated by the signal. If the<br>
command is "SYSTEM_DEFAULT", the operating system's default handler will be<br>
invoked. Otherwise, the given command or block will be run. The special<br>
signal name "EXIT" or signal number zero will be invoked just prior to<br>
program termination. trap returns the previous handler for the given<br>
signal.<br>
<br>
Signal.trap(0, proc { puts "Terminating: #{$$}" })<br>
Signal.trap("CLD") { puts "Child died" }<br>
fork ^!^ Process.wait</span></li><li data-letters="ua" class=""><span class="matching-letter">ua</span> <span class="TermText qDef lang-en">Executes the given block within the context of the receiver (obj).<br>
In order to set the context, the variable self is set to<br>
obj while the code is executing, giving the code access to<br>
obj's instance variables. Arguments are passed as block<br>
parameters.<br>
<br>
class KlassWithSecret<br>
 def initialize<br>
 @secret = 99<br>
 end<br>
end<br>
k = KlassWithSecret.new<br>
k.instance_exec(5) {|x| @secret+x } #=&gt; 104</span></li><li data-letters="ub" class=""><span class="matching-letter">ub</span> <span class="TermText qDef lang-en">Calls the given block for each element n times or forever if<br>
nil is given.<br>
<br>
a = ["a", "b", "c"]<br>
a.cycle { |x| puts x } # print, a, b, c, a, b, c,.. forever.<br>
a.cycle(2) { |x| puts x } # print, a, b, c, a, b, c.</span></li><li data-letters="uc" class=""><span class="matching-letter">uc</span> <span class="TermText qDef lang-en">Returns an array; [num.abs, num.arg].</span></li><li data-letters="ud" class=""><span class="matching-letter">ud</span> <span class="TermText qDef lang-en">Processes str as for String#chop, returning<br>
str, or nil if str is the empty string. See<br>
also String#chomp!.</span></li><li data-letters="ue" class=""><span class="matching-letter">ue</span> <span class="TermText qDef lang-en">Construct a new Exception object, optionally<br>
passing in a message.</span></li><li data-letters="uf" class=""><span class="matching-letter">uf</span> <span class="TermText qDef lang-en">Returns the length of str in bytes.<br>
<br>
"\x80\u3042".bytesize #=&gt; 4<br>
"hello".bytesize #=&gt; 5</span></li><li data-letters="ug" class=""><span class="matching-letter">ug</span> <span class="TermText qDef lang-en">Dissociates meth from its current receiver. The resulting<br>
UnboundMethod can subsequently be bound to a new object of the<br>
same class (see UnboundMethod).</span></li><li data-letters="uh" class=""><span class="matching-letter">uh</span> <span class="TermText qDef lang-en">Shifts big right numeric positions (left if numeric is<br>
negative).</span></li><li data-letters="ui" class=""><span class="matching-letter">ui</span> <span class="TermText qDef lang-en">Truncates file to at most integer bytes. The file must be<br>
opened for writing. Not available on all platforms.<br>
<br>
f = File.new("out", "w")<br>
f.syswrite("1234567890") #=&gt; 10<br>
f.truncate(5) #=&gt; 0<br>
f.close() #=&gt; nil<br>
File.size("out") #=&gt; 5</span></li><li data-letters="uj" class=""><span class="matching-letter">uj</span> <span class="TermText qDef lang-en">Returns the freeze status of obj.<br>
<br>
a = [ "a", "b", "c" ]<br>
a.freeze #=&gt; ["a", "b", "c"]<br>
a.frozen? #=&gt; true</span></li><li data-letters="uk" class=""><span class="matching-letter">uk</span> <span class="TermText qDef lang-en">Reads a byte as with IO#getbyte, but raises an<br>
EOFError on end of file.</span></li><li data-letters="ul" class=""><span class="matching-letter">ul</span> <span class="TermText qDef lang-en">Returns the change time for stat (that is, the time directory<br>
information about the file was changed, not the file itself).<br>
<br>
File.stat("testfile").ctime #=&gt; Wed Apr 09 08:53:14 CDT 2003</span></li><li data-letters="um" class=""><span class="matching-letter">um</span> <span class="TermText qDef lang-en">Returns any backtrace associated with the exception. The backtrace is an<br>
array of strings, each containing either "filename:lineNo: in `method"' or<br>
"filename:lineNo."<br>
<br>
def a<br>
 raise "boom"<br>
end<br>
<br>
def b<br>
 a()<br>
end<br>
<br>
begin<br>
 b()<br>
rescue =&gt; detail<br>
 print detail.backtrace.join("\n")<br>
end</span></li><li data-letters="un" class=""><span class="matching-letter">un</span> <span class="TermText qDef lang-en">When invoked with a block, yield all repeated permutations of length<br>
n of the elements of the array, then return the array itself.<br>
<br>
a = [1, 2]<br>
a.repeated_permutation(1).to_a #=&gt; [[1], [2]]<br>
a.repeated_permutation(2).to_a #=&gt; [[1,1],[1,2],[2,1],[2,2]]<br>
a.repeated_permutation(3).to_a #=&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],<br>
 # [2,1,1],[2,1,2],[2,2,1],[2,2,2]]<br>
a.repeated_permutation(0).to_a #=&gt; [[]] # one permutation of length 0</span></li><li data-letters="uo" class=""><span class="matching-letter">uo</span> <span class="TermText qDef lang-en">Returns the value of time as an integer number of seconds since<br>
the Epoch.<br>
<br>
t = Time.now<br>
"%10.5f" % t.to_f #=&gt; "1270968656.89607"<br>
t.to_i #=&gt; 1270968656</span></li><li data-letters="up" class=""><span class="matching-letter">up</span> <span class="TermText qDef lang-en">Concatenation — Returns a new array built by concatenating the two arrays<br>
together to produce a third array.<br>
<br>
[ 1, 2, 3 ] + [ 4, 5 ] #=&gt; [ 1, 2, 3, 4, 5 ]<br>
a = [ "a", "b", "c" ]<br>
a + [ "d", "e", "f" ]<br>
a #=&gt; [ "a", "b", "c", "d", "e", "f" ]</span></li><li data-letters="uq" class=""><span class="matching-letter">uq</span> <span class="TermText qDef lang-en">Reads the next 8-bit byte from ARGF and returns it<br>
as a Fixnum. Raises an EOFError after the last<br>
byte of the last file has been read.<br>
<br>
$ echo "foo" &gt; file<br>
$ ruby argf.rb file<br>
<br>
ARGF.readbyte #=&gt; 102<br>
ARGF.readbyte #=&gt; 111<br>
ARGF.readbyte #=&gt; 111<br>
ARGF.readbyte #=&gt; 10<br>
ARGF.readbyte #=&gt; end of file reached (EOFError)</span></li><li data-letters="ur" class=""><span class="matching-letter">ur</span> <span class="TermText qDef lang-en">Retrieves the value for environment variable name<br>
as a String. Returns nil if the<br>
named variable does not exist.</span></li><li data-letters="us" class=""><span class="matching-letter">us</span> <span class="TermText qDef lang-en">Invokes the block passing in successive elements from struct,<br>
returning an array containing those elements for which the block returns a<br>
true value (equivalent to Enumerable#select).<br>
<br>
Lots = Struct.new(:a, :b, :c, :d, :e, :f)<br>
l = Lots.new(11, 22, 33, 44, 55, 66)<br>
l.select {|v| (v % 2).zero? } #=&gt; [22, 44, 66]</span></li><li data-letters="ut" class=""><span class="matching-letter">ut</span> <span class="TermText qDef lang-en">Returns the real (absolute) pathname of pathname in the actual<br>
filesystem not containing symlinks or useless dots.</span></li><li data-letters="uu" class=""><span class="matching-letter">uu</span> <span class="TermText qDef lang-en">Replaces the contents of self with the contents of<br>
other_ary, truncating or expanding if necessary.<br>
<br>
a = [ "a", "b", "c", "d", "e" ]<br>
a.replace([ "x", "y", "z" ]) #=&gt; ["x", "y", "z"]<br>
a #=&gt; ["x", "y", "z"]</span></li><li data-letters="uv" class=""><span class="matching-letter">uv</span> <span class="TermText qDef lang-en">Removes the untrusted mark from the object.</span></li><li data-letters="uw" class=""><span class="matching-letter">uw</span> <span class="TermText qDef lang-en">Returns true if the effective user id of the process is the<br>
same as the owner of stat.<br>
<br>
File.stat("testfile").owned? #=&gt; true<br>
File.stat("/etc/passwd").owned? #=&gt; false</span></li><li data-letters="ux" class=""><span class="matching-letter">ux</span> <span class="TermText qDef lang-en">Constructs a new regular expression from pattern, which can be<br>
either a String or a Regexp (in which case that regexp's options are<br>
propagated), and new options may not be specified (a change as of Ruby<br>
1.8).<br>
<br>
r1 = Regexp.new('^a-z+:\s+\w+') #=&gt; /^a-z+:\s+\w+/<br>
r2 = Regexp.new('cat', true) #=&gt; /cat/i<br>
r3 = Regexp.new(r2) #=&gt; /cat/i<br>
r4 = Regexp.new('dog', Regexp::EXTENDED | Regexp::IGNORECASE) #=&gt; /dog/ix</span></li><li data-letters="uy" class=""><span class="matching-letter">uy</span> <span class="TermText qDef lang-en">Array Difference<br>
<br>
[ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ] #=&gt; [ 3, 3, 5 ]</span></li><li data-letters="uz" class=""><span class="matching-letter">uz</span> <span class="TermText qDef lang-en">Displays each of the given messages followed by a record separator on<br>
STDERR unless warnings have been disabled (for example with the<br>
-W0 flag).<br>
<br>
 warn("warning 1", "warning 2")<br>
<br>
&lt;em&gt;produces:&lt;/em&gt;<br>
<br>
 warning 1<br>
 warning 2</span></li><li data-letters="va" class=""><span class="matching-letter">va</span> <span class="TermText qDef lang-en">Set Union — Returns a new array by joining ary with<br>
other_ary, excluding any duplicates and preserving the order<br>
from the original array.<br>
<br>
[ "a", "b", "c" ] | [ "c", "d", "a" ] #=&gt; [ "a", "b", "c", "d" ]</span></li><li data-letters="vb" class=""><span class="matching-letter">vb</span> <span class="TermText qDef lang-en">Replaces the contents of hsh with the contents of<br>
other_hash.<br>
<br>
h = { "a" =&gt; 100, "b" =&gt; 200 }<br>
h.replace({ "c" =&gt; 300, "d" =&gt; 400 }) #=&gt; {"c"=&gt;300, "d"=&gt;400}</span></li><li data-letters="vc" class=""><span class="matching-letter">vc</span> <span class="TermText qDef lang-en">The first form transcodes the contents of str from str.encoding to<br>
encoding. The second form transcodes the contents of<br>
str from src_encoding to dst_encoding. The options Hash gives details for conversion. See #encode for details. Returns the<br>
string even if no changes were made.</span></li><li data-letters="vd" class=""><span class="matching-letter">vd</span> <span class="TermText qDef lang-en">syscall is essentially unsafe and unportable. Feel free to<br>
shoot your foot. DL (Fiddle) library is preferred for safer and a bit more<br>
portable programming.<br>
<br>
Calls the operating system function identified by _num_ and<br>
returns the result of the function or raises SystemCallError if<br>
it failed.<br>
<br>
Arguments for the function can follow _num_. They must be either<br>
+String+ objects or +Integer+ objects. A +String+ object is passed<br>
as a pointer to the byte sequence. An +Integer+ object is passed<br>
as an integer whose bit size is same as a pointer.<br>
Up to nine parameters may be passed (14 on the Atari-ST).<br>
<br>
The function identified by _num_ is system<br>
dependent. On some Unix systems, the numbers may be obtained from a<br>
header file called &lt;code&gt;syscall.h&lt;/code&gt;.<br>
<br>
 syscall 4, 1, "hello\n", 6 # '4' is write(2) on our box<br>
<br>
&lt;em&gt;produces:&lt;/em&gt;<br>
<br>
 hello<br>
<br>
Calling +syscall+ on a platform which does not have any way to<br>
an arbitrary system function just fails with NotImplementedError.</span></li><li data-letters="ve" class=""><span class="matching-letter">ve</span> <span class="TermText qDef lang-en">Returns true if the named file exists and the effective used<br>
id of the calling process is the owner of the file.</span></li><li data-letters="vf" class=""><span class="matching-letter">vf</span> <span class="TermText qDef lang-en">Element Assignment — Sets the element at index, or replaces a<br>
subarray from the start index for length<br>
elements, or replaces a subarray specified by the range of<br>
indices.<br>
<br>
a = Array.new<br>
a[4] = "4"; #=&gt; [nil, nil, nil, nil, "4"]<br>
a[0, 3] = [ 'a', 'b', 'c' ] #=&gt; ["a", "b", "c", nil, "4"]<br>
a[1..2] = [ 1, 2 ] #=&gt; ["a", 1, 2, nil, "4"]<br>
a[0, 2] = "?" #=&gt; ["?", 2, nil, "4"]<br>
a[0..2] = "A" #=&gt; ["A", "4"]<br>
a[-1] = "Z" #=&gt; ["A", "Z"]<br>
a[1..-1] = nil #=&gt; ["A", nil]<br>
a[1..-1] = [] #=&gt; ["A"]<br>
a[0, 0] = [ 1, 2 ] #=&gt; [1, 2, "A"]<br>
a[3, 0] = "B" #=&gt; [1, 2, "A", "B"]</span></li><li data-letters="vg" class=""><span class="matching-letter">vg</span> <span class="TermText qDef lang-en">Always returns an empty hash.<br>
<br>
nil.to_h #=&gt; {}</span></li><li data-letters="vh" class=""><span class="matching-letter">vh</span> <span class="TermText qDef lang-en">Performs multiplication: the class of the resulting object depends on the<br>
class of numeric and on the magnitude of the result.</span></li><li data-letters="vi" class=""><span class="matching-letter">vi</span> <span class="TermText qDef lang-en">Element Assignment—Replaces some or all of the content of str. The<br>
portion of the string affected is determined using the same criteria as<br>
String#[]. If the replacement string is not the same length as<br>
the text it is replacing, the string will be adjusted accordingly. If the<br>
regular expression or string is used as the index doesn't match a position<br>
in the string, IndexError is raised. If the regular expression<br>
form is used, the optional second Fixnum allows you to specify<br>
which portion of the match to replace (effectively using the<br>
MatchData indexing rules. The forms that take a<br>
Fixnum will raise an IndexError if the value is<br>
out of range; the Range form will raise a<br>
RangeError, and the Regexp and<br>
String will raise an IndexError on negative<br>
match.</span></li><li data-letters="vj" class=""><span class="matching-letter">vj</span> <span class="TermText qDef lang-en">Returns true if the current file has been closed; false<br>
otherwise. Use ARGF.close to actually close the current file.</span></li><li data-letters="vk" class=""><span class="matching-letter">vk</span> <span class="TermText qDef lang-en">Mark the object as untrusted.</span></li><li data-letters="vl" class=""><span class="matching-letter">vl</span> <span class="TermText qDef lang-en">With no associated block, File.open is a synonym for ::new. If the optional code block is<br>
given, it will be passed the opened file as an argument and<br>
the File object will automatically be closed when<br>
the block terminates. The value of the block will be returned from<br>
File.open.</span></li><li data-letters="vm" class=""><span class="matching-letter">vm</span> <span class="TermText qDef lang-en">Returns a replicated encoding of enc whose name is name.<br>
The new encoding should have the same byte structure of enc. If<br>
name is used by another encoding, raise ArgumentError.</span></li><li data-letters="vn" class=""><span class="matching-letter">vn</span> <span class="TermText qDef lang-en">Returns true if time represents Friday.<br>
<br>
t = Time.local(1987, 12, 18) #=&gt; 1987-12-18 00:00:00 -0600<br>
t.friday? #=&gt; true</span></li><li data-letters="vo" class=""><span class="matching-letter">vo</span> <span class="TermText qDef lang-en">Invokes the given block once for each element of self,<br>
replacing the element with the value returned by the block.<br>
<br>
a = [ "a", "b", "c", "d" ]<br>
a.map! {|x| x + "!" }<br>
a #=&gt; [ "a!", "b!", "c!", "d!" ]</span></li><li data-letters="vp" class=""><span class="matching-letter">vp</span> <span class="TermText qDef lang-en">Returns a hash value corresponding to proc body.</span></li><li data-letters="vq" class=""><span class="matching-letter">vq</span> <span class="TermText qDef lang-en">Returns the element at index. A negative index counts from the<br>
end of self. Returns nil if the index is out of<br>
range. See also Array#[].<br>
<br>
a = [ "a", "b", "c", "d", "e" ]<br>
a.at(0) #=&gt; "a"<br>
a.at(-1) #=&gt; "e"</span></li><li data-letters="vr" class=""><span class="matching-letter">vr</span> <span class="TermText qDef lang-en">Returns ios.</span></li><li data-letters="vs" class=""><span class="matching-letter">vs</span> <span class="TermText qDef lang-en">Returns true if obj is between the begin and end<br>
of the range.<br>
<br>
("a".."z").cover?("c") #=&gt; true<br>
("a".."z").cover?("5") #=&gt; false<br>
("a".."z").cover?("cc") #=&gt; true</span></li><li data-letters="vt" class=""><span class="matching-letter">vt</span> <span class="TermText qDef lang-en">Returns the index of the last object in self<br>
== to obj.<br>
<br>
a = [ "a", "b", "b", "b", "c" ]<br>
a.rindex("b") #=&gt; 3<br>
a.rindex("z") #=&gt; nil<br>
a.rindex { |x| x == "b" } #=&gt; 3</span></li><li data-letters="vu" class=""><span class="matching-letter">vu</span> <span class="TermText qDef lang-en">returns the indexth byte as an integer.</span></li><li data-letters="vv" class=""><span class="matching-letter">vv</span> <span class="TermText qDef lang-en">Changes the owner and group of file to the given numeric owner and<br>
group id's. Only a process with superuser privileges may change the owner<br>
of a file. The current owner of a file may change the file's group to any<br>
group to which the owner belongs. A nil or -1 owner or group<br>
id is ignored. Follows symbolic links. See also File#lchown.<br>
<br>
File.new("testfile").chown(502, 1000)</span></li><li data-letters="vw" class=""><span class="matching-letter">vw</span> <span class="TermText qDef lang-en">If Hash::new was invoked with a block, return that block,<br>
otherwise return nil.<br>
<br>
h = Hash.new {|h,k| h[k] = k*k } #=&gt; {}<br>
p = h.default_proc #=&gt; #&lt;Proc:0x401b3d08@-:1&gt;<br>
a = [] #=&gt; []<br>
p.call(a, 2)<br>
a #=&gt; [nil, nil, 4]</span></li><li data-letters="vx" class=""><span class="matching-letter">vx</span> <span class="TermText qDef lang-en">Removes the named instance variable from obj, returning that<br>
variable's value.<br>
<br>
class Dummy<br>
 attr_reader :var<br>
 def initialize<br>
 @var = 99<br>
 end<br>
 def remove<br>
 remove_instance_variable(:@var)<br>
 end<br>
end<br>
d = Dummy.new<br>
d.var #=&gt; 99<br>
d.remove #=&gt; 99<br>
d.var #=&gt; nil</span></li><li data-letters="vy" class=""><span class="matching-letter">vy</span> <span class="TermText qDef lang-en">Returns an array of the names of global variables.<br>
<br>
global_variables.grep /std/ #=&gt; [:$stdin, :$stdout, :$stderr]</span></li><li data-letters="vz" class=""><span class="matching-letter">vz</span> <span class="TermText qDef lang-en">Decodes str (which may contain binary data) according to the<br>
format string, returning an array of each value extracted. The format<br>
string consists of a sequence of single-character directives, summarized in<br>
the table at the end of this entry. Each directive may be followed by a<br>
number, indicating the number of times to repeat with this directive. An<br>
asterisk ("*") will use up all remaining elements. The<br>
directives sSiIlL may each be followed by an underscore<br>
("_") or exclamation mark ("!") to use the<br>
underlying platform's native size for the specified type; otherwise, it<br>
uses a platform-independent consistent size. Spaces are ignored in the<br>
format string. See also Array#pack.<br>
<br>
"abc \00\\00aabc \00\\00"".unpack('A6Z6') #=&gt; ["abc", "abc "]<br>
"abc \00\\00"".unpack('a3a3') #=&gt; ["abc", " \000\000"]<br>
"abc \00aabc \00"".unpack('Z<b>Z</b>') #=&gt; ["abc ", "abc "]<br>
"aa".unpack('b8B8') #=&gt; ["10000110", "01100001"]<br>
"aaa".unpack('h2H2c') #=&gt; ["16", "61", 97]<br>
"\xfe\xff\xfe\xff".unpack('sS') #=&gt; [-2, 65534]<br>
"now=20is".unpack('M*') #=&gt; ["now is"]<br>
"whole".unpack('xax2aX2aX1aX2a') #=&gt; ["h", "e", "l", "l", "o"]</span></li><li data-letters="wa" class=""><span class="matching-letter">wa</span> <span class="TermText qDef lang-en">Returns the numerator.</span></li><li data-letters="wb" class=""><span class="matching-letter">wb</span> <span class="TermText qDef lang-en">Returns 1.</span></li><li data-letters="wc" class=""><span class="matching-letter">wc</span> <span class="TermText qDef lang-en">Element Reference — If passed a single index, returns a<br>
substring of one character at that index. If passed a start<br>
index and a length, returns a substring containing<br>
length characters starting at the index. If<br>
passed a range, its beginning and end are interpreted as<br>
offsets delimiting the substring to be returned.<br>
<br>
a = "hello there"<br>
<br>
a[1] #=&gt; "e"<br>
a[2, 3] #=&gt; "llo"<br>
a[2..3] #=&gt; "ll"<br>
<br>
a[-3, 2] #=&gt; "er"<br>
a[7..-2] #=&gt; "her"<br>
a[-4..-2] #=&gt; "her"<br>
a[-2..-4] #=&gt; ""<br>
<br>
a[11, 0] #=&gt; ""<br>
a[11] #=&gt; nil<br>
a[12, 0] #=&gt; nil<br>
a[12..-1] #=&gt; nil<br>
<br>
a[/[aeiou](.)\1/] #=&gt; "ell"<br>
a[/[aeiou](.)\1/, 0] #=&gt; "ell"<br>
a[/[aeiou](.)\1/, 1] #=&gt; "l"<br>
a[/[aeiou](.)\1/, 2] #=&gt; nil<br>
<br>
a[/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/, "non_vowel"] #=&gt; "l"<br>
a[/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/, "vowel"] #=&gt; "e"<br>
<br>
a["lo"] #=&gt; "lo"<br>
a["bye"] #=&gt; nil</span></li><li data-letters="wd" class=""><span class="matching-letter">wd</span> <span class="TermText qDef lang-en">Returns true if ios is at end of file that means there are no more<br>
data to read. The stream must be opened for reading or an<br>
IOError will be raised.<br>
<br>
f = File.new("testfile")<br>
dummy = f.readlines<br>
f.eof #=&gt; true</span></li><li data-letters="we" class=""><span class="matching-letter">we</span> <span class="TermText qDef lang-en">Returns true if the named file is readable by the effective<br>
user id of this process.</span></li><li data-letters="wf" class=""><span class="matching-letter">wf</span> <span class="TermText qDef lang-en">Compares symbol with other_symbol after calling<br>
to_s on each of the symbols.<br>
Returns -1, 0, +1 or nil depending on whether symbol is less<br>
than, equal to, or greater than other_symbol.<br>
<br>
+nil+ is returned if the two values are incomparable.</span></li><li data-letters="wg" class=""><span class="matching-letter">wg</span> <span class="TermText qDef lang-en">The first form returns a copy of str transcoded to encoding<br>
encoding. The second form returns a copy of str<br>
transcoded from src_encoding to dst_encoding. The last form returns a copy<br>
of str transcoded to Encoding.default_internal.</span></li><li data-letters="wh" class=""><span class="matching-letter">wh</span> <span class="TermText qDef lang-en">Returns the floating point result of dividing fix by<br>
numeric.<br>
<br>
654321.fdiv(13731) #=&gt; 47.6528293642124<br>
654321.fdiv(13731.24) #=&gt; 47.6519964693647</span></li><li data-letters="wi" class=""><span class="matching-letter">wi</span> <span class="TermText qDef lang-en">Returns a string containing the regular expression and its options (using<br>
the (?opts:source) notation. This string can be fed back in to<br>
Regexp::new to a regular expression with the same semantics as<br>
the original. (However, Regexp#== may not return true when<br>
comparing the two, as the source of the regular expression itself may<br>
differ, as the example shows). Regexp#inspect produces a<br>
generally more readable version of rxp.<br>
<br>
r1 = /ab+c/x #=&gt; /ab+c/ix<br>
s1 = r1.to_s #=&gt; "(?ix-m:ab+c)"<br>
r2 = Regexp.new(s1) #=&gt; /(?ix-m:ab+c)/<br>
r1 == r2 #=&gt; false<br>
r1.source #=&gt; "ab+c"<br>
r2.source #=&gt; "(?ix-m:ab+c)"</span></li><li data-letters="wj" class=""><span class="matching-letter">wj</span> <span class="TermText qDef lang-en">Converts arg to a Fixnum or Bignum. Numeric types are converted directly (with floating<br>
point numbers being truncated). base (0, or between 2 and 36)<br>
is a base for integer string representation. If arg is a<br>
String, when base is omitted or equals to zero, radix<br>
indicators (0, 0b, and 0x) are<br>
honored. In any case, strings should be strictly conformed to numeric<br>
representation. This behavior is different from that of<br>
String#to_i. Non string values will be converted using<br>
to_int, and to_i.<br>
<br>
Integer(123.999) #=&gt; 123<br>
Integer("0x1a") #=&gt; 26<br>
Integer(Time.new) #=&gt; 1204973019<br>
Integer("0930", 10) #=&gt; 930<br>
Integer("111", 2) #=&gt; 7</span></li><li data-letters="wk" class=""><span class="matching-letter">wk</span> <span class="TermText qDef lang-en">Returns a one-character string at the beginning of the string.<br>
<br>
a = "abcde"<br>
a.chr #=&gt; "a"</span></li><li data-letters="wl" class=""><span class="matching-letter">wl</span> <span class="TermText qDef lang-en">Returns arg as an Array.<br>
<br>
Array(1..5) #=&gt; [1, 2, 3, 4, 5]</span></li><li data-letters="wm" class=""><span class="matching-letter">wm</span> <span class="TermText qDef lang-en">Evaluates the Ruby expression(s) in string. If binding is<br>
given, which must be a Binding object, the evaluation is<br>
performed in its context. If the optional filename and<br>
lineno parameters are present, they will be used when reporting<br>
syntax errors.<br>
<br>
def get_binding(str)<br>
 return binding<br>
end<br>
str = "hello"<br>
eval "str + ' Fred'" #=&gt; "hello Fred"<br>
eval "str + ' Fred'", get_binding("bye") #=&gt; "bye Fred"</span></li><li data-letters="wn" class=""><span class="matching-letter">wn</span> <span class="TermText qDef lang-en">Reads the next character from ARGF and returns it as a<br>
String. Raises an EOFError after the last<br>
character of the last file has been read.<br>
<br>
$ echo "foo" &gt; file<br>
$ ruby argf.rb file<br>
<br>
ARGF.readchar #=&gt; "f"<br>
ARGF.readchar #=&gt; "o"<br>
ARGF.readchar #=&gt; "o"<br>
ARGF.readchar #=&gt; "\n"<br>
ARGF.readchar #=&gt; end of file reached (EOFError)</span></li><li data-letters="wo" class=""><span class="matching-letter">wo</span> <span class="TermText qDef lang-en">Returns true if the named public method is defined by<br>
mod (or its included modules and, if mod is a class, its<br>
ancestors). String arguments are converted to<br>
symbols.<br>
<br>
module A<br>
 def method1() end<br>
end<br>
class B<br>
 protected<br>
 def method2() end<br>
end<br>
class C &lt; B<br>
 include A<br>
 def method3() end<br>
end<br>
<br>
A.method_defined? :method1 #=&gt; true<br>
C.public_method_defined? "method1" #=&gt; true<br>
C.public_method_defined? "method2" #=&gt; false<br>
C.method_defined? "method2" #=&gt; true</span></li><li data-letters="wp" class=""><span class="matching-letter">wp</span> <span class="TermText qDef lang-en">Same as ::gm, but interprets the values<br>
in the local time zone.<br>
<br>
Time.local(2000,"jan",1,20,15,1) #=&gt; 2000-01-01 20:15:01 -0600</span></li><li data-letters="wq" class=""><span class="matching-letter">wq</span> <span class="TermText qDef lang-en">Returns an array of every element in enum for which Pattern<br>
=== element. If the optional block is supplied, each<br>
matching element is passed to it, and the block's result is stored in the<br>
output array.<br>
<br>
(1..100).grep 38..44 #=&gt; [38, 39, 40, 41, 42, 43, 44]<br>
c = IO.constants<br>
c.grep(/SEEK/) #=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]<br>
res = c.grep(/SEEK/) { |v| IO.const_get(v) }<br>
res #=&gt; [0, 1, 2]</span></li><li data-letters="wr" class=""><span class="matching-letter">wr</span> <span class="TermText qDef lang-en">Returns the size of file in bytes.<br>
<br>
File.new("testfile").size #=&gt; 66</span></li><li data-letters="ws" class=""><span class="matching-letter">ws</span> <span class="TermText qDef lang-en">Closes ios and flushes any pending writes to the operating system.<br>
The stream is unavailable for any further data operations; an<br>
IOError is raised if such an attempt is made. I/O streams are<br>
automatically closed when they are claimed by the garbage collector.</span></li><li data-letters="wt" class=""><span class="matching-letter">wt</span> <span class="TermText qDef lang-en">Invoked by Ruby when obj is sent a message it cannot handle.<br>
symbol is the symbol for the method called, and args are<br>
any arguments that were passed to it. By default, the interpreter raises an<br>
error when this method is called. However, it is possible to override the<br>
method to provide more dynamic behavior. If it is decided that a particular<br>
method should not be handled, then super should be called, so that<br>
ancestors can pick up the missing method. The example below creates a class<br>
Roman, which responds to methods with names consisting of<br>
roman numerals, returning the corresponding integer values.<br>
<br>
class Roman<br>
 def roman_to_int(str)<br>
 # ...<br>
 end<br>
 def method_missing(methId)<br>
 str = methId.id2name<br>
 roman_to_int(str)<br>
 end<br>
end<br>
<br>
r = Roman.new<br>
r.iv #=&gt; 4<br>
r.xxiii #=&gt; 23<br>
r.mm #=&gt; 2000</span></li><li data-letters="wu" class=""><span class="matching-letter">wu</span> <span class="TermText qDef lang-en">Returns true if module is included in mod or<br>
one of mod's ancestors.<br>
<br>
module A<br>
end<br>
class B<br>
 include A<br>
end<br>
class C &lt; B<br>
end<br>
B.include?(A) #=&gt; true<br>
C.include?(A) #=&gt; true<br>
A.include?(A) #=&gt; false</span></li><li data-letters="wv" class=""><span class="matching-letter">wv</span> <span class="TermText qDef lang-en">Returns true if the named files are identical.<br>
<br>
open("a", "w") {}<br>
p File.identical?("a", "a") #=&gt; true<br>
p File.identical?("a", "./a") #=&gt; true<br>
File.link("a", "b")<br>
p File.identical?("a", "b") #=&gt; true<br>
File.symlink("a", "c")<br>
p File.identical?("a", "c") #=&gt; true<br>
open("d", "w") {}<br>
p File.identical?("a", "d") #=&gt; false</span></li><li data-letters="ww" class=""><span class="matching-letter">ww</span> <span class="TermText qDef lang-en">Comparison—Returns -1, 0, +1 or nil depending on whether<br>
module includes other_module, they are the same,<br>
or if module is included by other_module. This is<br>
the basis for the tests in Comparable.</span></li><li data-letters="wx" class=""><span class="matching-letter">wx</span> <span class="TermText qDef lang-en">Loads the given name, returning true if<br>
successful and false if the feature is already loaded.<br>
<br>
require "my-library.rb"<br>
require "db-driver"</span></li><li data-letters="wy" class=""><span class="matching-letter">wy</span> <span class="TermText qDef lang-en">Transfers control to the end of the active catch block waiting<br>
for tag. Raises ArgumentError if there is no<br>
catch block for the tag. The optional second<br>
parameter supplies a return value for the catch block, which<br>
otherwise defaults to nil. For examples, see<br>
Kernel::catch.</span></li><li data-letters="wz" class=""><span class="matching-letter">wz</span> <span class="TermText qDef lang-en">Returns a list of the names of public and protected methods of<br>
obj. This will include all the methods accessible in<br>
obj's ancestors. If the regular parameter is set to<br>
false, Returns an array of obj's public and protected<br>
singleton methods, the array will not include methods in modules included<br>
in obj.<br>
<br>
class Klass<br>
 def klass_method()<br>
 end<br>
end<br>
k = Klass.new<br>
k.methods[0..9] #=&gt; [:klass_method, :nil?, :===,<br>
 # :==~, :!, :eql?<br>
 # :hash, :&lt;=&gt;, :class, :singleton_class]<br>
k.methods.length #=&gt; 57<br>
<br>
k.methods(false) #=&gt; []<br>
def k.singleton_method; end<br>
k.methods(false) #=&gt; [:singleton_method]<br>
<br>
module M123; def m123; end end<br>
k.extend M123<br>
k.methods(false) #=&gt; [:singleton_method]</span></li><li data-letters="xa" class=""><span class="matching-letter">xa</span> <span class="TermText qDef lang-en">Returns the floating point result of dividing big by<br>
numeric.<br>
<br>
-1234567890987654321.fdiv(13731) #=&gt; -89910996357705.5<br>
-1234567890987654321.fdiv(13731.24) #=&gt; -89909424858035.7</span></li><li data-letters="xb" class=""><span class="matching-letter">xb</span> <span class="TermText qDef lang-en">Returns a new float which is the sum of float and<br>
other.</span></li><li data-letters="xc" class=""><span class="matching-letter">xc</span> <span class="TermText qDef lang-en">Same as sym.to_s.length.</span></li><li data-letters="xd" class=""><span class="matching-letter">xd</span> <span class="TermText qDef lang-en">Returns the set of bits corresponding to the options used when creating<br>
this Regexp (see Regexp::new for<br>
details. Note that additional bits may be set in the returned options:<br>
these are used internally by the regular expression code. These extra bits<br>
are ignored if the options are passed to Regexp::new.<br>
<br>
Regexp::IGNORECASE #=&gt; 1<br>
Regexp::EXTENDED #=&gt; 2<br>
Regexp::MULTILINE #=&gt; 4<br>
<br>
/cat/.options #=&gt; 0<br>
/cat/x.options #=&gt; 3<br>
Regexp.new('cat', true).options #=&gt; 1<br>
/\xa1\xa2/.options #=&gt; 16<br>
<br>
r = /cat/x<br>
Regexp.new(r.source, r.options) #=&gt; /cat/ix</span></li><li data-letters="xe" class=""><span class="matching-letter">xe</span> <span class="TermText qDef lang-en">The equivalent of included, but for prepended modules.<br>
<br>
module A<br>
 def self.prepended(mod)<br>
 puts "#{self} prepended to #{mod}"<br>
 end<br>
end<br>
module Enumerable<br>
 prepend A<br>
end<br>
 # =&gt; prints "A prepended to Enumerable"</span></li></ol><div class="clear"></div>			<p class="textright submit-button">
				<input tabindex="630" value="Create new test" onclick="return checkAnswers(this)" class="large button" type="button">
			</p>
			</div></div>
	
	</div>
</div>
</main>
		
	<script>QPAGE="Test\"index".replace(/"/g, '/');_qoptions={qacct:"p-5brKQLtleyIQU"};_comscore=[{c1:"2",c2:"8641686"}];_gaq.push(['_trackPageview',QPAGE]);QWait('dom',function(){var urls=["https://ssl.google-analytics.com/ga.js","https://secure.quantserve.com/quant.js","https://sb.scorecardresearch.com/beacon.js"];var b=document.getElementsByTagName('script')[0];for(var i=0;i<urls.length;i++){var s = document.createElement('script');s.type='text/javascript';s.async=true;s.src=urls[i];b.parentNode.insertBefore(s,b);}});</script><noscript><img src="https://sb.scorecardresearch.com/p?c1=2&amp;c2=8641686&amp;cv=2.0&amp;cj=1" alt="" /></noscript><script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"bam.nr-data.net","licenseKey":"a92c37725f","applicationID":"124534","transactionName":"YVcEY0EAXUJYVkUMDlgdJUJAFVxcFmFUFhUZWwhTVhk=","queueTime":0,"applicationTime":982,"atts":"TRAHFQkaTkw=","errorBeacon":"bam.nr-data.net","agent":""}</script>




<div class="mobile-nav">
	<a class="return-to-site" id="deactivate-nav" href="#"></a>

	<div class="scrollable-nav">
						<a class="create-set" href="https://quizlet.com/create-set">
			<span class="glyph icon create-set-icon "></span>			<span class="label">Create Study Set</span>
		</a>
					<div class="empty side-nav">
				<section>
					<ul>
						<li>
							<a href="https://quizlet.com/latest">
								<span class="glyph icon arrow-left-icon "></span>								<span class="label">Back to your sets</span>
							</a>
						</li>
					</ul>
				</section>
			</div>
			</div>
</div>


<script type="text/javascript">QWait("dom",function(){var a=document.body,b=document.getElementById("activate-nav"),c=document.getElementById("activate-search"),d=document.getElementById("deactivate-search"),e=document.getElementById("deactivate-nav");null!==b&&(b.onclick=function(){a.className=a.className.replace(" navActivated","")+" navActivated";return!1});null!==e&&(e.onclick=function(){a.className=a.className.replace(" navActivated","");return!1});null!==c&&(c.onclick=function(){a.className=a.className.replace(" searchActivated",
"")+" searchActivated";document.getElementById("header-search").focus();return!1});null!==d&&(d.onclick=function(){a.className=a.className.replace(" searchActivated","");return!1})});
</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74639447-2', 'auto');
  ga('send', 'pageview');

</script> <iframe src="https://www.google.com/recaptcha/api2/aframe" width="0" height="0" style="display: none;"></iframe></body><iframe id="google_esf" name="google_esf" src="https://googleads.g.doubleclick.net/pagead/html/r20211207/r20190131/zrt_lookup.html" style="display: none;"></iframe></html>